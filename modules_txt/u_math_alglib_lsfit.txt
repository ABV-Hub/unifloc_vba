''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2006-2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Least squares fitting report:
'    TaskRCond       reciprocal of task's condition number
'    RMSError        RMS error
'    AvgError        average error
'    AvgRelError     average relative error (for non-zero Y[I])
'    MaxError        maximum error
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type LSFitReport
    TaskRCond As Double
    RMSError As Double
    AvgError As Double
    AvgRelError As Double
    MaxError As Double
End Type
Public Type LSFitState
    N As Long
    M As Long
    K As Long
    EpsF As Double
    EpsX As Double
    MaxIts As Long
    STPMAX As Double
    TaskX() As Double
    TaskY() As Double
    W() As Double
    CheapFG As Boolean
    HaveHess As Boolean
    NeedF As Boolean
    NeedFG As Boolean
    NeedFGH As Boolean
    PointIndex As Long
    x() As Double
    C() As Double
    F As Double
    G() As Double
    H() As Double
    RepTerminationType As Long
    RepRMSError As Double
    RepAvgError As Double
    RepAvgRelError As Double
    RepMaxError As Double
    OptState As MinLMState
    OptRep As MinLMReport
    RState As RCommState
End Type
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted linear least squares fitting.
'
'QR decomposition is used to reduce task to MxM, then triangular solver  or
'SVD-based solver is used depending on condition number of the  system.  It
'allows to maximize speed and retain decent accuracy.
'
'INPUT PARAMETERS:
'    Y       -   array[0..N-1] Function values in  N  points.
'    W       -   array[0..N-1]  Weights  corresponding to function  values.
'                Each summand in square  sum  of  approximation  deviations
'                from  given  values  is  multiplied  by  the   square   of
'                corresponding weight.
'    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                FMatrix[I, J] - value of J-th basis function in I-th point.
'    N       -   number of points used. N>=1.
'    M       -   number of basis functions, M>=1.
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -4    internal SVD decomposition subroutine failed (very
'                        rare and for degenerate systems only)
'                * -1    incorrect N/M were specified
'                *  1    task is solved
'    C       -   decomposition coefficients, array[0..M-1]
'    Rep     -   fitting report. Following fields are set:
'                * Rep.TaskRCond     reciprocal of condition number
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'SEE ALSO
'    LSFitLinear
'    LSFitLinearC
'    LSFitLinearWC
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearW(ByRef Y() As Double, _
         ByRef W() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Call LSFitLinearInternal(Y, W, FMatrix, N, M, Info, C, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted constained linear least squares fitting.
'
'This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
'that  K  additional  constaints  C*x=bc are satisfied. It reduces original
'task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
'is called.
'
'INPUT PARAMETERS:
'    Y       -   array[0..N-1] Function values in  N  points.
'    W       -   array[0..N-1]  Weights  corresponding to function  values.
'                Each summand in square  sum  of  approximation  deviations
'                from  given  values  is  multiplied  by  the   square   of
'                corresponding weight.
'    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
'                FMatrix[I,J] - value of J-th basis function in I-th point.
'    CMatrix -   a table of constaints, array[0..K-1,0..M].
'                I-th row of CMatrix corresponds to I-th linear constraint:
'                CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
'    N       -   number of points used. N>=1.
'    M       -   number of basis functions, M>=1.
'    K       -   number of constraints, 0 <= K < M
'                K=0 corresponds to absence of constraints.
'
'OUTPUT PARAMETERS:
'    Info    -   error code:
'                * -4    internal SVD decomposition subroutine failed (very
'                        rare and for degenerate systems only)
'                * -3    either   too   many  constraints  (M   or   more),
'                        degenerate  constraints   (some   constraints  are
'                        repetead twice) or inconsistent  constraints  were
'                        specified.
'                * -1    incorrect N/M/K were specified
'                *  1    task is solved
'    C       -   decomposition coefficients, array[0..M-1]
'    Rep     -   fitting report. Following fields are set:
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'IMPORTANT:
'    this subroitine doesn't calculate task's condition number for K<>0.
'
'SEE ALSO
'    LSFitLinear
'    LSFitLinearC
'    LSFitLinearWC
'
'  -- ALGLIB --
'     Copyright 07.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearWC(ByRef Y_() As Double, _
         ByRef W() As Double, _
         ByRef FMatrix() As Double, _
         ByRef CMatrix_() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim Y() As Double
    Dim CMatrix() As Double
    Dim i As Long
    Dim J As Long
    Dim Tau() As Double
    Dim Q() As Double
    Dim F2() As Double
    Dim Tmp() As Double
    Dim C0() As Double
    Dim V As Double
    Dim i_ As Long
    Y = Y_
    CMatrix = CMatrix_
    If N < 1# Or M < 1# Or K < 0# Then
        Info = -1#
        Exit Sub
    End If
    If K >= M Then
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Solve
    '
    If K = 0# Then
        
        '
        ' no constraints
        '
        Call LSFitLinearInternal(Y, W, FMatrix, N, M, Info, C, Rep)
    Else
        
        '
        ' First, find general form solution of constraints system:
        ' * factorize C = L*Q
        ' * unpack Q
        ' * fill upper part of C with zeros (for RCond)
        '
        ' We got C=C0+Q2'*y where Q2 is lower M-K rows of Q.
        '
        Call RMatrixLQ(CMatrix, K, M, Tau)
        Call RMatrixLQUnpackQ(CMatrix, K, M, Tau, M, Q)
        For i = 0# To K - 1# Step 1
            For J = i + 1# To M - 1# Step 1
                CMatrix(i, J) = 0#
            Next J
        Next i
        If RMatrixLURCondInf(CMatrix, K) < 1000# * MachineEpsilon Then
            Info = -3#
            Exit Sub
        End If
        ReDim Tmp(0 To K - 1)
        For i = 0# To K - 1# Step 1
            If i > 0# Then
                V = 0#
                For i_ = 0# To i - 1# Step 1
                    V = V + CMatrix(i, i_) * Tmp(i_)
                Next i_
            Else
                V = 0#
            End If
            Tmp(i) = (CMatrix(i, M) - V) / CMatrix(i, i)
        Next i
        ReDim C0(0 To M - 1)
        For i = 0# To M - 1# Step 1
            C0(i) = 0#
        Next i
        For i = 0# To K - 1# Step 1
            V = Tmp(i)
            For i_ = 0# To M - 1# Step 1
                C0(i_) = C0(i_) + V * Q(i, i_)
            Next i_
        Next i
        
        '
        ' Second, prepare modified matrix F2 = F*Q2' and solve modified task
        '
        ReDim Tmp(0 To MaxInt(N, M) + 1# - 1)
        ReDim F2(0 To N - 1, 0 To M - K - 1)
        Call MatrixVectorMultiply(FMatrix, 0#, N - 1#, 0#, M - 1#, False, C0, 0#, M - 1#, -1#, Y, 0#, N - 1#, 1#)
        Call MatrixMatrixMultiply(FMatrix, 0#, N - 1#, 0#, M - 1#, False, Q, K, M - 1#, 0#, M - 1#, True, 1#, F2, 0#, N - 1#, 0#, M - K - 1#, 0#, Tmp)
        Call LSFitLinearInternal(Y, W, F2, N, M - K, Info, Tmp, Rep)
        Rep.TaskRCond = -1#
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' then, convert back to original answer: C = C0 + Q2'*Y0
        '
        ReDim C(0 To M - 1)
        For i_ = 0# To M - 1# Step 1
            C(i_) = C0(i_)
        Next i_
        Call MatrixVectorMultiply(Q, K, M - 1#, 0#, M - 1#, True, Tmp, 0#, M - K - 1#, 1#, C, 0#, M - 1#, 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Linear least squares fitting, without weights.
'
'See LSFitLinearW for more information.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinear(ByRef Y() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim W() As Double
    Dim i As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim W(0 To N - 1)
    For i = 0# To N - 1# Step 1
        W(i) = 1#
    Next i
    Call LSFitLinearInternal(Y, W, FMatrix, N, M, Info, C, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Constained linear least squares fitting, without weights.
'
'See LSFitLinearWC() for more information.
'
'  -- ALGLIB --
'     Copyright 07.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitLinearC(ByRef Y_() As Double, _
         ByRef FMatrix() As Double, _
         ByRef CMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim Y() As Double
    Dim W() As Double
    Dim i As Long
    Y = Y_
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    ReDim W(0 To N - 1)
    For i = 0# To N - 1# Step 1
        W(i) = 1#
    Next i
    Call LSFitLinearWC(Y, W, FMatrix, CMatrix, N, M, K, Info, C, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted nonlinear least squares fitting using gradient and Hessian.
'
'Nonlinear task min(F(c)) is solved, where
'
'    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,
'
'    * N is a number of points,
'    * M is a dimension of a space points belong to,
'    * K is a dimension of a space of parameters being fitted,
'    * w is an N-dimensional vector of weight coefficients,
'    * x is a set of N points, each of them is an M-dimensional vector,
'    * c is a K-dimensional vector of parameters being fitted
'
'This subroutine uses only f(x[i],c) and its gradient.
'
'INPUT PARAMETERS:
'    X       -   array[0..N-1,0..M-1], points (one row = one point)
'    Y       -   array[0..N-1], function values.
'    W       -   weights, array[0..N-1]
'    C       -   array[0..K-1], initial approximation to the solution,
'    N       -   number of points, N>1
'    M       -   dimension of space
'    K       -   number of parameters being fitted
'    CheapFG -   boolean flag, which is:
'                * True  if both function and gradient calculation complexity
'                        are less than O(M^2).  An improved  algorithm  can
'                        be  used  which corresponds  to  FGJ  scheme  from
'                        MINLM unit.
'                * False otherwise.
'                        Standard Jacibian-bases  Levenberg-Marquardt  algo
'                        will be used (FJ scheme).
'
'OUTPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls  of   LSFitNonlinearIteration.   Used  for  reverse
'                communication.  This  structure   should   be  passed  to
'                LSFitNonlinearIteration subroutine.
'
'See also:
'    LSFitNonlinearIteration
'    LSFitNonlinearResults
'    LSFitNonlinearFG (fitting without weights)
'    LSFitNonlinearWFGH (fitting using Hessian)
'    LSFitNonlinearFGH (fitting using Hessian, without weights)
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearWFG(ByRef x() As Double, _
         ByRef Y() As Double, _
         ByRef W() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByVal CheapFG As Boolean, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = CheapFG
    State.HaveHess = False
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.W(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i_ = 0# To N - 1# Step 1
            State.W(i_) = W(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting, no individual weights.
'See LSFitNonlinearWFG for more information.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearFG(ByRef x() As Double, _
         ByRef Y() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByVal CheapFG As Boolean, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = CheapFG
    State.HaveHess = False
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.W(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
            State.W(i) = 1#
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Weighted nonlinear least squares fitting using gradient/Hessian.
'
'Nonlinear task min(F(c)) is solved, where
'
'    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,
'
'    * N is a number of points,
'    * M is a dimension of a space points belong to,
'    * K is a dimension of a space of parameters being fitted,
'    * w is an N-dimensional vector of weight coefficients,
'    * x is a set of N points, each of them is an M-dimensional vector,
'    * c is a K-dimensional vector of parameters being fitted
'
'This subroutine uses f(x[i],c), its gradient and its Hessian.
'
'See LSFitNonlinearWFG() subroutine for information about function
'parameters.
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearWFGH(ByRef x() As Double, _
         ByRef Y() As Double, _
         ByRef W() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = True
    State.HaveHess = True
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.W(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i_ = 0# To N - 1# Step 1
            State.W(i_) = W(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting using gradient/Hessian without  individual
'weights. See LSFitNonlinearWFGH() for more information.
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearFGH(ByRef x() As Double, _
         ByRef Y() As Double, _
         ByRef C() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByVal K As Long, _
         ByRef State As LSFitState)
    Dim i As Long
    Dim i_ As Long
    State.N = N
    State.M = M
    State.K = K
    Call LSFitNonlinearSetCond(State, 0#, 0#, 0#)
    Call LSFitNonlinearSetStpMax(State, 0#)
    State.CheapFG = True
    State.HaveHess = True
    If N >= 1# And M >= 1# And K >= 1# Then
        ReDim State.TaskX(0 To N - 1, 0 To M - 1)
        ReDim State.TaskY(0 To N - 1)
        ReDim State.W(0 To N - 1)
        ReDim State.C(0 To K - 1)
        For i_ = 0# To K - 1# Step 1
            State.C(i_) = C(i_)
        Next i_
        For i = 0# To N - 1# Step 1
            For i_ = 0# To M - 1# Step 1
                State.TaskX(i, i_) = x(i, i_)
            Next i_
            State.TaskY(i) = Y(i)
            State.W(i) = 1#
        Next i
    End If
    ReDim State.RState.IA(0# To 4#)
    ReDim State.RState.RA(0# To 1#)
    State.RState.Stage = -1#
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Stopping conditions for nonlinear least squares fitting.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be initialized
'                with LSFitNonLinearCreate???()
'    EpsF    -   stopping criterion. Algorithm stops if
'                |F(k+1)-F(k)| <= EpsF*max{|F(k)|, |F(k+1)|, 1}
'    EpsX    -   stopping criterion. Algorithm stops if
'                |X(k+1)-X(k)| <= EpsX*(1+|X(k)|)
'    MaxIts  -   stopping criterion. Algorithm stops after MaxIts iterations.
'                MaxIts=0 means no stopping criterion.
'
'NOTE
'
'Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
'stopping criterion selection (according to the scheme used by MINLM unit).
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearSetCond(ByRef State As LSFitState, _
         ByVal EpsF As Double, _
         ByVal EpsX As Double, _
         ByVal MaxIts As Long)
    State.EpsF = EpsF
    State.EpsX = EpsX
    State.MaxIts = MaxIts
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This function sets maximum step length
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between calls and
'                which is used for reverse communication. Must be
'                initialized with LSFitNonLinearCreate???()
'    StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
'                want to limit step length.
'
'Use this subroutine when you optimize target function which contains exp()
'or  other  fast  growing  functions,  and optimization algorithm makes too
'large  steps  which  leads  to overflow. This function allows us to reject
'steps  that  are  too  large  (and  therefore  expose  us  to the possible
'overflow) without actually calculating function value at the x+stp*d.
'
'NOTE: non-zero StpMax leads to moderate  performance  degradation  because
'intermediate  step  of  preconditioned L-BFGS optimization is incompatible
'with limits on step size.
'
'  -- ALGLIB --
'     Copyright 02.04.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearSetStpMax(ByRef State As LSFitState, _
         ByVal STPMAX As Double)
    State.STPMAX = STPMAX
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting. Algorithm iteration.
'
'Called after inialization of the State structure with  LSFitNonlinearXXX()
'subroutine. See HTML docs for examples.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between  subsequent
'                calls and which is used for reverse communication. Must be
'                initialized with LSFitNonlinearXXX() call first.
'
'RESULT
'1. If subroutine returned False, iterative algorithm has converged.
'2. If subroutine returned True, then if:
'* if State.NeedF=True,      function value F(X,C) is required
'* if State.NeedFG=True,     function value F(X,C) and gradient  dF/dC(X,C)
'                            are required
'* if State.NeedFGH=True     function value F(X,C), gradient dF/dC(X,C) and
'                            Hessian are required
'
'One and only one of this fields can be set at time.
'
'Function, its gradient and Hessian are calculated at  (X,C),  where  X  is
'stored in State.X[0..M-1] and C is stored in State.C[0..K-1].
'
'Results are stored:
'* function value            -   in State.F
'* gradient                  -   in State.G[0..K-1]
'* Hessian                   -   in State.H[0..K-1,0..K-1]
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function LSFitNonlinearIteration(ByRef State As LSFitState) As Boolean
    Dim Result As Boolean
    Dim N As Long
    Dim M As Long
    Dim K As Long
    Dim i As Long
    Dim J As Long
    Dim V As Double
    Dim RelCnt As Double
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If State.RState.Stage >= 0# Then
        N = State.RState.IA(0#)
        M = State.RState.IA(1#)
        K = State.RState.IA(2#)
        i = State.RState.IA(3#)
        J = State.RState.IA(4#)
        V = State.RState.RA(0#)
        RelCnt = State.RState.RA(1#)
    Else
        N = -983#
        M = -989#
        K = -834#
        i = 900#
        J = -287#
        V = 364#
        RelCnt = 214#
    End If
    If State.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    If State.RState.Stage = 1# Then
        GoTo lbl_1
    End If
    If State.RState.Stage = 2# Then
        GoTo lbl_2
    End If
    If State.RState.Stage = 3# Then
        GoTo lbl_3
    End If
    If State.RState.Stage = 4# Then
        GoTo lbl_4
    End If
    
    '
    ' Routine body
    '
    
    '
    ' check params
    '
    If State.N < 1# Or State.M < 1# Or State.K < 1# Or State.EpsF < 0# Or State.EpsX < 0# Or State.MaxIts < 0# Then
        State.RepTerminationType = -1#
        Result = False
        LSFitNonlinearIteration = Result
        Exit Function
    End If
    
    '
    ' init
    '
    N = State.N
    M = State.M
    K = State.K
    ReDim State.x(0 To M - 1)
    ReDim State.G(0 To K - 1)
    If State.HaveHess Then
        ReDim State.H(0 To K - 1, 0 To K - 1)
    End If
    
    '
    ' initialize LM optimizer
    '
    If State.HaveHess Then
        
        '
        ' use Hessian.
        ' transform stopping conditions.
        '
        Call MinLMCreateFGH(K, State.C, State.OptState)
    Else
        
        '
        ' use one of gradient-based schemes (depending on gradient cost).
        ' transform stopping conditions.
        '
        If State.CheapFG Then
            Call MinLMCreateFGJ(K, N, State.C, State.OptState)
        Else
            Call MinLMCreateFJ(K, N, State.C, State.OptState)
        End If
    End If
    Call MinLMSetCond(State.OptState, 0#, State.EpsF, State.EpsX, State.MaxIts)
    Call MinLMSetStpMax(State.OptState, State.STPMAX)
    
    '
    ' Optimize
    '
lbl_5:
    If Not MinLMIteration(State.OptState) Then
        GoTo lbl_6
    End If
    If Not State.OptState.NeedF Then
        GoTo lbl_7
    End If
    
    '
    ' calculate F = sum (wi*(f(xi,c)-yi))^2
    '
    State.OptState.F = 0#
    i = 0#
lbl_9:
    If i > N - 1# Then
        GoTo lbl_11
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    State.OptState.F = State.OptState.F + Square(State.W(i) * (State.F - State.TaskY(i)))
    i = i + 1#
    GoTo lbl_9
lbl_11:
    GoTo lbl_5
lbl_7:
    If Not State.OptState.NeedFG Then
        GoTo lbl_12
    End If
    
    '
    ' calculate F/gradF
    '
    State.OptState.F = 0#
    For i = 0# To K - 1# Step 1
        State.OptState.G(i) = 0#
    Next i
    i = 0#
lbl_14:
    If i > N - 1# Then
        GoTo lbl_16
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 1#
    GoTo lbl_rcomm
lbl_1:
    State.OptState.F = State.OptState.F + Square(State.W(i) * (State.F - State.TaskY(i)))
    V = Square(State.W(i)) * 2# * (State.F - State.TaskY(i))
    For i_ = 0# To K - 1# Step 1
        State.OptState.G(i_) = State.OptState.G(i_) + V * State.G(i_)
    Next i_
    i = i + 1#
    GoTo lbl_14
lbl_16:
    GoTo lbl_5
lbl_12:
    If Not State.OptState.NeedFiJ Then
        GoTo lbl_17
    End If
    
    '
    ' calculate Fi/jac(Fi)
    '
    i = 0#
lbl_19:
    If i > N - 1# Then
        GoTo lbl_21
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFG = True
    State.RState.Stage = 2#
    GoTo lbl_rcomm
lbl_2:
    State.OptState.FI(i) = State.W(i) * (State.F - State.TaskY(i))
    V = State.W(i)
    For i_ = 0# To K - 1# Step 1
        State.OptState.J(i, i_) = V * State.G(i_)
    Next i_
    i = i + 1#
    GoTo lbl_19
lbl_21:
    GoTo lbl_5
lbl_17:
    If Not State.OptState.NeedFGH Then
        GoTo lbl_22
    End If
    
    '
    ' calculate F/grad(F)/hess(F)
    '
    State.OptState.F = 0#
    For i = 0# To K - 1# Step 1
        State.OptState.G(i) = 0#
    Next i
    For i = 0# To K - 1# Step 1
        For J = 0# To K - 1# Step 1
            State.OptState.H(i, J) = 0#
        Next J
    Next i
    i = 0#
lbl_24:
    If i > N - 1# Then
        GoTo lbl_26
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.OptState.x(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedFGH = True
    State.RState.Stage = 3#
    GoTo lbl_rcomm
lbl_3:
    State.OptState.F = State.OptState.F + Square(State.W(i) * (State.F - State.TaskY(i)))
    V = Square(State.W(i)) * 2# * (State.F - State.TaskY(i))
    For i_ = 0# To K - 1# Step 1
        State.OptState.G(i_) = State.OptState.G(i_) + V * State.G(i_)
    Next i_
    For J = 0# To K - 1# Step 1
        V = 2# * Square(State.W(i)) * State.G(J)
        For i_ = 0# To K - 1# Step 1
            State.OptState.H(J, i_) = State.OptState.H(J, i_) + V * State.G(i_)
        Next i_
        V = 2# * Square(State.W(i)) * (State.F - State.TaskY(i))
        For i_ = 0# To K - 1# Step 1
            State.OptState.H(J, i_) = State.OptState.H(J, i_) + V * State.H(J, i_)
        Next i_
    Next J
    i = i + 1#
    GoTo lbl_24
lbl_26:
    GoTo lbl_5
lbl_22:
    GoTo lbl_5
lbl_6:
    Call MinLMResults(State.OptState, State.C, State.OptRep)
    State.RepTerminationType = State.OptRep.TerminationType
    
    '
    ' calculate errors
    '
    If State.RepTerminationType <= 0# Then
        GoTo lbl_27
    End If
    State.RepRMSError = 0#
    State.RepAvgError = 0#
    State.RepAvgRelError = 0#
    State.RepMaxError = 0#
    RelCnt = 0#
    i = 0#
lbl_29:
    If i > N - 1# Then
        GoTo lbl_31
    End If
    For i_ = 0# To K - 1# Step 1
        State.C(i_) = State.C(i_)
    Next i_
    For i_ = 0# To M - 1# Step 1
        State.x(i_) = State.TaskX(i, i_)
    Next i_
    State.PointIndex = i
    Call LSFitClearRequestFields(State)
    State.NeedF = True
    State.RState.Stage = 4#
    GoTo lbl_rcomm
lbl_4:
    V = State.F
    State.RepRMSError = State.RepRMSError + Square(V - State.TaskY(i))
    State.RepAvgError = State.RepAvgError + Abs(V - State.TaskY(i))
    If State.TaskY(i) <> 0# Then
        State.RepAvgRelError = State.RepAvgRelError + Abs(V - State.TaskY(i)) / Abs(State.TaskY(i))
        RelCnt = RelCnt + 1#
    End If
    State.RepMaxError = MaxReal(State.RepMaxError, Abs(V - State.TaskY(i)))
    i = i + 1#
    GoTo lbl_29
lbl_31:
    State.RepRMSError = Sqr(State.RepRMSError / N)
    State.RepAvgError = State.RepAvgError / N
    If RelCnt <> 0# Then
        State.RepAvgRelError = State.RepAvgRelError / RelCnt
    End If
lbl_27:
    Result = False
    LSFitNonlinearIteration = Result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    Result = True
    State.RState.IA(0#) = N
    State.RState.IA(1#) = M
    State.RState.IA(2#) = K
    State.RState.IA(3#) = i
    State.RState.IA(4#) = J
    State.RState.RA(0#) = V
    State.RState.RA(1#) = RelCnt
    LSFitNonlinearIteration = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Nonlinear least squares fitting results.
'
'Called after LSFitNonlinearIteration() returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by LSFitNonlinearIteration).
'
'OUTPUT PARAMETERS:
'    Info    -   completetion code:
'                    * -1    incorrect parameters were specified
'                    *  1    relative function improvement is no more than
'                            EpsF.
'                    *  2    relative step is no more than EpsX.
'                    *  4    gradient norm is no more than EpsG
'                    *  5    MaxIts steps was taken
'    C       -   array[0..K-1], solution
'    Rep     -   optimization report. Following fields are set:
'                * Rep.TerminationType completetion code:
'                * RMSError          rms error on the (X,Y).
'                * AvgError          average error on the (X,Y).
'                * AvgRelError       average relative error on the non-zero Y
'                * MaxError          maximum error
'                                    NON-WEIGHTED ERRORS ARE CALCULATED
'
'
'  -- ALGLIB --
'     Copyright 17.08.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub LSFitNonlinearResults(ByRef State As LSFitState, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim i_ As Long
    Info = State.RepTerminationType
    If Info > 0# Then
        ReDim C(0 To State.K - 1)
        For i_ = 0# To State.K - 1# Step 1
            C(i_) = State.C(i_)
        Next i_
        Rep.RMSError = State.RepRMSError
        Rep.AvgError = State.RepAvgError
        Rep.AvgRelError = State.RepAvgRelError
        Rep.MaxError = State.RepMaxError
    End If
End Sub
Public Sub LSFitScaleXY(ByRef x() As Double, _
         ByRef Y() As Double, _
         ByVal N As Long, _
         ByRef XC() As Double, _
         ByRef YC() As Double, _
         ByRef DC() As Long, _
         ByVal K As Long, _
         ByRef XA As Double, _
         ByRef XB As Double, _
         ByRef SA As Double, _
         ByRef SB As Double, _
         ByRef XOriginal() As Double, _
         ByRef YOriginal() As Double)
    Dim XMin As Double
    Dim XMax As Double
    Dim i As Long
    Dim i_ As Long
    
    '
    ' Calculate xmin/xmax.
    ' Force xmin<>xmax.
    '
    XMin = x(0#)
    XMax = x(0#)
    For i = 1# To N - 1# Step 1
        XMin = MinReal(XMin, x(i))
        XMax = MaxReal(XMax, x(i))
    Next i
    For i = 0# To K - 1# Step 1
        XMin = MinReal(XMin, XC(i))
        XMax = MaxReal(XMax, XC(i))
    Next i
    If XMin = XMax Then
        If XMin = 0# Then
            XMin = -1#
            XMax = 1#
        Else
            XMin = 0.5 * XMin
        End If
    End If
    
    '
    ' Transform abscissas: map [XA,XB] to [0,1]
    '
    ' Store old X[] in XOriginal[] (it will be used
    ' to calculate relative error).
    '
    ReDim XOriginal(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        XOriginal(i_) = x(i_)
    Next i_
    XA = XMin
    XB = XMax
    For i = 0# To N - 1# Step 1
        x(i) = 2# * (x(i) - 0.5 * (XA + XB)) / (XB - XA)
    Next i
    For i = 0# To K - 1# Step 1
        XC(i) = 2# * (XC(i) - 0.5 * (XA + XB)) / (XB - XA)
        YC(i) = YC(i) * Power(0.5 * (XB - XA), DC(i))
    Next i
    
    '
    ' Transform function values: map [SA,SB] to [0,1]
    ' SA = mean(Y),
    ' SB = SA+stddev(Y).
    '
    ' Store old Y[] in YOriginal[] (it will be used
    ' to calculate relative error).
    '
    ReDim YOriginal(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        YOriginal(i_) = Y(i_)
    Next i_
    SA = 0#
    For i = 0# To N - 1# Step 1
        SA = SA + Y(i)
    Next i
    SA = SA / N
    SB = 0#
    For i = 0# To N - 1# Step 1
        SB = SB + Square(Y(i) - SA)
    Next i
    SB = Sqr(SB / N) + SA
    If SB = SA Then
        SB = 2# * SA
    End If
    If SB = SA Then
        SB = SA + 1#
    End If
    For i = 0# To N - 1# Step 1
        Y(i) = (Y(i) - SA) / (SB - SA)
    Next i
    For i = 0# To K - 1# Step 1
        If DC(i) = 0# Then
            YC(i) = (YC(i) - SA) / (SB - SA)
        Else
            YC(i) = YC(i) / (SB - SA)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal fitting subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LSFitLinearInternal(ByRef Y() As Double, _
         ByRef W() As Double, _
         ByRef FMatrix() As Double, _
         ByVal N As Long, _
         ByVal M As Long, _
         ByRef Info As Long, _
         ByRef C() As Double, _
         ByRef Rep As LSFitReport)
    Dim Threshold As Double
    Dim FT() As Double
    Dim Q() As Double
    Dim L() As Double
    Dim R() As Double
    Dim B() As Double
    Dim WMod() As Double
    Dim Tau() As Double
    Dim i As Long
    Dim J As Long
    Dim V As Double
    Dim SV() As Double
    Dim U() As Double
    Dim VT() As Double
    Dim Tmp() As Double
    Dim UTB() As Double
    Dim SUTB() As Double
    Dim RelCnt As Long
    Dim i_ As Long
    If N < 1# Or M < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    Threshold = Sqr(MachineEpsilon)
    
    '
    ' Degenerate case, needs special handling
    '
    If N < M Then
        
        '
        ' Create design matrix.
        '
        ReDim FT(0 To N - 1, 0 To M - 1)
        ReDim B(0 To N - 1)
        ReDim WMod(0 To N - 1)
        For J = 0# To N - 1# Step 1
            V = W(J)
            For i_ = 0# To M - 1# Step 1
                FT(J, i_) = V * FMatrix(J, i_)
            Next i_
            B(J) = W(J) * Y(J)
            WMod(J) = 1#
        Next J
        
        '
        ' LQ decomposition and reduction to M=N
        '
        ReDim C(0 To M - 1)
        For i = 0# To M - 1# Step 1
            C(i) = 0#
        Next i
        Rep.TaskRCond = 0#
        Call RMatrixLQ(FT, N, M, Tau)
        Call RMatrixLQUnpackQ(FT, N, M, Tau, N, Q)
        Call RMatrixLQUnpackL(FT, N, M, L)
        Call LSFitLinearInternal(B, WMod, L, N, N, Info, Tmp, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        For i = 0# To N - 1# Step 1
            V = Tmp(i)
            For i_ = 0# To M - 1# Step 1
                C(i_) = C(i_) + V * Q(i, i_)
            Next i_
        Next i
        Exit Sub
    End If
    
    '
    ' N>=M. Generate design matrix and reduce to N=M using
    ' QR decomposition.
    '
    ReDim FT(0 To N - 1, 0 To M - 1)
    ReDim B(0 To N - 1)
    For J = 0# To N - 1# Step 1
        V = W(J)
        For i_ = 0# To M - 1# Step 1
            FT(J, i_) = V * FMatrix(J, i_)
        Next i_
        B(J) = W(J) * Y(J)
    Next J
    Call RMatrixQR(FT, N, M, Tau)
    Call RMatrixQRUnpackQ(FT, N, M, Tau, M, Q)
    Call RMatrixQRUnpackR(FT, N, M, R)
    ReDim Tmp(0 To M - 1)
    For i = 0# To M - 1# Step 1
        Tmp(i) = 0#
    Next i
    For i = 0# To N - 1# Step 1
        V = B(i)
        For i_ = 0# To M - 1# Step 1
            Tmp(i_) = Tmp(i_) + V * Q(i, i_)
        Next i_
    Next i
    ReDim B(0 To M - 1)
    For i_ = 0# To M - 1# Step 1
        B(i_) = Tmp(i_)
    Next i_
    
    '
    ' R contains reduced MxM design upper triangular matrix,
    ' B contains reduced Mx1 right part.
    '
    ' Determine system condition number and decide
    ' should we use triangular solver (faster) or
    ' SVD-based solver (more stable).
    '
    ' We can use LU-based RCond estimator for this task.
    '
    Rep.TaskRCond = RMatrixLURCondInf(R, M)
    If Rep.TaskRCond > Threshold Then
        
        '
        ' use QR-based solver
        '
        ReDim C(0 To M - 1)
        C(M - 1#) = B(M - 1#) / R(M - 1#, M - 1#)
        For i = M - 2# To 0# Step -1
            V = 0#
            For i_ = i + 1# To M - 1# Step 1
                V = V + R(i, i_) * C(i_)
            Next i_
            C(i) = (B(i) - V) / R(i, i)
        Next i
    Else
        
        '
        ' use SVD-based solver
        '
        If Not RMatrixSVD(R, M, M, 1#, 1#, 2#, SV, U, VT) Then
            Info = -4#
            Exit Sub
        End If
        ReDim UTB(0 To M - 1)
        ReDim SUTB(0 To M - 1)
        For i = 0# To M - 1# Step 1
            UTB(i) = 0#
        Next i
        For i = 0# To M - 1# Step 1
            V = B(i)
            For i_ = 0# To M - 1# Step 1
                UTB(i_) = UTB(i_) + V * U(i, i_)
            Next i_
        Next i
        If SV(0#) > 0# Then
            Rep.TaskRCond = SV(M - 1#) / SV(0#)
            For i = 0# To M - 1# Step 1
                If SV(i) > Threshold * SV(0#) Then
                    SUTB(i) = UTB(i) / SV(i)
                Else
                    SUTB(i) = 0#
                End If
            Next i
        Else
            Rep.TaskRCond = 0#
            For i = 0# To M - 1# Step 1
                SUTB(i) = 0#
            Next i
        End If
        ReDim C(0 To M - 1)
        For i = 0# To M - 1# Step 1
            C(i) = 0#
        Next i
        For i = 0# To M - 1# Step 1
            V = SUTB(i)
            For i_ = 0# To M - 1# Step 1
                C(i_) = C(i_) + V * VT(i, i_)
            Next i_
        Next i
    End If
    
    '
    ' calculate errors
    '
    Rep.RMSError = 0#
    Rep.AvgError = 0#
    Rep.AvgRelError = 0#
    Rep.MaxError = 0#
    RelCnt = 0#
    For i = 0# To N - 1# Step 1
        V = 0#
        For i_ = 0# To M - 1# Step 1
            V = V + FMatrix(i, i_) * C(i_)
        Next i_
        Rep.RMSError = Rep.RMSError + Square(V - Y(i))
        Rep.AvgError = Rep.AvgError + Abs(V - Y(i))
        If Y(i) <> 0# Then
            Rep.AvgRelError = Rep.AvgRelError + Abs(V - Y(i)) / Abs(Y(i))
            RelCnt = RelCnt + 1#
        End If
        Rep.MaxError = MaxReal(Rep.MaxError, Abs(V - Y(i)))
    Next i
    Rep.RMSError = Sqr(Rep.RMSError / N)
    Rep.AvgError = Rep.AvgError / N
    If RelCnt <> 0# Then
        Rep.AvgRelError = Rep.AvgRelError / RelCnt
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub LSFitClearRequestFields(ByRef State As LSFitState)
    State.NeedF = False
    State.NeedFG = False
    State.NeedFGH = False
End Sub
