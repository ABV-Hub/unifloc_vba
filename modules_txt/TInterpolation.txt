' класс для хранения и работы с графиками функций y=f(x) заданных в табличном виде
'
'
'
' Ver 1.2
' rnt
' обновление для более полного манипулирования графиками
'
'
Option Explicit
Private Type TDPoint    ' тип для хранения точек
    X As Double
    Y As Variant
    stable As Boolean    ' специальный признак точки - показывает должна ли она сохраняться при преобразовании
End Type
' Поиск решения x при известном y
Public Enum TINTERPOLATION_SOLUTION
    TS_EXTRPOLATION = 0                 ' осуществлять экстраполирование решение
    TS_NO_EXTRPOLATION = 1              ' без экстрополяции
End Enum
Private FPoints() As TDPoint            ' исходный массив точек
Private FSolutionPoints() As TDPoint    ' массив точек решений (поиск x при известном y)
Private FStablePoints() As Double       ' массив особых (стабильных) точек, которые сохраняются при трансформации кривой
Private FkPoint As Integer              ' количество точек в массиве
Private FkSolPoints As Integer          ' количество точек решений
Private FkStablePoints As Integer       ' количество стабильных точек
Private FMinY As Double                 ' минимальное значение функции
Private FMaxY As Double                 ' максимальное значение функции
Public Z As Double                      ' неизвестная переменная - не используется ?
' флаг определяющий является ли функция линейно интерпорлированной или ступенчатой
Public isStepFunction As Boolean
' доп параметры для описания графиков
Public Title As String
Public xName As String
Public yName As String
Public note As String
Private Sub Class_Initialize()
    Call ClearPoints
    isStepFunction = False  ' по умолчанию - линейно интерполированная
End Sub
Public Property Get NumStablePoints() As Integer
    NumStablePoints = FkStablePoints
End Property
' свойство возвращает значение стабильной точки по ее номеру, если такая точка есть
Public Property Get StablePoint(I As Integer) As Double
    If I > 0 And I <= FkStablePoints Then
        StablePoint = FStablePoints(I - 1)
    Else
        Err.Raise kErrCurveStablePointIndex, , "Неверный индекс при считывании стабильных точек кривой TInterpolation"
    End If
End Property
Public Property Get numPoints() As Integer
    numPoints = FkPoint
End Property
Public Property Get pointStable(I As Integer) As Double
    If I > 0 And I <= FkPoint Then
        pointStable = FPoints(I - 1).stable
    Else
        Err.Raise kErrCurvePointIndex, , "Неверный индекс при считывании точек Х кривой TInterpolation"
    End If
End Property
Public Property Get pointX(I As Integer) As Double
    If I > 0 And I <= FkPoint Then
        pointX = FPoints(I - 1).X
    Else
        Err.Raise kErrCurvePointIndex, , "Неверный индекс при считывании точек Х кривой TInterpolation"
    End If
End Property
Public Property Get PointY(I As Integer) As Double
    If I > 0 And I <= FkPoint Then
        PointY = FPoints(I - 1).Y
    Else
        Err.Raise kErrCurvePointIndex, , "Неверный индекс при считывании точек Y кривой TInterpolation"
    End If
End Property
Public Property Get SolutionPointX(I As Integer) As Double
    If I > 0 And I <= FkSolPoints Then
        SolutionPointX = FSolutionPoints(I - 1).X
    Else
        Err.Raise kErrCurvePointIndex, , "Неверный индекс при считывании точек X решений кривой TInterpolation"
    End If
End Property
Public Property Get SolutionPointY(I As Integer) As Double
    If I > 0 And I <= FkSolPoints Then
        SolutionPointY = FSolutionPoints(I - 1).Y
    Else
        Err.Raise kErrCurvePointIndex, , "Неверный индекс при считывании точек Y решений кривой TInterpolation"
    End If
End Property
Public Property Get MinY() As Double
    MinY = FMinY
End Property
Public Function minx() As Double
    If FkPoint = 0 Then minx = 0 Else minx = FPoints(0).X
End Function
Public Function maxx() As Double
    If FkPoint = 0 Then maxx = 0 Else maxx = FPoints(FkPoint - 1).X
End Function
Private Function FindMinMaxY()
'находит минимальное и максимальное значение функции
Dim I As Integer
If FkPoint > 1 Then
    FMinY = FPoints(LBound(FPoints)).Y
    FMaxY = FPoints(LBound(FPoints)).Y
    For I = LBound(FPoints) To UBound(FPoints)
        If FPoints(I).Y > FMaxY Then FMaxY = FPoints(I).Y
        If FPoints(I).Y < FMinY Then FMinY = FPoints(I).Y
    Next I
End If
End Function
Private Function getFirstPointNo(ByVal X As Double) As Integer
 Dim I As Integer
 Dim F As Boolean
 
    I = 0
    F = True
    While F
        F = False
        If I < FkPoint - 1 Then
            If X > FPoints(I).X Then
                I = I + 1
                F = True
            End If
        End If
    Wend
    If I = 0 Then I = 1
    getFirstPointNo = I - 1
End Function
Public Function FindSolutions(Yvalue As Double, Optional ByVal with_extrapolation As TINTERPOLATION_SOLUTION = TS_EXTRPOLATION) As Integer
' FindSolutions Функция поиска решений X по известному Y. По умолчанию расчет ведется с линейной экстраполяцией на краях
' @param Yvalue - значение Y
' @param with_extrapolation - производить ли экстраполяцию при расчете
' @return Количество найденных точек
  Dim X1, X2, y1, Y2 As Double
  Dim X As Double
  Dim N As Integer
  Dim I As Integer
  
  FkSolPoints = 0  ' assume no soutions
  If UBound(FPoints) = LBound(FPoints) Then  ' если только одна точка то ничего нельзя сделать
        FindSolutions = 0
        Exit Function
  End If
  
  ReDim Preserve FSolutionPoints(FkSolPoints) ' удаляем хранилище точек пересечений
  For I = LBound(FPoints) To UBound(FPoints) - 1
        If (FPoints(I).Y <= Yvalue) And (FPoints(I + 1).Y >= Yvalue) Or (FPoints(I).Y >= Yvalue) And (FPoints(I + 1).Y <= Yvalue) Then    ' must be solution here
            If (FPoints(I).Y = Yvalue) And (FPoints(I + 1).Y = Yvalue) Then   ' infinite solutions of line segment
                If FkSolPoints = 0 Then
                    AddPointToSolPoints FPoints(I).X, FPoints(I).Y
                ElseIf FSolutionPoints(FkSolPoints - 1).X <> FPoints(I).X Then ' особенности VBA, чтобы при FkSolPoints = 0 не падало
                    ' особенности VBA,
                    AddPointToSolPoints FPoints(I).X, FPoints(I).Y
                End If
                
            Else ' one solution
                 X1 = FPoints(I).X
                 X2 = FPoints(I + 1).X
                 y1 = FPoints(I).Y
                 Y2 = FPoints(I + 1).Y
                 X = (X2 - X1) / (Y2 - y1) * (Yvalue - y1) + X1
                 AddPointToSolPoints X, Yvalue
            End If
        End If
  Next I
  
  If FkSolPoints = 0 And with_extrapolation = TS_EXTRPOLATION Then
        ' проверяем существование y на левом крае
        I = 0
        y1 = FPoints(I).Y
        Y2 = FPoints(I + 1).Y
        If ((Yvalue - y1) * (y1 - Y2) > 0) Then
             X1 = FPoints(I).X
             X2 = FPoints(I + 1).X
             X = (X2 - X1) / (Y2 - y1) * (Yvalue - y1) + X1
             AddPointToSolPoints X, Yvalue
        End If
        ' проверяем существование y на правом крае
        I = UBound(FPoints)
        y1 = FPoints(I).Y
        Y2 = FPoints(I - 1).Y
        If ((Yvalue - y1) * (y1 - Y2) > 0) Then
             X1 = FPoints(I).X
             X2 = FPoints(I - 1).X
             X = (X2 - X1) / (Y2 - y1) * (Yvalue - y1) + X1
             AddPointToSolPoints X, Yvalue
        End If
  End If
  FindSolutions = FkSolPoints
End Function
Public Function FindMinOneSolution(Yvalue As Double, Optional ByVal with_extrapolation As TINTERPOLATION_SOLUTION = TS_EXTRPOLATION) As Double
' FindSolutions Функция поиска решений X по известному Y. По умолчанию расчет ведется с линейной экстраполяцией на краях
' @param Yvalue - значение Y
' @param with_extrapolation - производить ли экстраполяцию при расчете
' @return Возвращает искомое решение, если решение одно,возвращает минимальное значения для решения, если значений несколько,
' Вызывает исключение, если решений нет
    Dim points_solve_size As Integer
    
    points_solve_size = FindSolutions(Yvalue, with_extrapolation)
    If (points_solve_size = 1) Then
        FindMinOneSolution = Me.SolutionPointX(1)
    ElseIf (points_solve_size > 1) Then
        FindMinOneSolution = Me.SolutionPointX(1) ' тут надо проверить - что возвращается, сделать возвращение минимального
    Else
        FindMinOneSolution = 0
        'Err.Raise kErrArraySize, , "FindMinOneSolution завершился неудачно, решений нет"
    End If
End Function
Public Function FindMaxOneSolution(Yvalue As Double, Optional ByVal with_extrapolation As TINTERPOLATION_SOLUTION = TS_EXTRPOLATION) As Double
' FindSolutions Функция поиска решений X по известному Y. По умолчанию расчет ведется с линейной экстраполяцией на краях
' @param Yvalue - значение Y
' @param with_extrapolation - производить ли экстраполяцию при расчете
' @return Возвращает искомое решение, если решение одно,возвращает максимальное значения для решения, если значений несколько,
' Вызывает исключение, если решений нет
    Dim points_solve_size As Integer
    
    points_solve_size = FindSolutions(Yvalue, with_extrapolation)
    If (points_solve_size = 1) Then
        FindMaxOneSolution = Me.SolutionPointX(1)
    ElseIf (points_solve_size > 1) Then
        FindMaxOneSolution = Me.SolutionPointX(points_solve_size) ' возвращаем послежнюю точку
    Else
        Err.Raise kErrArraySize, , "FindMaxOneSolution завершился неудачно, решений нет"
    End If
End Function
Private Sub AddPointToSolPoints(ByVal X As Double, ByVal Y As Double)
      ReDim Preserve FSolutionPoints(FkSolPoints)
      FSolutionPoints(FkSolPoints).X = X
      FSolutionPoints(FkSolPoints).Y = Y
      FkSolPoints = FkSolPoints + 1
End Sub
Public Function getPoint(ByVal X As Double) As Double
     Dim N As Integer
     Dim X1, X2, y1, Y2 As Double
    ' интерполирует или экстраполирует значения по кривой - линейно
     getPoint = 0
     If FkPoint < 2 And Not isStepFunction Then
         addLogMsg "TInterpolation.getPoint   error - trying to find intersection with one point line"
         Exit Function
     End If
     ' если ступенчатая функция - то достаточно только одной точки чтобы получить значение где угодно
     If FkPoint < 1 Then
         addLogMsg "TInterpolation.getPoint   error - trying to find intersection with line without points"
         Exit Function
     End If
     
     N = getFirstPointNo(X)
     X1 = FPoints(N).X
     y1 = FPoints(N).Y
     
     If FkPoint > 1 Then
        X2 = FPoints(N + 1).X
        Y2 = FPoints(N + 1).Y
     Else
        X2 = X1
        Y2 = y1
     End If
     
     ' делаем проверку - если функция ступенчатая то выдаем не интерполированное значение, а значение в предущей точке
     If isStepFunction Then
        If X >= X2 Then
            getPoint = Y2
        Else
            getPoint = y1
        End If
     Else
         getPoint = (Y2 - y1) / (X2 - X1) * (X - X1) + y1
 End If
End Function
Public Function TestPoint(ByVal X As Double) As Integer
    ' проверяет если точка с заданным аргументом
    '
     Dim I, N As Integer
     
     N = -1
     TestPoint = False
     For I = 0 To FkPoint - 1
        If FPoints(I).X = X Then
            N = I
            Exit For
        End If
     Next I
     TestPoint = N
End Function
Public Sub ClearPoints()
    ReDim FPoints(0)
    ReDim FSolutionPoints(0)
    ReDim FStablePoints(0)
    FkPoint = 0
    FkSolPoints = 0
    FkStablePoints = 0
End Sub
Public Sub AddPointsCurve(ParamArray crv())
' добавляет в кривую все точки из другой кривой
    Dim I As Integer, J As Integer
    Dim crv_local As TInterpolation
   ' If crv <> Nothing Then
        For J = LBound(crv) To UBound(crv)
            Set crv_local = crv(J)
            For I = 1 To crv_local.numPoints
                Me.AddPoint crv_local.pointX(I), crv_local.PointY(I), crv_local.pointStable(I)
            Next I
        Next J
   ' End If
End Sub
Public Sub AddPoint(ByVal X As Double, ByVal Y As Double, Optional isStable As Boolean = False)
    ' добавление точки с сортировкой и обеспечением возрастания аргументов
     Dim I, N As Integer
     Dim CheckMinMaxY As Boolean
     Dim tp As TDPoint
     Dim F As Boolean
     
     N = TestPoint(X)
     If N >= 0 Then ' если аргумент уже есть в массиве
        FPoints(N).X = X
        If (FPoints(N).Y = FMinY) Or (FPoints(N).Y = FMinY) Then
              CheckMinMaxY = True
        Else
              CheckMinMaxY = False
              If Y > FMaxY Then FMaxY = Y
              If Y < FMinY Then FMinY = Y
        End If
        FPoints(N).Y = Y
        FPoints(N).stable = isStable
        If CheckMinMaxY Then Call FindMinMaxY
        Exit Sub
     End If
     
     ReDim Preserve FPoints(FkPoint)
     
     FPoints(FkPoint).X = X
     FPoints(FkPoint).Y = Y
     FPoints(FkPoint).stable = isStable
     
     ' дальше сортируем точки, чтобы получилось все хорошо
     If (Y > FMaxY) Or (FkPoint = LBound(FPoints)) Then FMaxY = Y
     If (Y < FMinY) Or (FkPoint = LBound(FPoints)) Then FMinY = Y
     FkPoint = FkPoint + 1
     If FkPoint > 1 Then
        I = FkPoint - 1
        F = True
        While F
            F = False
            If I > 0 Then
                If FPoints(I - 1).X > FPoints(I).X Then
                    tp = FPoints(I)
                    FPoints(I) = FPoints(I - 1)
                    FPoints(I - 1) = tp
                    I = I - 1
                    F = True
                End If
            End If
        Wend
     End If
     ' в конце перечитаем массив специальных стабильных точек
     Call UpdateStablePointsList
End Sub
' функция которая по признакам точек обновляет массив стабильных точек
Private Sub UpdateStablePointsList()
    Dim I As Integer
    ReDim FStablePoints(0)
    FkStablePoints = 0
    
    ' заполняем массив - первая и последние точки там всегда есть по умолчанию
    For I = 0 To FkPoint - 1
        If FPoints(I).stable Or (I = 0) Or I = (FkPoint - 1) Then
            ReDim Preserve FStablePoints(FkStablePoints)
            FStablePoints(FkStablePoints) = FPoints(I).X
            FkStablePoints = FkStablePoints + 1
        End If
    Next I
End Sub
Public Sub PrintPoints()
    Dim I As Integer
    For I = 0 To FkPoint - 1
        'Debug.Print "i" = i; "x = "; FPoints(i).x; " "; "y = "; FPoints(i).y
        Debug.Print FPoints(I).X & " " & FPoints(I).Y
    Next I
End Sub
Public Sub PrintValXY(ByVal X As Double)
    Dim Y As Double
    
    Y = getPoint(X)
    Debug.Print "F(" + CStr(X) + ") = " + CStr(Y)
End Sub
Public Sub PrintInterval(ByVal X As Double)
    Dim S  As String
    Dim N As Integer
    
    N = getFirstPointNo(X)
    S = CStr(FPoints(N).X) + " (" + CStr(X) + ") " + CStr(FPoints(N + 1).X)
    Debug.Print S
End Sub
' метод который позволяет получить кривую с заданным количеством точек
Public Function ClonePointsToNum(numPoints) As TInterpolation
    Dim outCurve As New TInterpolation  ' определили новую кривую
    Dim I As Integer
    Dim xPoint As Double, DX As Double
    Dim NumToAdd As Integer
    Dim N As Integer
    Dim AddedStablePoints As Integer
    AddedStablePoints = 0
    Const EPS = 0.01
    
    outCurve.xName = xName
    outCurve.yName = yName
    
    If Me.numPoints <= 1 Then
        addLogMsg ("TInterpolation.ClonePointsToNum: error - trying to populate one point curve. curve name: " & note)
        outCurve.AddPoint 0, 0
        Exit Function
    End If
    ' добавим все стабильные точки в результирующую кривую
    For I = 1 To FkStablePoints
        xPoint = FStablePoints(I - 1)
        outCurve.AddPoint xPoint, getPoint(xPoint)
        If isStepFunction And xPoint > 0 Then outCurve.AddPoint xPoint - EPS, getPoint(xPoint - EPS)
    Next I
    
    AddedStablePoints = outCurve.numPoints
    ' найдем точки равномерного распределения
    NumToAdd = numPoints - AddedStablePoints   ' количество точек, которые надо добавить  концы отрезков уже добавлены
    If NumToAdd <= 0 Then
        Set ClonePointsToNum = outCurve
        Exit Function
    End If
    DX = (maxx - minx) / (NumToAdd + 1)      ' приращение - ориетировочное расстояние между точками которые добавляем
    ' добавим недостающие точки
    For I = 1 To NumToAdd
        xPoint = minx + DX * I
        outCurve.AddPoint xPoint, getPoint(xPoint)   ' добавляем точку в выходной массив
    Next I
    ' может так получится, что стабильные точки совпадают
    While outCurve.numPoints < numPoints And outCurve.numPoints > 1
        Call outCurve.DivMaxL
    Wend
    Set ClonePointsToNum = outCurve
End Function
' функция разделяет максимальный отрезок пополам
Public Function DivMaxL()
    Dim xNew, yNew As Double
    Dim maxL As Double
    Dim I As Integer, MaxI As Integer
    
    MaxI = 0
    maxL = 0
    For I = LBound(FPoints) + 1 To UBound(FPoints)
        If maxL < (FPoints(I).X - FPoints(I - 1).X) Then
            maxL = (FPoints(I).X - FPoints(I - 1).X)
            MaxI = I
        End If
    Next I
        
    If MaxI > 0 Then
        xNew = FPoints(MaxI - 1).X + (FPoints(MaxI).X - FPoints(MaxI - 1).X) / 2
        yNew = getPoint(xNew)
        AddPoint xNew, yNew
    End If
End Function
Public Function ConvertPointsToNum(numPoints) As Boolean
' функция преобразует кривую к кривой такой же с заданным количеством точек (пока линейная интерполяция)
    Dim I As Integer, J As Integer
    Dim maxL As Double
    Dim MaxI As Integer
    Dim xNew As Double, yNew As Double
    maxL = 0
    MaxI = 0
    
    If FkPoint < numPoints Then  ' тут надо добавлять точки
        Do
            maxL = 0
            For I = LBound(FPoints) + 1 To UBound(FPoints)
                If maxL < (FPoints(I).X - FPoints(I - 1).X) Then
                    maxL = (FPoints(I).X - FPoints(I - 1).X)
                    MaxI = I
                End If
            Next I
                
            xNew = FPoints(MaxI - 1).X + (FPoints(MaxI).X - FPoints(MaxI - 1).X) / 2
            yNew = getPoint(xNew)
            AddPoint xNew, yNew
            
        Loop Until FkPoint = numPoints
        ConvertPointsToNum = True
    Else                        ' тут надо удалять точки
        ConvertPointsToNum = False
    End If
End Function
Public Function Transform(Optional multY As Double = 1, Optional sumY As Double = 0, _
                          Optional multX As Double = 1, Optional sumX As Double = 0) As TInterpolation
' преобразует кривую с использованием линейного преобразования на плоскости
 Dim I As Integer
 For I = 0 To FkPoint - 1
    FPoints(I).Y = FPoints(I).Y * multY + sumY
    FPoints(I).X = FPoints(I).X * multX + sumX
 Next I
 
 Set Transform = Me
End Function
Public Sub loadFromVertRange(RangX As Range, RangY As Range)
' функция для чтения range в кривую значений. range читаются по вертикали - значения должны быть в строках - столбец должен быть только один
' должна использоваться для чтения исходных данных с листа
'
    Dim I As Integer
    Dim NumVal As Integer
    Dim X As Double, Y As Double
    
    Call ClearPoints
    NumVal = MinReal(RangX.Rows.Count, RangY.Rows.Count)
    If NumVal < 0 Then Err.Raise 1, , "Не удалось прочитать кривую"
    ' читаем поэлементно, чтобы отсеять пустые ячейки по пути
    On Error Resume Next
    For I = 1 To NumVal
        X = RangX.Value2(I, 1)
        Y = RangY.Value2(I, 1)
        If (I = 1) Or (X > 0) Then
            If isStepFunction Then
                Me.AddPoint X, Y, isStable:=True
            Else
                Me.AddPoint X, Y, isStable:=False
            End If
        End If
    Next I
End Sub
Public Function CutByValue(Val) As TInterpolation
            Dim I As Integer
            Dim pcur As New TInterpolation
            For I = 1 To numPoints
                If pointX(I) > Val Then
                    pcur.AddPoint pointX(I), PointY(I)
                End If
            Next I
            pcur.AddPoint Val, getPoint(Val)
            pcur.AddPoint 0, getPoint(Val)
            Set CutByValue = pcur
End Function
Public Function CutByCurve(crv As TInterpolation) As TInterpolation
' обрезание кривой с использованием другой кривой
    Dim I As Integer
    Dim J1, J2 As Integer
    J1 = 0
    J2 = 0
    Dim pcur As New TInterpolation
    Dim crv_min As TInterpolation
    Dim crv_val As Double
    Dim Val As Double
    For I = 1 To numPoints
        crv_val = crv.getPoint(pointX(I))
        If PointY(I) > crv_val Then
            pcur.AddPoint pointX(I), PointY(I)
            J1 = J1 + 1
        Else
            pcur.AddPoint pointX(I), crv_val
            J2 = J2 + 1
        End If
    Next I
    If J1 > 0 And J2 > 0 Then
        ' for sure there is an intersection - need to find and add it
        Set crv_min = SubtractCurve(Me, crv)
        I = crv_min.FindSolutions(0)
        If I = 1 Then
            Val = crv_min.SolutionPointX(1)
        Else
        End If
        ' adding Hdyn point as stable - to make sure to have pretty charts later
        pcur.AddPoint Val, getPoint(Val), isStable:=True
    End If
    Set CutByCurve = pcur
End Function
Public Sub WriteToRange(RangX As Range, RangY As Range, Optional ByVal NumPt As Integer = 0)
    If NumPt > 0 And numPoints > 1 Then
        Me.ClonePointsToNum(NumPt).WriteToRange RangX, RangY
    Else
        WriteToVertRange RangX, RangY
    End If
End Sub
Private Sub WriteToVertRange(RangX As Range, RangY As Range)
' позволим кривой записывать себя за заранее данный диапазон ячеек (тут хорошо бы сообразить уместится ли запись или нет - может надо кривую масштабировать?)
' функция записи кривой на лист excel
 On Error GoTo er1
    Dim ValX As Double, ValY As Double
    Dim NumStr As Integer
    Dim I As Integer
    
    RangX.Clear
    RangY.Clear
    NumStr = MinReal(numPoints, RangX.Rows.Count)   ' определяем количество элементов в списке. Оно равно числу значений по оси X
    RangX.Cells(0, 1) = xName   ' XDescription
    RangY.Cells(0, 1) = yName  'YDescription
    For I = 1 To NumStr
        ValX = pointX(I)
        ValY = PointY(I)
        RangX.Cells(I, 1) = ValX
        RangY.Cells(I, 1) = ValY
    Next I
    
    Exit Sub
er1:
    Err.Raise kErrWriteDataFromWorksheet, "TInterpolation.WriteToVertRange", "Ошибка, при записи кривой. Точек " & NumStr & " в диапазон ."
End Sub
