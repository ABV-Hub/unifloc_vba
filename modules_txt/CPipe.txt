'=======================================================================================
'Unifloc 7.7  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' класс для расчета многофазного потока в трубе (вторая версия после рефакторинга Алма)
'
' История
'
' 2016.04    Реализован новый механизм расчета распределения давления в стволе с использованием модуля решения ОДУ
'               упрощена структура хранения массивов
' 2017.01    Модернизация под 7 версию. Исправление ошибок и контроль температуры
'
' 2019.04    Рефакторинг в сторону упрощения
Option Explicit
Option Base 0
 Public ZeroCoordMes_m As Double                        ' начальная координата трубы, измеренная, от которой будут отсчитываться координаты в выходных массивах
 Public ZeroCoordVert_m As Double                       ' начальная координата трубы, вертикальная, от которой будут отсчитываться координаты в выходных массивах
 Public Fluid As CPVT                                   ' базовый флюид в трубе. Определяет свойства и расходы и фазовый состав
 Public AmbientForm As New CAmbientFormation            ' порода за пределями скважины
 Public Curves As New CCurves                           ' все кривые планируется прятать тут
        '  Curves("c_Hvert")                   ' кривая зависимость вертикальной глубины от измеренной (траектория скважины)
        '  Curves("c_Theta")                   ' зенитный угол в зависимости от измеренной глубины
        '  Curves("c_Roughness")               ' шероховатость от измеренной глубины
        '  Curves("c_Diam")                    ' диаметр трубы от измеренной глубины
        '  Curves("c_Tinit")                   ' распределение температуры по которой инициализировалась труба
 Public CurvesOut As New CCurves
        ' набор кривых с базовыми свойствами
        '  CurvesOut("c_P")                       ' кривая с давлениями
        '  CurvesOut("c_T")
        '  CurvesOut("c_Tamb")
        '  CurvesOut("c_dpdl_g")
        '  CurvesOut("c_dpdl_f")
        '  CurvesOut("c_dpdl_a")
        '  CurvesOut("c_vsl")
        '  CurvesOut("c_vsg")
        '  CurvesOut("c_Hl")
        '  CurvesOut("c_fpat")
        ' ' дополнительные выводные параметры по трубам
        '  CurvesOut("c_Rs")
        '  CurvesOut("c_gasfrac")
        '  CurvesOut("c_muo")
        '  CurvesOut("c_muw")
        '  CurvesOut("c_mug")
        '  CurvesOut("c_mumix")
        '  CurvesOut("c_rhoo")
        '  CurvesOut("c_rhow")
        '  CurvesOut("c_rhol")
        '  CurvesOut("c_rhog")
        '  CurvesOut("c_rhomix")
        '  CurvesOut("c_qo")
        '  CurvesOut("c_qw")
        '  CurvesOut("c_qg")
        '  CurvesOut("c_mo")
        '  CurvesOut("c_mw")
        '  CurvesOut("c_mg")
        '  CurvesOut("c_vl")
        '  CurvesOut("c_vg")
' геометрия трубы заданная массивами
 Private p_Hmes_insert_m As TInterpolation              ' измеренная глубина которую надо вставить в расчет трубы
 Private p_Param As PARAMCALC                           ' параметры расчета по трубе
                                                        ' чтобы отловить изменение градиента температуры, например при динамическом уровне
 Private p_total_legth_m As Double                      ' общая длинна трубы
 Private p_total_depthVert_m As Double                  ' общая глубина трубы
' расчетные параметры по трубе  (используются для вывода после проведения расчета)
 Private p_FlowParams_out() As PIPE_FLOW_PARAMS         ' расчетные параметры по трубе после расчета
 
 Private p_dTdLinit As Double                           ' распределение градиента температуры по длине начальное
' набор расчетных параметров по стволу скважины
 Private p_NumPointsCurve As Integer                    ' количество точек которые должны быть сохранены для распределения давления в трубе в итоговых кривых
 Private p_StepHmCurve As Double                        ' шаг для формирования выходного массива по трубе. м
 Private p_HmCurve As New TInterpolation                ' кривая для хранения набора точек, для которых должны строится все другие кривые
 
 ' поправочные коэффициенты для расчета распределения давления
 Private p_betta_grav As Double
 Private p_betta_fric As Double
 
 Public GLVin As CGLvalve  ' link to gas lift valve in pipe
 
  ' конструктор класса
  ' вызывается при создании класса - гарантирует что все объекты будут созданы
 Private Sub Class_Initialize()
    Set GLVin = Nothing
  '  p_Calculated = False
    ZeroCoordMes_m = 0
    ZeroCoordVert_m = 0
    p_total_legth_m = 100
    ReDim p_FlowParams_out(0) As PIPE_FLOW_PARAMS
    ' шероховатость и диаметр трубы меняют ступенчато и не интерполируются
    Curves("c_Roughness").isStepFunction = True
    Curves("c_Diam").isStepFunction = True
    CurvesOut("c_fpat").isStepFunction = True
    Set Fluid = New CPVT
    With Param
        .correlation = AnsariCor
        .FlowDirection = FlowAgainstCoord
        .tempMethod = StartEndTemp
    End With
    p_HmCurve.ClearPoints
    Set p_Hmes_insert_m = New TInterpolation
    p_Hmes_insert_m.ClearPoints
    Call p_Hmes_insert_m.AddPoint(0, 0)
    Call p_Hmes_insert_m.AddPoint(LengthMes_m, 0)
    StepHmCurve = 1000    ' по умолчанию шаг 100 м для сохранения кривых
    p_betta_grav = 1
    p_betta_fric = 1
 End Sub
 
 Public Property Get Param() As PARAMCALC
    Param = p_Param
 End Property
 Public Property Let Param(val As PARAMCALC)
    p_Param = val
 End Property
 Public Property Get betta_grav() As Double
    betta_grav = p_betta_grav
 End Property
 
 Public Property Let betta_grav(val As Double)
    If val >= 0 And val < 2 Then
    ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
        p_betta_grav = val
    End If
 End Property
 
 Public Property Let betta_fric(val As Double)
    If val >= 0 And val < 2 Then
    ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
        p_betta_fric = val
    End If
 End Property
 
 Public Property Get betta_fric() As Double
    betta_fric = p_betta_fric
 End Property
  
 Public Property Get Hmes_insert_m(ByVal i As Integer) As Double
   Hmes_insert_m = p_Hmes_insert_m.pointX(i)
 End Property
 
 Public Function AddHmes_insert_m(ByVal val As Double) As Boolean
    Call p_Hmes_insert_m.AddPoint(val, 0)   ' Запишем точку, которую надо сохранить
 End Function
 
 Public Property Get StepHmCurve() As Double
    StepHmCurve = p_StepHmCurve
 End Property
 
 Public Property Let StepHmCurve(val As Double)
    Dim i As Integer
    Dim Hm As Double
    Dim Hm_max As Double
    
    p_StepHmCurve = val
    ' установили шаг - сразу подготовим массив точек по давлению для которых должен быть проведен расчет
    p_HmCurve.ClearPoints    ' очистили точки по давлению
    For i = 1 To p_Hmes_insert_m.numPoints    ' пустили цикл по количеству точек, которые должны быть обязательно
        Hm = p_Hmes_insert_m.pointX(i)
        p_HmCurve.AddPoint Hm, 0                ' добвляем точку в выходной массив. Важен только x, поэтому y задаем произвольно
                                               ' здесь же должны задаться первая и последняя точки
    Next i
    ' далее добавим все промежуточные точки с заданым шагом
    i = 0
    Hm = p_HmCurve.pointX(1)   ' начинаем с первой точки
    Hm_max = p_HmCurve.pointX(p_HmCurve.numPoints)
    Do
        Hm = Hm + StepHmCurve
        If Hm < Hm_max Then                     ' если новая точка попадает в диапазон, добавляем ее.
            p_HmCurve.AddPoint Hm, 0             ' здесь предполагается, что координаты будут возрастать
        End If                                  ' если такая точка есть, то она просто перезапишется
    Loop While Hm < Hm_max
    ' здесь получили в кривой p_HmCurve все точки для которых надо искать параметры
 End Property
  
' свойста класса служебные
'Property Get ZeroCoordMes_m() As Double
'    ZeroCoordMes_m = ZeroCoordMes_m
'End Property
'
'Property Let ZeroCoordMes_m(val As Double)
'    ZeroCoordMes_m = val
'End Property
'
'Property Get ZeroCoordVert_m() As Double
'    ZeroCoordVert_m = ZeroCoordVert_m
'End Property
'
'Property Let ZeroCoordVert_m(val As Double)
'    ZeroCoordVert_m = val
'End Property
'' флаг целостности данных. показвает взаимную согласованность данных класса. только для чтения
' Public Property Get calculated() As Boolean
'   calculated = p_Calculated
' End Property
 
 
' длина сегмента трубы
Public Property Get LengthMes_m() As Double
    LengthMes_m = p_total_legth_m
End Property
Public Property Get DepthVert_m() As Double
    DepthVert_m = p_total_depthVert_m
End Property
Property Let correlation(cor As H_CORRELATION)
    Param.correlation = cor
End Property
Property Get correlation() As H_CORRELATION
    correlation = Param.correlation
End Property
Property Let tempMethod(cor As TEMP_CALC_METHOD)
    Param.tempMethod = cor
End Property
Property Get tempMethod() As TEMP_CALC_METHOD
    tempMethod = Param.tempMethod
End Property
    
 Public Sub InitTlinear(ByVal Tstart_C As Double, ByVal Tend_C As Double)
 ' начальная инициализация распределения температуры в трубе
        p_dTdLinit = (Tend_C - Tstart_C) / p_total_legth_m
        Curves("c_Tinit").ClearPoints
        Curves("c_Tinit").AddPoint ZeroCoordMes_m, Tstart_C
        Curves("c_Tinit").AddPoint ZeroCoordMes_m + LengthMes_m, Tend_C
 End Sub
 
 Private Function Tlinear_C(lmes_m As Double) As Double
    ' возвращает температуру исходя из линейного приближения
    Tlinear_C = Curves("c_Tinit").GetPoint(lmes_m)
 End Function
 
 Private Function Tamb_C(lmes_m As Double) As Double
    ' возвращает температуру исходя из окружения скважины
    Dim Hv_m As Double
    Hv_m = HvertZ(lmes_m)              ' определяем вертикальную глубину для заданной измеренной глубины
    Tamb_C = AmbientForm.AmbTemp_С(Hv_m)
 End Function
 
 Public Function Tinit_C(lmes_m As Double) As Double
        Select Case Param.tempMethod
            Case StartEndTemp
                Tinit_C = Tlinear_C(lmes_m) ' температуру берем извне
            Case GeoGradTemp
                Tinit_C = Tamb_C(lmes_m)
            Case AmbientTemp
                Tinit_C = Tamb_C(lmes_m)
        End Select
 End Function
 
 Private Function dTdLlinear_Cm(lmes_m As Double) As Double
    ' возвращает градиент температуры исходя из линейного приближения
    dTdLlinear_Cm = p_dTdLinit
 End Function
 
 Private Function dTdLamb_Cm(lmes_m As Double) As Double
    ' возвращает градиент температуры исходя из окружения
    Dim theta_deg As Double
    Dim Hv_m As Double
    theta_deg = AngleThetaZ(lmes_m)    ' определяем наклон на заданной глубине
    Hv_m = HvertZ(lmes_m)              ' определяем вертикальную глубину для заданной измеренной глубины
    dTdLamb_Cm = AmbientForm.AmbTempGrad_Cm(Hv_m) * sind(theta_deg)
 End Function
    
' Public Property Get dTdLinit() As Double
'    dTdLinit = p_dTdLinit
' End Property
'
' Public Property Let dTdLinit(val As Double)
'    p_dTdLinit = val
' End Property
 
' Public Function TinitZ(ByVal z As Double) As Double
'    TinitZ = Curves("c_Tinit").GetPoint(z)
' End Function
    
 Public Function DiamZ(ByVal z As Double) As Double
' функция возвращает внутренний диаметр трубы по заданной абсолютной измеренной глубине (если труба проходит по этой глубине)
    DiamZ = Curves("c_Diam").GetPoint(z)
 End Function
 
 Public Function RoughnessZ(ByVal z As Double) As Double
 ' возвращает шероховатость по измеренной глубине
    RoughnessZ = Curves("c_Roughness").GetPoint(z)
 End Function
 Public Function AngleThetaZ(ByVal z As Double) As Double
' возвращает угол по измеренной глубине
    AngleThetaZ = Curves("c_Theta").GetPoint(z)
 End Function
 
 Public Function HvertZ(ByVal z As Double) As Double
' возвращает угол по измеренной глубине
    HvertZ = Curves("c_Hvert").GetPoint(z)
 End Function
' инициализация трубы через данные по траектории скважины
Public Sub InitPipeConstrTr(ByVal tr As CTrajectory, _
                            ByVal HmesStart_m As Double, ByVal HmesEnd_m As Double, _
                            Optional PipeType As PIPE_TYPE = pipeTubing)
    Dim i As Integer
    Dim h As Double
    Dim p_pipe_segments_num As Integer
    
    Curves("c_Diam").isStepFunction = True
    ZeroCoordMes_m = HmesStart_m
    ZeroCoordVert_m = tr.HabsZ_m(HmesStart_m)
    p_pipe_segments_num = tr.numPoints - 1
    ' по умолчанию используем все сегменты которые были заданы в траектории
    For i = 0 To p_pipe_segments_num
         h = tr.Hmes_m(i)
         If h >= HmesStart_m And h <= HmesEnd_m Then
            ' теперь  заполним кривые соответствующие траектории скважины  - в первый раз пишем нулевую точку
            Select Case PipeType
                Case pipeTubing
                    Curves("c_Diam").AddPoint h, tr.DtubZ_m(h)   ' НКТ
                    Curves("c_Roughness").AddPoint h, tr.RoughnessTub_m(i)
                Case pipeCasing:
                    Curves("c_Diam").AddPoint h, tr.DcasZ_m(h)   ' эксп
                    Curves("c_Roughness").AddPoint h, tr.RoughnessCas_m(i)
                Case pipeAnnulus:
                    Curves("c_Diam").AddPoint h, tr.DcasZ_m(h) - tr.DtubZ_m(h)  ' затруб
                    Curves("c_Roughness").AddPoint h, tr.RoughnessCas_m(i)
            End Select
            Curves("c_Theta").AddPoint h, tr.AngZ_deg(h)
            Curves("c_Hvert").AddPoint h, tr.HabsZ_m(h)
         End If
    Next i
    p_total_legth_m = HmesEnd_m - HmesStart_m
    p_total_depthVert_m = tr.HabsZ_m(HmesEnd_m) - tr.HabsZ_m(HmesStart_m)
    Call SetHmes_insert    ' после инициализации конструкции добавляем обязательные точки, которые надо добавить
    StepHmCurve = 100    ' ставим заведомо большой шаг для сохранения, чтобы сохранить только крайние точки
End Sub
' Метод прямой инициализации конструкции трубы из массивов или исходных данных
'
Public Sub InitPipeConstr(ByVal arr_d_m, _
                          ByVal arr_length_m, _
                          ByVal arr_theta_deg, _
                          ByVal arr_roughness_m)
    Dim length_
    Dim tot_length As Double
    Dim tot_length_mes As Double
    Dim i As Integer
    Dim p_pipe_segments_num As Integer
    
    i = 0
    tot_length = 0
    p_total_depthVert_m = 0
    tot_length_mes = ZeroCoordMes_m   ' повторно начнем использовать переменную для отсчета глубины
    If (IsObject(arr_length_m)) Then  ' length is specified as range
        For Each length_ In arr_length_m   'calculate total length
            tot_length = tot_length + length_
            i = i + 1
        Next
    Else
        If IsArray(arr_length_m) Then
            i = UBound(arr_length_m)
        Else
            i = 0
        End If
    End If
    
    If i > 0 Then
        p_pipe_segments_num = i + 1
        p_total_legth_m = tot_length
        For i = 0 To p_pipe_segments_num - 1
            ' теперь  заполним кривые соответствующие траектории скважины  - в первый раз пишем нулевую точку
            Curves("c_Diam").AddPoint tot_length_mes, arr_d_m(i)
            Curves("c_Theta").AddPoint tot_length_mes, arr_theta_deg(i)
            Curves("c_Roughness").AddPoint tot_length_mes, arr_roughness_m(i)
            Curves("c_Hvert").AddPoint tot_length_mes, p_total_depthVert_m
            tot_length_mes = tot_length_mes + arr_length_m(i)
            p_total_depthVert_m = p_total_depthVert_m + arr_length_m(i) * sind(arr_theta_deg(i))
        Next i
        i = p_pipe_segments_num - 1
        Curves("c_Diam").AddPoint tot_length_mes, arr_d_m(i)
        Curves("c_Theta").AddPoint tot_length_mes, arr_theta_deg(i)
        Curves("c_Roughness").AddPoint tot_length_mes, arr_roughness_m(i)
        Curves("c_Hvert").AddPoint tot_length_mes, p_total_depthVert_m
        i = p_pipe_segments_num - 1
        p_total_legth_m = tot_length_mes
    Else  ' just numbers
        p_pipe_segments_num = 1
        Dim parr_arr_d_m, parr_arr_theta_deg, parr_arr_roughness_m, parr_arr_length_m
        If IsArray(arr_length_m) Then
            parr_arr_length_m = arr_length_m(0)
            parr_arr_d_m = arr_d_m(0)
            parr_arr_theta_deg = arr_theta_deg(0)
            parr_arr_roughness_m = arr_roughness_m(0)
            p_total_legth_m = arr_length_m(0)
            p_total_depthVert_m = p_total_legth_m * sind(arr_theta_deg(0))
        Else
            parr_arr_length_m = arr_length_m
            parr_arr_d_m = arr_d_m
            parr_arr_theta_deg = arr_theta_deg
            parr_arr_roughness_m = arr_roughness_m
            p_total_legth_m = arr_length_m
            p_total_depthVert_m = p_total_legth_m * sind(arr_theta_deg)
        End If
        i = 0
        Curves("c_Diam").AddPoint tot_length_mes, parr_arr_d_m
        Curves("c_Theta").AddPoint tot_length_mes, parr_arr_theta_deg
        Curves("c_Roughness").AddPoint tot_length_mes, parr_arr_roughness_m
        Curves("c_Hvert").AddPoint tot_length_mes, ZeroCoordVert_m
        tot_length_mes = tot_length_mes + parr_arr_length_m
        Curves("c_Diam").AddPoint tot_length_mes, parr_arr_d_m
        Curves("c_Theta").AddPoint tot_length_mes, parr_arr_theta_deg
        Curves("c_Roughness").AddPoint tot_length_mes, parr_arr_roughness_m
        Curves("c_Hvert").AddPoint tot_length_mes, p_total_depthVert_m
    End If
    Call SetHmes_insert    ' после инициализации конструкции добавляем обязательные точки, которые надо добавить
    StepHmCurve = 100    ' ставим заведомо большой шаг для сохранения, чтобы сохранить только крайние точки
End Sub
Public Sub SetHmes_insert(Optional pointX As Double = 0)
    p_Hmes_insert_m.ClearPoints
    p_Hmes_insert_m.AddPoint ZeroCoordMes_m, 0
    p_Hmes_insert_m.AddPoint ZeroCoordMes_m + LengthMes_m, 0
    If pointX > ZeroCoordMes_m And pointX < (ZeroCoordMes_m + LengthMes_m) Then
        p_Hmes_insert_m.AddPoint pointX, 0
    End If
End Sub
Public Function InitPipe(ByVal d_m, _
                         ByVal Hmes0_m, _
                         ByVal Hmes1_m, _
                         ByVal theta_deg, _
                         Optional ByVal roughness_m = 0.00001)
' простой метод инициализации трубы по двум точкам
' используется для учебных примеров в функциях Excel
    Dim arr_d_m(0) As Double
    Dim arr_length_m(0) As Double
    Dim arr_theta_deg(0) As Double
    Dim arr_roughness_m(0) As Double
    Dim i As Integer
    For i = LBound(arr_d_m) To UBound(arr_d_m)
        arr_d_m(i) = d_m
        arr_theta_deg(i) = theta_deg
        arr_roughness_m(i) = roughness_m
    Next i
    
    arr_length_m(0) = Hmes1_m - Hmes0_m
    ZeroCoordMes_m = Hmes0_m
    ZeroCoordVert_m = 0
    
    Call InitPipeConstr(arr_d_m, arr_length_m, arr_theta_deg, arr_roughness_m)
    
End Function
'=================================================================================================
' новый подход - можно обойтись без разделение на прямой участок и кривой - расчет за один проход.
'=================================================================================================
Public Function CalcGrad(L_m As Double, _
                         P_atma As Double, _
                         T_C As Double, _
                         Optional calc_dtdl As Boolean = True, _
                         Optional Pcas_atma As Double = 0.95) As PIPE_FLOW_PARAMS
' функция расчета градиента давления и температуры в скважине при заданных параметрах
' возвращает все параметры потока в заданной точке трубы при заданых термобарических условиях.
'
'
'
'  L_m      - измеренная глубина на которой ведется расчет, нужна для привязки по температуре
'  P_atma   - давление в заданной точке
'  T_C      - температура в заданной точке
'  calc_dtdl
'  Pcas_atma - затрубное давление для оптимизации расчета барботажа в затрубе
'Allocate variables used to output auxilary values
Dim dpdlg_out As Double
Dim dpdlf_out As Double
Dim dpdla_out As Double
Dim v_sl_out As Double
Dim v_sg_out As Double
Dim vl_msec As Double
Dim vg_msec As Double
Dim h_l_out As Double
Dim fpat_out
Dim d_m As Double   ' диаметр трубы по которой идет поток
Dim theta_deg As Double ' угол наклона трубы в расчете
Dim rough_m As Double   ' шероховатость
Dim Hv_m As Double
Dim dp_dl As Double, dp_dl_arr
Dim dt_dl As Double
Dim v As Double, dvdL As Double
d_m = DiamZ(L_m)                ' определяем диаметр на указанной глубине
theta_deg = AngleThetaZ(L_m)    ' определяем наклон на заданной глубине
rough_m = RoughnessZ(L_m)       ' определяем шероховатость на заданной глубине
Hv_m = HvertZ(L_m)              ' определяем вертикальную глубину для заданной измеренной глубины
With Fluid
  'проверим на корректность исходных данных
    If P_atma < const_minPpipe_atma Then
        dp_dl = 0
        GoTo endlab:
    End If
  
    Call .Calc_PVT(P_atma, T_C)             ' найдем все PVT в заданных условиях
    If .Qmix_m3day = 0 Then
        T_C = AmbientForm.AmbTemp_С(Hv_m)
    End If
  
    If Param.correlation = BeggsBriilCor Then
            dp_dl_arr = unf_BegsBrillGradient(d_m, theta_deg, rough_m, .Qliq_rc_m3day, .Qgas_rc_m3day, .MuLiq_rc_cP, .Mug_cP, .sigma_liq_Nm, _
                                  .rho_liq_kgm3, .rho_gas_kgm3, 0, 1, betta_grav, betta_fric)
            dp_dl = dp_dl_arr(0)
            dpdlg_out = dp_dl_arr(1)
            dpdlf_out = dp_dl_arr(2)
            dpdla_out = dp_dl_arr(3)
            v_sl_out = dp_dl_arr(4)
            v_sg_out = dp_dl_arr(5)
            h_l_out = dp_dl_arr(6)
            fpat_out = dp_dl_arr(7)
    ElseIf Param.correlation = AnsariCor Then
            If P_atma > Pcas_atma Then
                dp_dl_arr = unf_AnsariGradient(d_m, theta_deg, rough_m, .Qliq_rc_m3day, .Qgas_rc_m3day, .MuLiq_rc_cP, .Mug_cP, .sigma_liq_Nm, _
                                  .rho_liq_kgm3, .rho_gas_kgm3, P_atma, , betta_grav, betta_fric)
            Else
                ReDim dp_dl_arr(7) As Double
                dp_dl_arr(0) = 0
                dp_dl_arr(1) = 0
                dp_dl_arr(2) = 0
                dp_dl_arr(3) = 0
                dp_dl_arr(4) = 0
                dp_dl_arr(5) = 0
                dp_dl_arr(6) = 0
                dp_dl_arr(7) = 101
            End If
            
            dp_dl = dp_dl_arr(0)
            dpdlg_out = dp_dl_arr(1)
            dpdlf_out = dp_dl_arr(2)
            dpdla_out = dp_dl_arr(3)
            v_sl_out = dp_dl_arr(4)
            v_sg_out = dp_dl_arr(5)
            h_l_out = dp_dl_arr(6)
            fpat_out = dp_dl_arr(7)
    ElseIf Param.correlation = Gas Then
            If P_atma > Pcas_atma Then
                dp_dl_arr = unf_GasGradient(d_m, theta_deg, rough_m, .Qgas_rc_m3day, .Mug_cP, _
                                           .rho_gas_kgm3, P_atma, betta_grav, betta_fric)
            Else
                ReDim dp_dl_arr(7) As Double
                dp_dl_arr(0) = 0
                dp_dl_arr(1) = 0
                dp_dl_arr(2) = 0
                dp_dl_arr(3) = 0
                dp_dl_arr(4) = 0
                dp_dl_arr(5) = 0
                dp_dl_arr(6) = 0
                dp_dl_arr(7) = 101
            End If
            dp_dl = dp_dl_arr(0)
            dpdlg_out = dp_dl_arr(1)
            dpdlf_out = dp_dl_arr(2)
            dpdla_out = dp_dl_arr(3)
            v_sl_out = dp_dl_arr(4)
            v_sg_out = dp_dl_arr(5)
            h_l_out = dp_dl_arr(6)
            fpat_out = dp_dl_arr(7)
    ElseIf Param.correlation = UnifiedCor Then
            dp_dl_arr = unf_UnifiedTUFFPGradient(d_m, theta_deg, rough_m, .Qliq_rc_m3day, .Qgas_rc_m3day, .MuLiq_rc_cP, .Mug_cP, .sigma_liq_Nm, _
                                  .rho_liq_kgm3, .rho_gas_kgm3, P_atma, , betta_grav, betta_fric)
                                      
            dp_dl = dp_dl_arr(0)
            dpdlg_out = dp_dl_arr(1)
            dpdlf_out = dp_dl_arr(2)
            dpdla_out = dp_dl_arr(3)
            v_sl_out = dp_dl_arr(4)
            v_sg_out = dp_dl_arr(5)
            h_l_out = dp_dl_arr(6)
            fpat_out = dp_dl_arr(7)
    ElseIf Param.correlation = Gray Then
            dp_dl_arr = unf_GrayModifiedGradient(d_m, theta_deg, rough_m, .Qliq_rc_m3day, .Qgas_rc_m3day, .MuLiq_rc_cP, .Mug_cP, .sigma_liq_Nm, _
                                  .rho_liq_kgm3, .rho_gas_kgm3, 0, 1, , betta_grav, betta_fric)
            dp_dl = dp_dl_arr(0)
            dpdlg_out = dp_dl_arr(1)
            dpdlf_out = dp_dl_arr(2)
            dpdla_out = dp_dl_arr(3)
            v_sl_out = dp_dl_arr(4)
            v_sg_out = dp_dl_arr(5)
            h_l_out = dp_dl_arr(6)
            fpat_out = dp_dl_arr(7)
    ElseIf Param.correlation = HagedornBrown Then
            dp_dl_arr = unf_HagedornandBrawnmodified(d_m, theta_deg, rough_m, .Qliq_rc_m3day, .Qgas_rc_m3day, .MuLiq_rc_cP, .Mug_cP, .sigma_liq_Nm, _
                                  .rho_liq_kgm3, .rho_gas_kgm3, P_atma, 0, 1, , betta_grav, betta_fric)
            dp_dl = dp_dl_arr(0)
            dpdlg_out = dp_dl_arr(1)
            dpdlf_out = dp_dl_arr(2)
            dpdla_out = dp_dl_arr(3)
            v_sl_out = dp_dl_arr(4)
            v_sg_out = dp_dl_arr(5)
            h_l_out = dp_dl_arr(6)
            fpat_out = dp_dl_arr(7)
    ElseIf Param.correlation = SakharovMokhov Then
            dp_dl_arr = unf_Saharov_Mokhov_Gradient(d_m, theta_deg, rough_m, P_atma, .Qo_scm3day, .Qw_scm3day, .Qgas_scm3day, .Bo_m3m3, _
                                      .Bw_m3m3, .Bg_m3m3, .rs_m3m3, .Muo_cP, .Muw_cP, .Mug_cP, .sigma_o_Nm, .sigma_w_Nm, .RhoOil_sckgm3, .rhoWat_sckgm3, .rhoGas_sckgm3, _
                                      , , , betta_grav, betta_fric)
            dp_dl = dp_dl_arr(0)
            dpdlg_out = dp_dl_arr(1)
            dpdlf_out = dp_dl_arr(2)
            dpdla_out = dp_dl_arr(3)
            v_sl_out = dp_dl_arr(4)
            v_sg_out = dp_dl_arr(5)
            h_l_out = dp_dl_arr(6)
            fpat_out = dp_dl_arr(7)
    End If
  
    vl_msec = v_sl_out * const_Pi * d_m ^ 2 / 4 ' скорость жидкости реальная
    vg_msec = v_sg_out * const_Pi * d_m ^ 2 / 4 ' скорость жидкости реальная
    ' для оценки температуры оценим скорость потока и ускорение
    
    ' теперь зададим изменение температуры в потоке
    If calc_dtdl Then
        Select Case Param.tempMethod
              Case StartEndTemp
                  dt_dl = dTdLlinear_Cm(Hv_m)
              Case GeoGradTemp
                  dt_dl = dTdLamb_Cm(Hv_m)
              Case AmbientTemp
                  v = vg_msec    ' оценка сверху
                  dvdL = -v / P_atma * dp_dl
                  dt_dl = AmbientForm.Calc_dTdL_Cm(Hv_m, sind(theta_deg), T_C, .Wm_kgsec, .Cmix_JkgC, _
                                                          dp_dl, v, dvdL, .CJT_Katm, Param.FlowDirection = FlowAgainstCoord)
        End Select
    End If
    ' тут надо записать в результаты все расчетные параметры
    Dim res As PIPE_FLOW_PARAMS
 
endlab:
 res.dp_dl = dp_dl
 res.dt_dl = dt_dl
 
         res.md_m = L_m                                 ' pipe measured depth (from start - top)
         res.vd_m = Hv_m                                ' pipe vertical depth from start - top
         res.dpdl_a_atmm = dpdla_out                    ' acceleration gradient at measured depth
         res.dpdl_f_atmm = dpdlf_out                    ' friction gradient at measured depth
         res.dpdl_g_atmm = dpdlg_out                    ' gravity gradient at measured depth
         res.fpat = fpat_out                            ' flow pattern code
         res.gasfrac = Fluid.GasFraction_d()
         res.h_l_d = h_l_out                            ' liquid hold up
         res.Qg_m3day = Fluid.Qgas_m3day
         res.P_atma = P_atma                              '  pipe pressure at measured depth
         res.T_C = T_C                                  ' pipe temp at measured depth
         res.v_sl_msec = v_sl_out                       ' superficial liquid velosity
         res.v_sg_msec = v_sg_out                       ' superficial gas velosity
         res.thete_deg = theta_deg                      '
         res.roughness_m = rough_m                      '
         res.rs_m3m3 = Fluid.rs_m3m3                    ' растворенный газ в нефти в потоке
         res.gasfrac = Fluid.GasFraction_d              ' расходное содержание газа в потоке
         res.Muo_cP = Fluid.Muo_cP                      ' вязкость нефть в потоке
         res.Muw_cP = Fluid.Muw_cP                      ' вязкость воды в потоке
         res.Mug_cP = Fluid.Mug_cP                      ' вязкость газа в потоке
         res.MuMix_cP = Fluid.MuMix_cP                  ' вязкость смеси в потоке
         res.Rhoo_kgm3 = Fluid.rho_oil_kgm3             ' плотность нефти
         res.Rhow_kgm3 = Fluid.rho_water_kgm3           ' плотность воды
         res.rhol_kgm3 = Fluid.rho_liq_kgm3             ' плотность жидкости
         res.Rhog_kgm3 = Fluid.rho_gas_kgm3             ' плотность газа
         res.rhomix_kgm3 = Fluid.rho_mix_kgm3           ' плотность смеси в потоке
         res.Qo_m3day = Fluid.Qo_m3day                  ' расход нефти в рабочих условиях
         res.Qw_m3day = Fluid.Qw_m3day                  ' расход воды в рабочих условиях
         res.Qg_m3day = Fluid.Qgas_m3day                ' расход газа в рабочих условиях
         res.mo_kgsec = Fluid.mo_kgsec                  ' массовый расход нефти в рабочих условиях
         res.mw_kgsec = Fluid.mw_kgsec                  ' массовый расход воды в рабочих условиях
         res.mg_kgsec = Fluid.mg_kgsec                  ' массовый расход газа в рабочих условиях
         res.vl_msec = vl_msec  ' скорость жидкости реальная
         res.vg_msec = vg_msec  ' скорость газа реальная
  
 CalcGrad = res
End With
'
End Function
Public Function Calc_dPipe(PT As PTtype, Optional saveCurve As CALC_RESULTS = noCurves) As PTtype
' здесь выбираем метод расчета
' если не надо рассчитывать эмисию тепла - то можно расчет делать только по давлению - это быстрее
' если температуру рассчитываем то решаем систему и по давлению и по температуре - медленнее
    If Param.tempMethod = AmbientTemp Then
        Calc_dPipe = Calc_dPipe_2d(PT, saveCurve)
    Else
        Calc_dPipe = Calc_dPipe_1d(PT.P_atma, saveCurve)
    End If
End Function
Public Function Calc_dPipe_2d(PT As PTtype, Optional saveCurve As CALC_RESULTS = noCurves) As PTtype
' новая версия расчета перепада давления в трубе, сразу с учетом инклинометрии
' основан на применении ODEsolver
' PT   - термобарические условия в точке задания условия по давлению
' SaveCurve - флаг показывающий необходимость сохранения детальных результатов расчета
' Tother_C  - опциональное значение температуры на другом конце трубы, необходимо при линейном
'             распределении температуры
Dim Y0(1) As Double   ' начальные значения для проведения расчета
Dim n, M As Long
Dim x() As Double, y() As Double     ' массив глубин для которых нужны значения
Dim eps As Double
Dim Step As Double
Dim State As ODESolverState
Dim Rtn As Boolean
Dim i As Integer
Dim pfp As PIPE_FLOW_PARAMS
Dim Rep As ODESolverReport
Dim stPt As Boolean
'ReDim Y0(1)
On Error GoTo err1:
    eps = 0.01
    Step = 10
    Y0(0) = PT.P_atma
    Y0(1) = PT.T_C
    n = 2                   ' размер системы  - две переменные - давление и температура
    M = p_HmCurve.numPoints ' количество точек для которых надо выдать ответ
    ' формируем массив глубин для расчета давления
    ' учитываем, что массив глубин зависит от направления в котором отсчитываем координаты
    ReDim x(M - 1)
    
    For i = 0 To M - 1
        If Param.FlowDirection = FlowAlongCoord Then
            x(i) = p_HmCurve.pointX(i + 1)
        Else
            x(i) = p_HmCurve.pointX(M - i)
        End If
    Next i
      ' проверка - если поток в скважине нулевой, тогда температура равна температуре окружающей среды
      ' без такой проверки расчет градиента температуры сходит с ума
    If Fluid.Qliq_scm3day = 0 Then
        Y0(1) = AmbientForm.AmbTemp_С(x(0))
    End If
    Call ODESolverRKCK(Y0(), n, x, M, eps, Step, State)
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "FuncName" is called using
    ' the Application.Run method.
    Rtn = True
    i = 0
    Do While Rtn = True And i < 10000
        Rtn = ODESolverIteration(State)
        pfp = CalcGrad(State.x, State.y(0), State.y(1))  ' Application.Run(FuncName, State.X, State.Y, CoeffA)
        State.DY(0) = pfp.dp_dl
        State.DY(1) = pfp.dt_dl
        i = i + 1
    Loop
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
    Call ODESolverResults(State, M, x, y, Rep)
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    ' Assign the output array to the function return value
    ' ODE = YA2
    
    ' подговим выходные результаты функции
    Calc_dPipe_2d.P_atma = y(M - 1, 0)
    Calc_dPipe_2d.T_C = y(M - 1, 1)
    If saveCurve > 0 Then
    ' сохраним результаты расчета для отображения на графиках
        Curves("c_P").ClearPoints
        Curves("c_T").ClearPoints
        Curves("c_Tamb").ClearPoints
        For i = 0 To M - 1
            stPt = i = 0 Or i = M - 1
            Curves("c_P").AddPoint x(i), y(i, 0), stPt
            Curves("c_T").AddPoint x(i), y(i, 1), stPt
            If Param.tempMethod = AmbientTemp Then
                Curves("c_Tamb").AddPoint x(i), AmbientForm.AmbTemp_С(Curves("c_Hvert").GetPoint(x(i))), stPt
            Else
                Curves("c_Tamb").AddPoint x(i), y(i, 1), stPt
            End If
        Next i
        If saveCurve > 1 Then
            Call FillDetailedCurve
        End If
    End If
    Exit Function
err1:
    addLogMsg ("CPipe.Calc_dPipe_2d: ошибка какая то")
    Err.Raise Err.Number, Err.Source, Err.Description
End Function
Public Function Calc_dPipe_1d(P_atma As Double, Optional saveCurve As CALC_RESULTS = noCurves) As PTtype
' новая версия расчета перепада давления в трубе, сразу с учетом инклинометрии
' основан на применении ODEsolver
' проверка работы одномерного решателя - ради скорости расчета
Dim Y0(0) As Double   ' начальные значения для проведения расчета
Dim n, M As Long
Dim x() As Double, y() As Double     ' массив глубин для которых нужны значения
Dim eps As Double
Dim Step As Double
Dim State As ODESolverState
Dim Rtn As Boolean
Dim i As Integer
Dim pfp As PIPE_FLOW_PARAMS
Dim Rep As ODESolverReport
Dim stPt As Boolean
On Error GoTo err1:
    eps = 0.1
    Step = 10
    Y0(0) = P_atma
    
'    Y0(1) = PT.T_C
    n = 1                   ' размер системы  - одна переменные - давление и температура
    M = p_HmCurve.numPoints ' количество точек для которых надо выдать ответ
    ' формируем массив глубин для расчета давления
    ' учитываем, что массив глубин зависит от направления в котором отсчитываем координаты
    ReDim x(M - 1)
    For i = 0 To M - 1
        If Param.FlowDirection = FlowAlongCoord Then
            x(i) = p_HmCurve.pointX(i + 1)
        Else
            x(i) = p_HmCurve.pointX(M - i)
        End If
    Next i
      ' проверка - если поток в скважине нулевой, тогда температура равна температуре окружающей среды
      ' без такой проверки расчет градиента температуры сходит с ума
'    If Fluid.Qliq_scm3day = 0 Then
'        Y0(1) = AmbientForm.AmbTemp_С(X(0))
'    End If
    Call ODESolverRKCK(Y0(), n, x, M, eps, Step, State)
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "FuncName" is called using
    ' the Application.Run method.
    Rtn = True
    i = 0
    Do While Rtn = True And i < 10000
        Rtn = ODESolverIteration(State)
        If State.y(0) < const_minPpipe_atma Then
        ' при расчете давления получили отрицательные значения
        ' может происходить про расчете в затрубе
        ' тогда имитируем правильное завершение работы цикла
            State.RepTerminationType = 2
            Rtn = False
        End If
        pfp = CalcGrad(State.x, State.y(0), Tinit_C(State.x), calc_dtdl:=False)
        State.DY(0) = pfp.dp_dl
        i = i + 1
    Loop
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
    Call ODESolverResults(State, M, x, y, Rep)
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    ' Assign the output array to the function return value
    ' ODE = YA2
    
    ' подговим выходные результаты функции
    Calc_dPipe_1d.P_atma = y(M - 1, 0)
    Calc_dPipe_1d.T_C = Tinit_C(x(M - 1))
    If saveCurve > 0 Then
    ' сохраним результаты расчета для отображения на графиках
        Curves("c_P").ClearPoints
        Curves("c_T").ClearPoints
        Curves("c_Tamb").ClearPoints
        For i = 0 To M - 1
            stPt = i = 0 Or i = M - 1
            Curves("c_P").AddPoint x(i), y(i, 0), stPt
            Curves("c_T").AddPoint x(i), Tinit_C(x(i)), stPt
            Curves("c_Tamb").AddPoint x(i), Tinit_C(x(i)), stPt
        Next i
        If saveCurve > 1 Then
            Call FillDetailedCurve
        End If
    End If
    Exit Function
err1:
    addLogMsg ("CPipe.Calc_dPipe_1d: ошибка какая то")
    Err.Raise Err.Number, Err.Source, Err.Description
End Function
Public Function Calc_dPipeZNLF(PT As PTtype, Optional saveCurve As CALC_RESULTS = noCurves) As PTtype
    ' расчет перепада давления в неподвижной колонне с газом
    Fluid.ZNLF = True
    Calc_dPipeZNLF = Calc_dPipe_1d(PT.P_atma, saveCurve)
End Function
Public Sub FillDetailedCurve()
' функция расчета  детальных распределений параметров по длине трубы
Dim i As Integer
Dim M As Integer
Dim FlowParams_out As PIPE_FLOW_PARAMS
    M = Curves("c_P").numPoints
    
    CurvesOut.ClearPoints
 
    For i = 1 To M
     FlowParams_out = CalcGrad(p_HmCurve.pointX(i), Curves("c_P").PointY(i), Curves("c_T").PointY(i))
     With FlowParams_out
        CurvesOut("c_Hvert").AddPoint .md_m, .vd_m
        CurvesOut("c_dpdl_g").AddPoint .md_m, .dpdl_g_atmm
        CurvesOut("c_dpdl_f").AddPoint .md_m, .dpdl_f_atmm
        CurvesOut("c_dpdl_a").AddPoint .md_m, .dpdl_a_atmm
        CurvesOut("c_vsl").AddPoint .md_m, .v_sl_msec
        CurvesOut("c_vsg").AddPoint .md_m, .v_sg_msec
        CurvesOut("c_Hl").AddPoint .md_m, .h_l_d
        CurvesOut("c_fpat").AddPoint .md_m, .fpat
        CurvesOut("c_Theta").AddPoint .md_m, .thete_deg
        CurvesOut("c_Roughness").AddPoint .md_m, .roughness_m
        CurvesOut("c_Rs").AddPoint .md_m, .rs_m3m3
        CurvesOut("c_gasfrac").AddPoint .md_m, .gasfrac
        CurvesOut("c_muo").AddPoint .md_m, .Muo_cP
        CurvesOut("c_muw").AddPoint .md_m, .Muw_cP
        CurvesOut("c_mug").AddPoint .md_m, .Mug_cP
        CurvesOut("c_mumix").AddPoint .md_m, .MuMix_cP
        CurvesOut("c_rhoo").AddPoint .md_m, .Rhoo_kgm3
        CurvesOut("c_rhow").AddPoint .md_m, .Rhow_kgm3
        CurvesOut("c_rhol").AddPoint .md_m, .rhol_kgm3
        CurvesOut("c_rhog").AddPoint .md_m, .Rhog_kgm3
        CurvesOut("c_rhomix").AddPoint .md_m, .rhomix_kgm3
        CurvesOut("c_qo").AddPoint .md_m, .Qo_m3day
        CurvesOut("c_qw").AddPoint .md_m, .Qw_m3day
        CurvesOut("c_qg").AddPoint .md_m, .Qg_m3day
        CurvesOut("c_mo").AddPoint .md_m, .mo_kgsec
        CurvesOut("c_mw").AddPoint .md_m, .mw_kgsec
        CurvesOut("c_mg").AddPoint .md_m, .mg_kgsec
        CurvesOut("c_vl").AddPoint .md_m, .vl_msec
        CurvesOut("c_vg").AddPoint .md_m, .vg_msec
     End With
    Next i
End Sub
'Private Sub fillCurves()
'Dim i As Integer
'    CurvesOut("c_Hvert").ClearPoints
'    CurvesOut("c_P").ClearPoints
'    CurvesOut("c_T").ClearPoints
'    CurvesOut("c_dpdl_g").ClearPoints
'    CurvesOut("c_dpdl_f").ClearPoints
'    CurvesOut("c_dpdl_a").ClearPoints
'    CurvesOut("c_vsl").ClearPoints
'    CurvesOut("c_vsg").ClearPoints
'    CurvesOut("c_Hl").ClearPoints
'    CurvesOut("c_fpat").ClearPoints
'    CurvesOut("c_Rs").ClearPoints
'    CurvesOut("c_gasfrac").ClearPoints
'    CurvesOut("c_muo").ClearPoints
'    CurvesOut("c_muw").ClearPoints
'    CurvesOut("c_mug").ClearPoints
'    CurvesOut("c_mumix").ClearPoints
'    CurvesOut("c_rhoo").ClearPoints
'    CurvesOut("c_rhow").ClearPoints
'    CurvesOut("c_rhol").ClearPoints
'    CurvesOut("c_rhog").ClearPoints
'    CurvesOut("c_rhomix").ClearPoints
'    CurvesOut("c_qo").ClearPoints
'    CurvesOut("c_qw").ClearPoints
'    CurvesOut("c_qg").ClearPoints
'    CurvesOut("c_mo").ClearPoints
'    CurvesOut("c_mw").ClearPoints
'    CurvesOut("c_mg").ClearPoints
'    CurvesOut("c_vl").ClearPoints
'    CurvesOut("c_vg").ClearPoints
'
'
'    For i = LBound(p_FlowParams_out) To UBound(p_FlowParams_out)
'     With p_FlowParams_out(i)
'        CurvesOut("c_Hvert").AddPoint .md_m, .vd_m
'        CurvesOut("c_P").AddPoint .md_m, .P_atma
'        CurvesOut("c_T").AddPoint .md_m, .T_C
'        CurvesOut("c_dpdl_g").AddPoint .md_m, .dpdl_g_atmm
'        CurvesOut("c_dpdl_f").AddPoint .md_m, .dpdl_f_atmm
'        CurvesOut("c_dpdl_a").AddPoint .md_m, .dpdl_a_atmm
'        CurvesOut("c_vsl").AddPoint .md_m, .v_sl_msec
'        CurvesOut("c_vsg").AddPoint .md_m, .v_sg_msec
'        CurvesOut("c_Hl").AddPoint .md_m, .h_l_d
'        CurvesOut("c_fpat").AddPoint .md_m, .fpat
'        CurvesOut("c_Theta").AddPoint .md_m, .thete_deg
'        CurvesOut("c_Roughness").AddPoint .md_m, .roughness_m
'
'        CurvesOut("c_Rs").AddPoint .md_m, .rs_m3m3
'        CurvesOut("c_gasfrac").AddPoint .md_m, .gasfrac
'        CurvesOut("c_muo").AddPoint .md_m, .Muo_cP
'        CurvesOut("c_muw").AddPoint .md_m, .Muw_cP
'        CurvesOut("c_mug").AddPoint .md_m, .Mug_cP
'        CurvesOut("c_mumix").AddPoint .md_m, .MuMix_cP
'        CurvesOut("c_rhoo").AddPoint .md_m, .Rhoo_kgm3
'        CurvesOut("c_rhow").AddPoint .md_m, .Rhow_kgm3
'        CurvesOut("c_rhol").AddPoint .md_m, .rhol_kgm3
'        CurvesOut("c_rhog").AddPoint .md_m, .Rhog_kgm3
'        CurvesOut("c_rhomix").AddPoint .md_m, .rhomix_kgm3
'        CurvesOut("c_qo").AddPoint .md_m, .Qo_m3day
'        CurvesOut("c_qw").AddPoint .md_m, .Qw_m3day
'        CurvesOut("c_qg").AddPoint .md_m, .Qg_m3day
'        CurvesOut("c_mo").AddPoint .md_m, .mo_kgsec
'        CurvesOut("c_mw").AddPoint .md_m, .mw_kgsec
'        CurvesOut("c_mg").AddPoint .md_m, .mg_kgsec
'        CurvesOut("c_vl").AddPoint .md_m, .vl_msec
'        CurvesOut("c_vg").AddPoint .md_m, .vg_msec
'     End With
'    Next i
'End Sub
'
Public Property Get PCurve() As TInterpolation
    Set PCurve = Curves("c_P")
End Property
