'=======================================================================================
'Unifloc 7.6  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' класс для расчета свойств скважины c УЭЦН - распределение давления и температуры в скважине
Option Explicit
Option Base 0
Implements IWell
' ============ general well objects ===========
' штуцер установленный на поверхности
' choke always exist in well (but can have diam = 0 which means - no influence on flow)
Private p_choke As New Cchoke
' input fluid object
Private p_Fluid As New CPVT                  ' флюид из пласта
Public Trajectory As New CTrajectory         ' полная траектория скважины с инклинометрии (основной способ задания скважины)
' abbient formation object needed for full temperature calculation
' must be accessed through property - in order to pass it to pipes properly
Private p_AmbientForm As New CAmbientFormation
' calculated parameters for well
Private p_PTbuf As PTtype
Private p_PTlin As PTtype
Private p_PTcas As PTtype
Private p_PTwf As PTtype
' temperature params
' температура задается отдельно, поэтому для удобства прямые параметры для работы с температурной моделью скважины заданы
Private p_Twh_C As Double
Private p_Tsurf_C As Double
Private p_Tbh_C As Double
Private p_Tintake_C As Double
Private p_Tres_C As Double
Private p_Param As PARAMCALC                 ' параметры расчета по трубе
 ' поправочные коэффициенты для расчета распределения давления
Private p_betta_grav As Double
Private p_betta_fric As Double
Public Curve As New CCurves           ' коллекция кривых с результатами расчетов
Public Event ReportProgress(msg As String)
' ============ESP well objects =======================================
Public isCalcCasing As Boolean
Public isCalcESPtemp As Boolean
' параметры УЭЦН
Private p_ESP As CESPsystemSimple            '
' ключевые элементы конструкции
Private p_Pipe_HspHvd As New CPipe           ' от приема насоса до забоя (перфорации)      ' pipe segment from bottom to tubing setting depth
Private p_Pipe_WHeadHsp_Tubing As New CPipe  ' от приема насоса по устья скважины до нкт
Private p_Pipe_WHeadHsp_Casing As New CPipe  ' от приема насоса до устья
Private p_Pipe_WHeadHsp_Casing_Gas As New CPipe  ' от приема насоса до устья газовая шапка в затрубе с учетом плотности газа
' ===========================================
Private p_Hsp_m As Double                   ' tubing depth
'данные расчета
Private p_PTintake As PTtype
Private p_PTdis As PTtype
Private p_Hd_m As Double                    ' динамический уровень
Private p_ESP_on As Boolean                 '  УЭЦН включен или нет (флаг)
' ============ constructor ====================
Private Sub Class_Initialize()
    With p_Param
        .correlation = BeggsBriilCor
        .FlowDirection = FlowAgainstCoord
        .tempMethod = StartEndTemp
    End With
    Param = p_Param                         ' здесь распространим все настройки на трубы
    p_ESP_on = False                        ' по умолчанию УЭЦН отключен
    p_betta_grav = 1
    p_betta_fric = 1
    isCalcCasing = True
    isCalcESPtemp = False
    InitWellConstruction 2500, 2000     ' init with some dummy data
    InitWellTemperature                 ' init temp with some data
    
End Sub
'------------------------------------------------------------
' choke general  properties
'------------------------------------------------------------
Property Get Choke() As Cchoke
   Set Choke = p_choke
End Property
Public Sub SetChoke(dChoke_mm, Optional dTub_mm = 62)
' установка параметров штуцера
   p_choke.Dchoke_m = dChoke_mm / 1000
   p_choke.Ddown_m = dTub_mm / 1000
   p_choke.Dup_m = dTub_mm / 1000
End Sub
 
Public Sub clearChoke()
   p_choke.Dchoke_m = 0
End Sub
Private Function isChoke() As Boolean
   isChoke = p_choke.Dchoke_m > 0
End Function
'------------------------------------------------------------
' fluid general properties
'------------------------------------------------------------
Public Property Get Fluid() As CPVT
   Set Fluid = p_Fluid
End Property
Public Property Get FluidTub() As CPVT
   If IsESP Then Set FluidTub = ESP.FluidTub
End Property
Public Property Get FluidCas() As CPVT
   If IsESP Then Set FluidCas = ESP.FluidCas
End Property
Public Property Set Fluid(val As CPVT)
' Установка PVT свойств для скважины
' Для разных сегментов скважины задается один и тот же флюид. После расчета скважины некоторые флюиды могут модифицироваться
  Set p_Fluid = val
  Set p_Pipe_HspHvd.Fluid = Fluid
  Set p_Pipe_WHeadHsp_Casing.Fluid = Fluid
  Set p_Pipe_WHeadHsp_Casing_Gas.Fluid = Fluid
  Set p_Pipe_WHeadHsp_Tubing.Fluid = Fluid
  Set Choke.Fluid = Fluid
  If IsESP Then
      Set ESP.Fluid = Fluid
  End If
End Property
' ---------------------------------------------------------------
' flow correlations tuning methods
' ---------------------------------------------------------------
Public Property Get betta_grav() As Double
   betta_grav = p_betta_grav
End Property
Public Property Get betta_fric() As Double
   betta_fric = p_betta_fric
End Property
Public Property Let betta_grav(val As Double)
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       p_Pipe_HspHvd.betta_grav = val
       p_Pipe_WHeadHsp_Casing.betta_grav = val
       p_Pipe_WHeadHsp_Casing_Gas.betta_grav = val
       p_Pipe_WHeadHsp_Tubing.betta_grav = val
'       p_Pipe_WHeadHspFact_Tubing.betta_grav = val
       p_betta_grav = val
       If val <> 1 Then addLogMsg_debug "CWellESP.betta_grav = " & str(val) & " warning. correction to multiphase flow correlation active!"
   Else
       addLogMsg_debug "CWellESP.betta_grav: value " & str(val) & " not set. Out of range"
   End If
End Property
 
Public Property Let betta_fric(val As Double)
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       p_Pipe_HspHvd.betta_fric = val
       p_Pipe_WHeadHsp_Casing.betta_fric = val
       p_Pipe_WHeadHsp_Casing_Gas.betta_fric = val
       p_Pipe_WHeadHsp_Tubing.betta_fric = val
'       p_Pipe_WHeadHspFact_Tubing.betta_fric = val
       p_betta_fric = val
       If val <> 1 Then addLogMsg_debug "CWellESP.betta_fric = " & str(val) & " warning. correction to multiphase flow correlation friction active!"
   Else
       addLogMsg_debug "CWellESP.betta_fric: value " & str(val) & " not set. Out of range"
   End If
End Property
 
Public Property Get HFlowCorrelation() As H_CORRELATION
    HFlowCorrelation = Param.correlation
End Property
Public Property Let HFlowCorrelation(val As H_CORRELATION)
    Dim prm As PARAMCALC
    prm = Param
    prm.correlation = val
    Param = prm
End Property
 
Public Property Get TempCorrelation() As TEMP_CALC_METHOD
    TempCorrelation = Param.tempMethod
End Property
 
Public Property Let TempCorrelation(val As TEMP_CALC_METHOD)
    Dim prm As PARAMCALC
    prm = Param
    prm.tempMethod = val
    Param = prm
End Property
 
Public Property Get Param() As PARAMCALC
    Param = p_Param
End Property
Public Property Let Param(val As PARAMCALC)
    p_Param = val
    p_Pipe_HspHvd.Param = val
    p_Pipe_WHeadHsp_Casing.Param = val
    p_Pipe_WHeadHsp_Casing_Gas.Param = val
    p_Pipe_WHeadHsp_Tubing.Param = val
End Property
'------------------------------------------------------------
' temperature general properties
'------------------------------------------------------------
Public Property Get Tline_C() As Double
    Tline_C = p_PTlin.T_C
End Property
Public Property Get Tbuf_C() As Double
    Tbuf_C = p_PTbuf.T_C
End Property
 
Public Property Get Tbh_C() As Double
    Tbh_C = p_PTwf.T_C
End Property
 
Public Property Get Twh_C() As Double
    Twh_C = p_PTbuf.T_C
End Property
Public Property Get Tsurf_C() As Double
    On Error Resume Next
    Tsurf_C = p_PTbuf.T_C
    Tsurf_C = AmbientForm.AmbTemp_С(0)
End Property
Public Property Get AmbientForm() As CAmbientFormation
    Set AmbientForm = p_AmbientForm
End Property
Public Property Set AmbientForm(ByVal vNewValue As CAmbientFormation)
    Set p_AmbientForm = vNewValue
    Set p_Pipe_HspHvd.AmbientForm = p_AmbientForm
    Set p_Pipe_WHeadHsp_Casing.AmbientForm = p_AmbientForm
    Set p_Pipe_WHeadHsp_Casing_Gas.AmbientForm = p_AmbientForm
    Set p_Pipe_WHeadHsp_Tubing.AmbientForm = p_AmbientForm
    ' после ручного задания объекта - периинициализируем параметры температурного расчета
    Call InitWellTemperature
End Property
'------------------------------------------------------------
' pressure general properties
'------------------------------------------------------------
Public Property Get Pline_atma() As Double
   Pline_atma = p_PTlin.P_atma
End Property
Public Property Get Pbuf_atma() As Double
' buffer pressure
   Pbuf_atma = p_PTbuf.P_atma
End Property
Public Property Get Pwf_atma() As Double
' давление на забое
   Pwf_atma = p_PTwf.P_atma
End Property
Public Property Get Pan_atma() As Double
' annulus presure
   Pan_atma = p_PTcas.P_atma
End Property
Public Property Get Pcas_atma() As Double
    Pcas_atma = p_PTcas.P_atma
End Property
Public Property Let Pcas_atma(ByVal Pcas_atma As Double)
    p_PTcas.P_atma = Pcas_atma
End Property
'------------------------------------------------------------
' well rates general properties
'------------------------------------------------------------
Property Let Qliq_scm3day(Qval_scm3day As Double)
   Fluid.Qliq_scm3day = Qval_scm3day
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set Fluid = Fluid
End Property
' дебит жидкости из скважины в поверхностных условиях
Public Property Get Qliq_scm3day() As Double
   Qliq_scm3day = p_Fluid.Qliq_scm3day
End Property
Public Property Get W_kgsec() As Double
'    массовый расход продукции рассчитаем
   W_kgsec = p_Fluid.Wm_kgsec
End Property
Public Property Get Qo_scm3day() As Double
   Qo_scm3day = p_Fluid.Qo_m3day
End Property
Public Property Get Qo_sctday() As Double
   Qo_sctday = Qliq_scm3day * (1 - p_Fluid.wc_fr) * p_Fluid.gamma_o
End Property
Public Property Get Qw_scm3day() As Double
   Qw_scm3day = Qliq_scm3day * p_Fluid.wc_fr
End Property
Public Property Get Qg_scm3day() As Double
   Qg_scm3day = p_Fluid.Qgas_scm3day
End Property
Property Get fw_perc() As Double
    fw_perc = p_Fluid.wc_perc
End Property
Property Let fw_perc(wcval As Double)
   Dim Wc As Double
   Wc = wcval / 100
   Fluid.wc_fr = Wc
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set Fluid = p_Fluid
End Property
Property Let Rp_m3m3(Rpval As Double)
   Fluid.Rp_m3m3 = Rpval
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set Fluid = p_Fluid
End Property
' ---------------------------------------------------------------
' service function
' ---------------------------------------------------------------
   
 Public Function Clone() As CWellESP
    Dim wl As New CWellESP
    Dim i As Integer
    Set wl.Trajectory = Trajectory   ' это должно сработать вместо инициализации
    Set wl.AmbientForm = AmbientForm
    Call wl.Choke.Copy(Choke)
    
    Dim ESP_1 As New CESPpump
    Call ESP_1.Copy(ESP)
    Set wl.ESP = ESP_1
    
    Set wl.Fluid = Fluid.Clone
    
    Set Clone = wl
 End Function
 
 
' =======================================
' методы инициализации скважины
' =======================================
Public Sub InitWellConstruction(ByVal Hperf_m As Double, _
                                ByVal Htub_m As Double, _
                       Optional ByVal dCas_mm As Double = 125, _
                       Optional ByVal dTub_mm As Double = 72, _
                       Optional ByVal Udl_m As Double = 0, _
                       Optional ByVal hmes_incl_range_m_ = -1, _
                       Optional ByVal hvert_incl_range_m_ = -1, _
                       Optional ByVal hmes_dcas_range_m_ = -1, _
                       Optional ByVal dcas_range_mm_ = -1, _
                       Optional ByVal hmes_dtub_range_m_ = -1, _
                       Optional ByVal dtub_range_mm_ = -1)
    ' универсальный метод инициализации скважины - должен использоваться для инициализации скважины
    ' поддерживает три варианта инициалиции
    '       - с упрощенным набором данных с удлинением (загрузка из тех режима)
    '       - с заданием инклинометрии через range и упрощенным набором труб (диаметры)
    '       - с заданием инклинометрии и диаметров с использованием range
    '
    ' параметры обязательные для всех вариантов задания
    ' Hperf_m               - глубина перфорации измеренная, м. Используется для расчета забойного давления
    ' Htub_m                - глубина спуска НКТ измеренная, м. Соответствует глубине спуска насоса
    '
    ' параметры упрощенного режима задания
    ' dCas_mm               - внутренний диамет эксплуатационной колонны, мм
    ' dTub_mm               - внешний диамет НКТ, мм (толщина стенки 10 мм)
    ' Udl_m                 - удлинение на глубину перфорации, м (разница между измеренной и вертикальной глубиной)
    '
    ' параметры детального задания скважины  (все - вертикальные range)
    ' hmes_incl_range_m_    - измеренная глубина скважины для задания инклинометрии
    ' hvert_incl_range_m_   - вертикальная глубина скважины для задания инклинометрии
    '                       - если инклинометрии как range задана, то удлинение игнорируется
    '
    ' hmes_dcas_range_m_    - измеренная глубина для задания диаметра эксплуатационной колонны (начинается с 0)
    ' dcas_range_mm_        - диаметр эксплуатационной колонны на соответствующей глубине (действует от глубины и вниз до след изменения)
    ' hmes_dtub_range_m_    - измеренная глубина для задания диаметра НКТ
    ' dtub_range_mm_        - диаметр НКТ внешний на соответствующей глубине (действует от глубины и вниз до след изменения)
    '                       - для полного задания скважины все range должны быть заданы
    
    
    Dim simpleNumbers As Boolean
    Dim fullRange As Boolean
    Dim inclRange As Boolean
    Dim fullArray As Boolean
On Error GoTo er1:
    simpleNumbers = IsNumeric(hmes_incl_range_m_)
    inclRange = IsObject(hmes_incl_range_m_) And IsObject(hvert_incl_range_m_)
    fullRange = inclRange And IsObject(hmes_dcas_range_m_) And IsObject(dcas_range_mm_) And _
                              IsObject(hmes_dtub_range_m_) And IsObject(dtub_range_mm_)
    
    If simpleNumbers Then
    ' use simple numbers here
        Call FillWellConstructionSimple(Hperf_m, Htub_m, Udl_m, dCas_mm, dTub_mm)
    ElseIf fullRange Then
        Call FillWellConstructionRangeAll(hmes_incl_range_m_, hvert_incl_range_m_, hmes_dcas_range_m_, _
                              dcas_range_mm_, hmes_dtub_range_m_, dtub_range_mm_, _
                              Hperf_m, Htub_m)
    ElseIf inclRange Then
        Call FillWellConstructionRange(hmes_incl_range_m_, hvert_incl_range_m_, Hperf_m, Htub_m, dCas_mm, dTub_mm)
    End If
    Exit Sub
er1:
    ' стандартная схема обработки ошибок
    Dim err_str As String
    err_str = "CWellESP.InitWellConstruction: error" & sDELIM & Err.Description
    addLogMsg err_str
    RaiseEvent ReportProgress(err_str)
    Err.Raise Err.Number, Err.Source, err_str
End Sub
Public Sub InitWellTemperature(Optional ByVal Tbh_C As Double = -1, _
                               Optional ByVal Twh_C As Double = -1, _
                               Optional ByVal hmes_tamb_arr_m_ = -1, _
                               Optional ByVal tamb_arr_C_ = -1)
   ' основная функция инициализации температуры в скважине
   ' задает по исходным данным объект AmbientForm, который определяет параметры температуры в скважине
   '
   ' если никакие параметры не заданы, скважине переинициализируется используя уже заданный объект p_AmbientForm
   '
   ' Tbh_C              - температура на забое скважины
   ' Twh_C              - температура на устье скважины
   ' hmes_tamb_arr_m_   - массив (range) измеренных глубин для задания распределения температуры по глубине
   ' tamb_arr_C_        - значения температуры по глубине
   
   
    Dim simpleNumbers As Boolean
    Dim ambRange As Boolean
    Dim newTempValues As Boolean
    
    Dim geoGrad As New TInterpolation
    Dim ambTemp As New CAmbientFormation
    Dim RangX As Range, RangY As Range
On Error GoTo err1:
    simpleNumbers = IsNumeric(hmes_tamb_arr_m_)
    ambRange = IsObject(hmes_tamb_arr_m_) And IsObject(tamb_arr_C_)
    newTempValues = ((Tbh_C > 20) And (Twh_C > 0)) Or ambRange
    
    If newTempValues Then
        If simpleNumbers Then
            geoGrad.AddPoint 0, Twh_C
            geoGrad.AddPoint Trajectory.Hperfvert_m, Tbh_C
        ElseIf ambRange Then
            Set RangX = hmes_tamb_arr_m_
            Set RangY = tamb_arr_C_
            Call geoGrad.LoadFromVertRange(RangX, RangY)
        End If
        Set ambTemp.AmbTempCurve = geoGrad
        Set p_AmbientForm = ambTemp
    End If
    
    ' here we must have p_AmbientForm ready for initialisation
    
    p_Tbh_C = p_AmbientForm.AmbTemp_С(Trajectory.Hperfvert_m)
    p_Twh_C = p_AmbientForm.AmbTemp_С(0)
    p_Tsurf_C = p_Twh_C
    p_Tres_C = Fluid.Tres_C
    
    ' инициализируем все элементы скважины для расчета по линейной зависимости от измеренной глубине
    ' это метод расчета по умолчанию
    ' все другие режимы расчета используют объект p_AmbientForm и не зависят от этой инициализации
    Dim TempGrad As Double
    Dim Tint_C As Double
    TempGrad = (p_Tbh_C - p_Twh_C) / Trajectory.Hperf_m
    p_Tintake_C = p_Tbh_C - TempGrad * p_Pipe_HspHvd.LengthMes_m
    
    p_Pipe_HspHvd.InitTlinear p_Tintake_C, p_Tbh_C
    p_Pipe_WHeadHsp_Tubing.InitTlinear p_Twh_C, p_Tintake_C
    p_Pipe_WHeadHsp_Casing.InitTlinear p_Twh_C, p_Tintake_C
    p_Pipe_WHeadHsp_Casing_Gas.InitTlinear p_Twh_C, p_Tintake_C
    
    ' зададим значения всех температур в ключевых точках в соответствии с исходными параметрами
    ' некоторые из этих параметров потом могут быть перевычисленны
    p_PTbuf.T_C = p_Twh_C
    p_PTlin.T_C = p_Twh_C
    p_PTcas.T_C = p_Twh_C
    p_PTwf.T_C = p_Tbh_C
    p_PTdis.T_C = p_Tintake_C
    p_PTintake.T_C = p_Tintake_C
    
    Exit Sub
err1:
    Dim errMsg As String
    errMsg = "CWellESP.InitWellTemperature: error in temperature init " & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
Private Sub FillWellConstructionSimple( _
                                Hperf_m As Double, _
                                Htub_m As Double, _
                                Udl_m As Double, _
                                dCas_mm As Double, _
                                dTub_mm As Double _
                                       )
' метод для инициализации скважины простыми числами
On Error GoTo err1:
   Dim errMsg As String
   
   Dim HabsCurve_m As New TInterpolation
   HabsCurve_m.AddPoint 0, 0
   HabsCurve_m.AddPoint Hperf_m, Hperf_m - Udl_m
   
   Dim DcasCurve_mm As New TInterpolation
   DcasCurve_mm.AddPoint 0, dCas_mm
   DcasCurve_mm.AddPoint Hperf_m, dCas_mm
   
   Dim DtubCurve_mm As New TInterpolation
   DtubCurve_mm.AddPoint 0, dTub_mm
   DtubCurve_mm.AddPoint Htub_m, dTub_mm
   
   Dim tr As New CTrajectory
   Call tr.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, Hperf_m, Htub_m)
   Set Trajectory = tr
   Call FillWellConstructionTr
   Exit Sub
err1:
   errMsg = "CWellESP.FillWellConstructionSimple: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errMsg)
   Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
 
Private Sub FillWellConstructionRange( _
                          ByVal Incl_Hmes_m_ As Range, _
                          ByVal Incl_Hvert_m_ As Range, _
                          ByVal Hperf_m As Double, _
                          ByVal Htub_m As Double, _
                          ByVal dCas_mm As Double, _
                          ByVal dTub_mm As Double _
                                      )
' метод для инициализации скважины данными инсклинометрии и числами для остальных параметров
On Error GoTo err1:
   Dim HabsCurve_m As New TInterpolation
   Dim DcasCurve_mm As New TInterpolation
   Dim DtubCurve_mm As New TInterpolation
   Dim geoGrad As New TInterpolation
   Dim ambTemp As New CAmbientFormation
   
   Dim tr As New CTrajectory
   Dim errMsg As String
   
   Call HabsCurve_m.LoadFromVertRange(Incl_Hmes_m_, Incl_Hvert_m_)
  
   DcasCurve_mm.AddPoint 0, dCas_mm
   DcasCurve_mm.AddPoint Hperf_m, dCas_mm
   
   DtubCurve_mm.AddPoint 0, dTub_mm
   DtubCurve_mm.AddPoint Htub_m, dTub_mm
   
   Call tr.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, Hperf_m, Htub_m)
   Set Trajectory = tr
   Call FillWellConstructionTr
   
   
   Exit Sub
err1:
   errMsg = "CWellESP.FillWellConstructionRange: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errMsg)
   Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
 
Private Sub FillWellConstructionRangeAll(ByVal Incl_Hmes_m_ As Range, _
                           ByVal Incl_Hvert_m_ As Range, _
                           ByVal hmes_dcas_m_ As Range, _
                           ByVal dcas_arr_mm_ As Range, _
                           ByVal hmes_dtub_m_ As Range, _
                           ByVal dtub_arr_mm_ As Range, _
                           ByVal Hperf_m As Double, _
                           ByVal Htub_m As Double)
' метод для инициализации скважины из диапазонов измнения ключевых параметров
On Error GoTo err1:
   Dim HabsCurve_m As New TInterpolation
   Dim DcasCurve_mm As New TInterpolation
   Dim DtubCurve_mm As New TInterpolation
   Dim geoGrad As New TInterpolation
   Dim ambTemp As New CAmbientFormation
  ' Dim Hperf_m As Double, Htub_m As Double
   Dim errMsg As String
   
   Call HabsCurve_m.LoadFromVertRange(Incl_Hmes_m_, Incl_Hvert_m_)
   Call DcasCurve_mm.LoadFromVertRange(hmes_dcas_m_, dcas_arr_mm_)
   Call DtubCurve_mm.LoadFromVertRange(hmes_dtub_m_, dtub_arr_mm_)
  
  ' Hperf_m = DcasCurve_mm.maxx
  ' Htub_m = DtubCurve_mm.maxx
   
   Call Trajectory.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, Hperf_m, Htub_m)
   Call FillWellConstructionTr
   
   Exit Sub
err1:
   errMsg = "CWellESP.FillWellConstructionRangeAll: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errMsg)
   Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
' ============================================================
' основные расчетные функции
' ============================================================
Public Function calc_Pintake_Pwf_atma( _
                             ByVal Pwf_atma As Double) As Double
' @brief расчет давления на приеме через забойное давление (снизу -> вверх)
' @param Pwf_atma - исходное забойное давление
On Error GoTo err1:
    
    ' 1. Начало расчета. Заданы забойное давление Pwf, температура на забое скважины Tbh
    p_PTwf.P_atma = Pwf_atma
    p_PTwf.T_C = Tbh_C
    ' 2. Рассчитывается давление на приеме насоса PIn и температура в потоке перед насосом TbIт
    ' p_Pipe_HspHvd - труба от забоя до приема, задаем расчет параметров снизу-вверх
    p_Pipe_HspHvd.Param = ParamCalcFromBottom(HFlowCorrelation, TempCorrelation)
    ' Расчитываем давление на приеме (Pwf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    p_PTintake = p_Pipe_HspHvd.Calc_dPipe(p_PTwf)
    calc_Pintake_Pwf_atma = p_PTintake.P_atma
    
    Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.calc_Pintake_Pwf_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
End Function
Public Function calc_Pwf_Pintake_atma( _
                             ByVal Pintake_atma As Double) As Double
' @brief расчет забойного давления через давление на приеме   (сверху -> вниз)
' @param Pwf_atma - исходное забойное давление
On Error GoTo err1:
    ' 1. Начало расчета. Задано давление на приеме Pintake_atma
    '    температуру на приеме явно задавать не надо - она определится из температурной модели
    '                                           сработают только простые температурные модели
    p_PTintake.P_atma = Pintake_atma
    p_Pipe_HspHvd.Param = ParamCalcFromTop(HFlowCorrelation, TempCorrelation)
    ' Расчитываем давление на приеме (Pwf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    p_PTintake = p_Pipe_HspHvd.Calc_dPipe(p_PTwf)
    calc_Pwf_Pintake_atma = p_PTintake.P_atma
    
    Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.calc_Pwf_Pintake_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
    
End Function
Public Function calc_Plin_Pwf_atma( _
                             ByVal Pwf_atma As Double, _
                    Optional ByVal saveCurve As CALC_RESULTS = noCurves _
                                  ) As Double
' @brief расчет давления на устье через забойное давление (снизу -> вверх)
' @param Pwf_atma - исходное забойное давление
' @@param saveCurve - показывает насколько детально надо сохранять результаты расчета
Dim Tintake_esp_C As Double
Dim p_PTcas_temp As PTtype
Dim p_PTintgas_temp As PTtype
Dim Tan_C As Double
Dim pcur As TInterpolation
    
On Error GoTo err1:
    ' 1. Начало расчета. Заданы забойное давление Pwf, температура на забое скважины Tbh
    p_PTwf.P_atma = Pwf_atma
    p_PTwf.T_C = Tbh_C
    ' 2. Рассчитывается давление на приеме насоса PIn и температура в потоке перед насосом TbIт
    ' p_Pipe_HspHvd - труба от забоя до приема, задаем расчет параметров снизу-вверх
    p_Pipe_HspHvd.Param = ParamCalcFromBottom(HFlowCorrelation, TempCorrelation)
    ' Расчитываем давление на приеме (Pwf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    p_PTintake = p_Pipe_HspHvd.Calc_dPipe(p_PTwf, saveCurve)
    ' еслт давление на приеме меньше 1 значит поток не доходит до насоса, значит надо поправить расчеты
    If p_PTintake.P_atma < 1 Then
'        p_Pipe_HspHvd.Param = ParamCalcFromTop(HFlowCorrelation, TempCorrelation)
'        p_PTintake.P_atma = 1
'        p_PTwf = p_Pipe_HspHvd.Calc_dPipe(p_PTintake, SaveCurve)              ' стрельнем назад и определим новое давление на приеме
        calc_Plin_Pwf_atma = 0
        Exit Function
    End If
    If IsESP() Then                                                 ' Если есть насос
        ' 3. Расчет изменения температуры в насосе
        ' сначала считаем сепарацию и модификацию флюидов
        Call ESP.calc_separation(p_PTintake.P_atma, p_PTintake.T_C)
        If isCalcESPtemp Then
'            ' расчитываются параметры насоса и температура
            Call ESP.calc_ESPsys(p_PTintake.P_atma, p_PTintake.T_C, -1, True)
        Else
            ' расчитываются параметры насоса при заданном распределении температур
            Call ESP.calc_ESPsys(p_PTintake.P_atma, p_PTintake.T_C, p_PTintake.T_C, True)
        End If
        p_PTdis = SetPT(ESP.ESPpump.Pdis_atma, ESP.ESPpump.Tdis_C)
        Set p_Pipe_WHeadHsp_Tubing.Fluid = ESP.FluidTub       ' учитываем что выше насоса пойдет модифицированный флюид
        Set p_Pipe_WHeadHsp_Casing.Fluid = ESP.FluidCas
        Set p_Pipe_WHeadHsp_Casing_Gas.Fluid = ESP.FluidCas
    Else                                                            ' Если насоса нет, то совпадают
        p_PTdis = p_PTintake
    End If
    ' calc casing (dynamic level) if data given
    If isCalcCasing And IsESP() And Pcas_atma >= 1 Then
        Call CasingCalc
    End If
    ' 7. Расчет распределения давления в НКТ и расчет буферного давления c учетом движения в НКТ нефти после сепарации PVTtub
    p_Pipe_WHeadHsp_Tubing.Param = ParamCalcFromBottom(HFlowCorrelation, TempCorrelation)
    p_PTbuf = p_Pipe_WHeadHsp_Tubing.Calc_dPipe(p_PTdis, saveCurve)   'Calc_Pipe_PIncl_atma(p_Pdis_atma, p_Tdis_C)
    
    ' 8. Расчет линейного давления по штуцеру
    On Error GoTo err_choke:
        If p_choke.Dchoke_m > 0 Then       ' пока отключено
            p_PTlin = Choke.Calc_Choke_Plin(p_PTbuf)
            If p_PTlin.P_atma <= 0 Then
                p_PTlin.P_atma = 0
            End If
        Else
            p_PTlin = p_PTbuf
        End If
b:
    On Error GoTo err1:
    ' Если при заданном затрубном давлении Pan существует отличный от нуля динамический уровень Hdyn
    ' то в качестве результатов расчетов сохраняются эти значения
    ' уже подсчитано
    calc_Plin_Pwf_atma = p_PTlin.P_atma
    
    Call SaveCurves(saveCurve)
    
    Exit Function
err_choke:
    addLogMsg "CWellESP.Calc_Plin_Pwf_atma: error in choke calculation. Pbuf = ", s(p_PTbuf.P_atma)
    Resume b:
        
    Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.calc_Plin_Pwf_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
End Function
 Public Function calc_Pwf_Plin_atma(ByVal Plin_atma As Double, _
                                    ByVal Tbh_C As Double, _
                                    Optional fast As Boolean = True, _
                                    Optional saveCurve As CALC_RESULTS = noCurves)
 ' функция расчета сверху вниз
 ' тут смотрим можно ли провести расчет быстро
 ' или надо вызывать медленный метод (итерациями снизу вверх)
    ' надо сделать приближение по расчету давления - чтобы сработала сепарация
    If Pint_atma = 0 Then p_PTintake = SetPT(50, Tbh_C)
    If fast And p_Param.tempMethod <> AmbientTemp Then
       calc_Pwf_Plin_atma = fast_Pwf_Plin_atma(Plin_atma, Tbh_C, saveCurve)
    Else
       calc_Pwf_Plin_atma = slow_Pwf_Plin_atma(Plin_atma, Tbh_C, saveCurve)
    End If
 
 End Function
 
 
Public Function calc_Well(ByVal Plin_atma As Double, _
                          ByVal Pbuf_atma As Double, _
                          ByVal Pwf_atma As Double, _
                          ByVal Pcas_atma As Double) As Boolean
'функция анализа работы скважины и определения ключевых параметров по скважине
'надо еще сюда добавить расчет забойного давления по динамическому уровню или давлению на приеме и получится замкнутый анализ скважины
'надо еще сюда добавить построение всех графиков по скважине
' после выполнения этой функции можно сказать что расчет по скважине проведен в полном объеме
   Dim i As Integer
   Dim PlinTemp_atma As Double
   Dim PbufTemp_atma As Double
   Dim ESPdegrDir As Double
   Dim PlinOld1 As Double, PlinOld2 As Double
   Dim foundDegr As Boolean
On Error GoTo err1:
   calc_Well = True    ' по умолчанию ждем что все будет хорошо
   ESP.cfHead_fr = 0   ' деградация УЭЦН = 0
   ' расчет параетров калибровки штуцера
   '     - проводится если только данные для штуцера коррекно заданы
   '     - если линейное давление и оно меньше буферного
   If Plin_atma > 0 And Pbuf_atma > Plin_atma And Choke.Dchoke_m > 0 Then
       '  ищем распределение давления в скважине соответствующее текущим условиям
       Call Choke.Calc_Choke_Calibration(Pbuf_atma, Plin_atma, Qliq_scm3day)
       ' определили поправочный коэффициент для штуцера
   End If
   isCalcCasing = False
   PlinTemp_atma = calc_Plin_Pwf_atma(Pwf_atma)
   ' получаем на выходе коэффициент сепарации и параметры флюида на участке выше насоса
   If isEqual(p_PTdis.P_atma, p_PTintake.P_atma) Then ' значит насос не развивает перепад давления и подобрать коэффициент деградации не удасться
       calc_Well = False     ' расчет провести не удалось
       ESP.cfHead_fr = 0   ' возвращаем насос в исходное состояние
       Exit Function
   End If
   ESP.cfHead_fr = FindDegradation(1 - ESP.cfHead_fr, PlinTemp_atma, Plin_atma, Pwf_atma, Tbh_C)
   ' перерасчитываем распределения давления в скважине с учетом деградации
   isCalcCasing = True
   PlinTemp_atma = calc_Plin_Pwf_atma(Pwf_atma)
   ' после этого расчета определили все параметры по скважине которые нас могут интересовать
   Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.calc_Well: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
 
End Function
' =============================================================================
' specific properties and functions
' =============================================================================
'------------------------------------------------------------
' ESP  properties
'------------------------------------------------------------
Public Sub Set_ESPwell_data(Optional Pint_atma As Double = -1, _
                            Optional Hdyn_m As Double = -1, _
                            Optional Pdis_atma As Double = -1)
' sub set additional ESP well props needed for ESP full calc
    
End Sub
' доступ к насосу
Public Property Get ESP() As CESPsystemSimple
   Set ESP = p_ESP
End Property
Public Property Set ESP(val As CESPsystemSimple)
  Set p_ESP = val
  If val Is Nothing Then GoTo noESP:
  ' переводим в состояние "целостность нарушена"
'  p_Calculated = False
On Error GoTo noESP
  p_ESP_on = True
  Set p_ESP.Fluid = Fluid
  ' after ESP installation consruction must be reset to account ESP length
  Call FillWellConstructionTr
  Exit Property
noESP:
  p_ESP_on = False
  addLogMsg_debug "насос отключен"
End Property
 
 Public Property Get IsESP() As Boolean
    IsESP = p_ESP_on
 End Property
 
'------------------------------------------------------------
' ESP well specific properties
'------------------------------------------------------------
Public Property Get Pint_atma() As Double
' давление на приеме
   Pint_atma = p_PTintake.P_atma
End Property
Public Property Get Pdis_atma() As Double
 ' давление на приеме
   Pdis_atma = p_PTdis.P_atma
End Property
Public Property Get Tint_C() As Double
   Tint_C = p_PTintake.T_C
End Property
Public Property Get Tdis_C() As Double
   Tdis_C = p_PTdis.T_C
End Property
Public Property Get Hdyn_m() As Double
   Hdyn_m = p_Hd_m
End Property
 
Private Sub FillWellConstructionTr()
Dim ESPbottom_m As Double   ' ESP bottom - todo - move to main definition and account pressure drop along ESP
' инициализация скважины по данным траектории скважин
    
   Call p_Pipe_WHeadHsp_Tubing.InitPipeConstrTr(Trajectory, 0, Trajectory.Htubing_m)
   p_Hsp_m = Trajectory.Htubing_m ' определим глубину спуска установки
   If IsESP Then
       ESP.HmesTop_m = p_Hsp_m  ' установим глубину спуска оборудования
       ESPbottom_m = ESP.HmesBottom_m
   Else
       ESPbottom_m = p_Hsp_m
   End If
   Call p_Pipe_WHeadHsp_Casing.InitPipeConstrTr(Trajectory, 0, ESPbottom_m, pipeAnnulus)
   Call p_Pipe_WHeadHsp_Casing_Gas.InitPipeConstrTr(Trajectory, 0, ESPbottom_m, pipeAnnulus)
   Call p_Pipe_HspHvd.InitPipeConstrTr(Trajectory, ESPbottom_m, Trajectory.Hperf_m, pipeCasing)
   Choke.Dup_m = 0.06
   Choke.Ddown_m = 0.06
   Set p_Pipe_HspHvd.AmbientForm = p_AmbientForm
   Set p_Pipe_WHeadHsp_Casing.AmbientForm = p_AmbientForm
   Set p_Pipe_WHeadHsp_Casing_Gas.AmbientForm = p_AmbientForm
   Set p_Pipe_WHeadHsp_Tubing.AmbientForm = p_AmbientForm
End Sub
 
 
 
Private Function FindDegradation(ByVal kESP As Double, _
                                 ByVal Plin As Double, _
                                 Plin_targ As Double, _
                                 Pwf_atma As Double, _
                                 Tbh_C As Double)
' функция для поиска значения деградации УЭЦН
' получает в качестве аргументов первое приближение для поиска и целевое значение линейного давления
' kESP = 1 - degr  поправочный коэффициент на насос
   Dim kESP1 As Double ', degr2 As Double
   Dim Plin1 As Double ', Plin2 As Double
   Dim kESP_Up As Double   ' верхняя граница значения деградации
   Dim kESP_Down As Double ' нижняя граница значения деградации
   Dim Plin_Up As Double
   Dim Plin_Down As Double
   Dim found_solution As Double
   Dim i As Integer
   
On Error GoTo err1:
   i = 0
   If Plin > Plin_targ Then
       ' поправку на насос надо уменьшать
       kESP1 = 0
       Plin1 = 0
       kESP_Up = kESP
       Plin_Up = Plin
       kESP_Down = kESP1
       Plin_Down = -1 ' unknown flag
   Else
       ' поправку надо увеличивать
       kESP1 = 10    '
       Plin1 = 0
       kESP_Up = kESP1
       Plin_Up = -1 ' unknown flag
       kESP_Down = kESP
       Plin_Down = Plin
   End If
   Curve(str_PdisKdegr_curve).ClearPoints
   Do
       ESP.cfHead_fr = 1 - kESP1
       isCalcCasing = False
       Plin1 = calc_Plin_Pwf_atma(Pwf_atma)
       Curve(str_PdisKdegr_curve).AddPoint Plin1, 1 - kESP1
       ' посмотрим если вдруг нашли решение то запомним его и завершим расчет
       If (Abs(Plin1 - Plin_targ) < const_well_P_tolerance) Then
            found_solution = True
            FindDegradation = ESP.cfHead_fr
            Exit Function
       End If
       If Not found_solution Then
          If Plin1 > Plin_targ Then
               ' если новое лин давление больше целевого - значит нашли нижнюю границу деградации - искомое значение должно быть больше
              kESP_Up = kESP1
              Plin_Up = Plin1
              If (Plin_Down > 0) And (Plin_Down < Plin_targ) Then
                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (Plin_targ - Plin_Down) / (Plin_Up - Plin_Down) '
              Else
                  kESP1 = kESP1 - 1
              End If
          Else
              kESP_Down = kESP1
              Plin_Down = Plin1
              If (Plin_Up > 0) And (Plin_Up > Plin_targ) Then
                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (Plin_targ - Plin_Down) / (Plin_Up - Plin_Down) '
              Else
                  kESP1 = kESP1 + 1
              End If
          End If
        End If
       i = i + 1
   Loop While Not found_solution And i < 20
   
   Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.FindDegradation: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
End Function
 
Private Sub CasingCalc()
'  расчет параметров затрубного простраства скважины
'  должно быть задано давление на приеме - от которого проводится расчет снизу вверх
'                     и затрубное давление - от которого проводится расчет сверзу вниз
'  результат расчет - распределение давление и значение динамического уровня
    Dim p_PTcas_temp As PTtype
    Dim p_PTintgas_temp As PTtype
    Dim cas_crv As TInterpolation
    Dim num_Hd As Integer
    
On Error GoTo err_casing:
        ' 1. Расчет расхода свободного газа двигающегося через затрубное пространство после сепарации
        ' для затруба считаем снизу вверх
        p_Pipe_WHeadHsp_Casing.Param = ParamCalcFromBottom(HFlowCorrelation, TempCorrelation)
        p_PTcas_temp = p_Pipe_WHeadHsp_Casing.Calc_dPipeZNLF(p_PTintake, mainCurves)
        ' 2. для затруба считаем распределение давления в газовом столбе сверху вниз
        p_Pipe_WHeadHsp_Casing_Gas.Param = ParamCalcFromTop(Gas, GeoGradTemp)
        p_PTintgas_temp = p_Pipe_WHeadHsp_Casing_Gas.Calc_dPipe(p_PTcas, mainCurves)
        ' 3. найдем пересечение  распределений газа и жидкости в затрубе по давлению
        Set cas_crv = SubtractCurve(p_Pipe_WHeadHsp_Casing.PCurve, p_Pipe_WHeadHsp_Casing_Gas.PCurve)
        num_Hd = cas_crv.FindSolutions(0, TS_NO_EXTRPOLATION)  ' ищем количество пересечений
        ' 4. если пересечение одно, то все в порядке - это Ндин если значение хорошее
        If num_Hd = 1 Then
            p_Hd_m = cas_crv.SolutionPointX(1)
            ' проверяем, чтобы значение динамического уровня было разумным, иначе фиксируем крайние значения
            If p_Hd_m < 0 Then p_Hd_m = 0
            If p_Hd_m >= p_Hsp_m Then p_Hd_m = p_Hsp_m
            ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
            Set Curve("Pcas_Hd") = p_Pipe_WHeadHsp_Casing.PCurve.CutByCurve(p_Pipe_WHeadHsp_Casing_Gas.PCurve)
        ElseIf num_Hd = 0 Then
        ' 5. если пересечение найти не удалось - то фиксируем крайние значения
            If p_PTcas.P_atma >= p_PTintake.P_atma Then
                p_Hd_m = p_Hsp_m
            Else
                p_Hd_m = 0
            End If
        Else
        '6. если пересечений не одно, то пытаемся применить устаревший алгоритм без учета плотности газа
            addLogMsg_debug "CWellESP.Calc_Plin_Pwf_atma: abnormal casing behavior. Num of intersections =", num_Hd
            ' Если заданному затрубному давлению Pan соответствует отрицательный динамический уровень Hdyn,
            ' тогда ищется затрубное давление P(Hdyn=0)an соответствующее Hdyn=0 и данные значения сохраняются как результат
            If (p_PTcas.P_atma = 0 Or p_PTcas.P_atma >= p_PTintake.P_atma) Then
                'p_Pan_atma = p_pipe_WHeadHsp_Casing.PCurve.GetPoint(0)
                p_Hd_m = p_Hsp_m
                p_PTcas.P_atma = p_PTintake.P_atma
            Else
                With p_Pipe_WHeadHsp_Casing.PCurve
                        p_Hd_m = .FindMinOneSolution(p_PTcas.P_atma)
                End With
            End If
    
            If (p_Hd_m < 0) Then
                p_Hd_m = 0
                p_PTcas.P_atma = p_Pipe_WHeadHsp_Casing.PCurve.GetPoint(0)
            End If
    
            ' Если заданному затрубному давлению Pan соответствует динамический уровень Hdyn больше глубины спуска насоса Hpump, _
            ' тогда ищется затрубное давление P(Hdyn=Hpump)an соответствующее Hdyn=Hpump и данные значения сохраняются как результат
            If is_Hdyn_Larger_Hsp Then
                p_Hd_m = p_Hsp_m
                p_PTcas.P_atma = p_Pipe_WHeadHsp_Casing.PCurve.GetPoint(p_Hsp_m)
            End If
            Set Curve("Pcas_Hd") = p_Pipe_WHeadHsp_Casing.PCurve.CutByValue(p_Hd_m)
        End If
        '7. сохраним параметры для расчета распределения давления
        p_AmbientForm.Hdyn_m = p_Hd_m
        p_AmbientForm.Hpump_m = p_Hsp_m
        p_Pipe_WHeadHsp_Tubing.AddHmes_insert_m (p_Hd_m)
    Exit Sub
    
err_casing:
    ' стандартная схема обработки ошибок
    Dim err_str As String
    err_str = "CWellESP.CasingCalc: error in casing calculation. Pcas = " & s(p_PTcas.P_atma) & sDELIM & Err.Description
    addLogMsg err_str
    RaiseEvent ReportProgress(err_str)
    Err.Raise Err.Number, Err.Source, err_str
 End Sub
 
 Private Sub SaveCurves(saveCurve As CALC_RESULTS)
 On Error GoTo err1:
    If saveCurve > 0 Then
        Call Curve(str_PtubHmes_curve).AddPointsCurve(p_Pipe_WHeadHsp_Tubing.PCurve, p_Pipe_HspHvd.PCurve)
        Curve(str_PtubHmes_curve).xName = "hmes ptub"
        Curve(str_PtubHmes_curve).yName = "Ptub"
        Call Curve(str_TtubHmes_curve).AddPointsCurve(p_Pipe_WHeadHsp_Tubing.Curves(str_Tcurve), p_Pipe_HspHvd.Curves(str_Tcurve))
        Curve(str_TtubHmes_curve).yName = "Ttub"
        Call Curve(str_TambHmes_curve).AddPointsCurve(p_Pipe_WHeadHsp_Tubing.Curves("c_Tamb"), p_Pipe_HspHvd.Curves("c_Tamb"))
        Curve(str_TambHmes_curve).yName = "Tamb"
        Call Curve(str_PcasHmes_curve).AddPointsCurve(Curve("Pcas_Hd"))
        Curve(str_PcasHmes_curve).xName = "hmes pcas"
    
        If saveCurve > 1 Then
            Call Curve(str_HlHmes_curve).AddPointsCurve(p_Pipe_WHeadHsp_Tubing.Curves("c_Hl"), p_Pipe_HspHvd.Curves("c_Hl"))
            Curve(str_HlHmes_curve).yName = "Hl"
        End If
    End If
    
     Exit Sub
err1:
    Dim errMsg As String
    errMsg = "CWellESP.SaveCurves: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
  
 End Sub
 
 
 Private Function fast_Pwf_Plin_atma( _
                         Plin_atma As Double, _
                         ByVal Tbh_C As Double, _
                Optional saveCurve As CALC_RESULTS = noCurves _
                                    )
'@brief  быстрый метод расчета забойного давления через линейное (без итераций - прямой счет)
'         считает за один проход, за счет дополнительных упрощений и предположений
'@param Plin_atma  линейное давление
'@param Tbh_C      температура на забое
'@param saveCurve  флаг показывает - что сохранять в качестве результатов
'       для уточнения оценки сепарации флюида желательно задать
'       оценочные значения давления и температуры на приеме УЭЦН Pint_atma Tint_C для объекта расчета
'       расчет температуры по заданной извне температурной корреляции, которая должны быть простой
On Error GoTo err1:
    If TempCorrelation = AmbientTemp Then
        TempCorrelation = GeoGradTemp
    End If
    ' 1. если есть ЭЦН пытаемся оценить сепарацию и модификацию флюида на основе предполагаемого давления на приеме насоса
    If IsESP Then
        Call ESP.calc_separation(Pint_atma, Tint_C)
        Set p_Pipe_WHeadHsp_Tubing.Fluid = ESP.FluidTub
        If isChoke() Then Set Choke.Fluid = ESP.FluidTub
    End If
    
    ' 2. фиксируем заданные линейные давления
    p_PTlin.P_atma = Plin_atma
    p_PTlin.T_C = Twh_C
    
    ' 3. Расчет буферного давления по штуцеру
    If isChoke() Then
        p_PTbuf = Choke.Calc_Choke_Pbuf(p_PTlin)
        If p_PTbuf.P_atma < 0 Then p_PTbuf.P_atma = 1
    Else
        p_PTbuf = p_PTlin
    End If
    
    ' 4. Расчет давления на выкиде по буферному
    p_Pipe_WHeadHsp_Tubing.Param = ParamCalcFromTop(HFlowCorrelation, TempCorrelation)
    p_PTdis = p_Pipe_WHeadHsp_Tubing.Calc_dPipe(p_PTbuf, saveCurve)
    
    ' 5. если есть ЭЦН то считаем давление на приеме по давлению на выкиде сверху вниз
    If IsESP() Then                                                 ' Если есть насос
        ' расчитываются параметры насоса включая сепарацию и модификацию флюидов
        Call ESP.calc_ESPsys(p_PTdis.P_atma, p_PTdis.T_C, p_PTdis.T_C, CalcFromIntake:=False)
        p_PTintake = SetPT(ESP.ESPpump.Pint_atma, ESP.ESPpump.Tint_C)
    Else                                                            ' Если насоса нет, то совпадают
        p_PTintake = p_PTdis
    End If
    ' 6. По давлению на приеме считаем забойное давление
    p_Pipe_HspHvd.Param = ParamCalcFromTop(HFlowCorrelation, TempCorrelation)
    p_PTwf = p_Pipe_HspHvd.Calc_dPipe(p_PTintake, saveCurve)
    fast_Pwf_Plin_atma = p_PTwf.P_atma
    ' 7. если надо считаем затруб
    Dim p_PTcas_temp As PTtype
    If isCalcCasing And Pcas_atma >= 1 Then
        Call CasingCalc
    End If
    
    Call SaveCurves(saveCurve)
     
    Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.fast_Pwf_Plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
End Function
Private Function slow_Pwf_Plin_atma(ByVal Plin_atma As Double, _
                                        ByVal Tbh_C As Double, _
                                        Optional saveCurve As CALC_RESULTS = noCurves)
' @brief Calc_Pwf_Plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
' @param Plin_atma - давление в линии
' @param Hd - динамический уровень
' @param Tbh_C - температура на забое скважины
' @return Подсчитанное для заданного линейного давление
On Error GoTo err1:
    Dim Pwf1 As Double      ' первое приближение
    Dim PwfUp As Double, PwfDown As Double
    Dim PlinUp As Double, PlinDown As Double
    Dim Plin0 As Double, Plin1 As Double
    Dim found_solution As Boolean
    Dim i As Integer
    found_solution = False
    i = 0
    Pwf1 = 60
    PwfUp = -1
    PwfDown = -1
    Do
        ' ищем  приближения
        Plin1 = calc_Plin_Pwf_atma(Pwf1, saveCurve:=noCurves)
        If (Abs(Plin1 - Plin_atma) < const_well_P_tolerance) Then
             found_solution = True
             p_PTwf.P_atma = Pwf1
             p_PTwf.T_C = Tbh_C
        End If
        If Not found_solution Then
          If Plin1 > Plin_atma Then
              PwfUp = Pwf1
              PlinUp = Plin1
              If PwfDown < 0 Then
                  Pwf1 = PwfUp / 2
              Else
                  Pwf1 = PwfDown + (PwfUp - PwfDown) * (Plin_atma - PlinDown) / (PlinUp - PlinDown)
              End If
          Else
              PwfDown = Pwf1
              PlinDown = Plin1
              If PwfUp < 0 Then
                  Pwf1 = Pwf1 * 2
              Else
                  Pwf1 = (PwfUp + PwfDown) / 2
                '  Pwf1 = PwfDown + (PwfUp - PwfDown) * (Plin_atma - PlinDown) / (PlinUp - PlinDown)
              End If
          End If
        End If
        i = i + 1
    Loop While Not found_solution And i < 20
    ' calc more one time to restore all what needed
    p_PTlin.P_atma = calc_Plin_Pwf_atma(p_PTwf.P_atma, saveCurve:=saveCurve)
    If Abs(Me.Pline_atma - Plin_atma) > const_well_P_tolerance Then
       addLogMsg "Calc_Pwf_Plin_atma: ошибка расчета забойного давления больше " & const_well_P_tolerance & ". Равна = " & Abs(Me.Pline_atma - Plin_atma)
    End If
    slow_Pwf_Plin_atma = p_PTwf.P_atma
    Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.Slow_Pwf_Plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
 End Function
 
Public Function calc_Pwf_PanHd_atma(ByVal Pan_atma As Double, ByVal Hd_m As Double, ByVal Tbh_C As Double) As PTtype
' @brief Calc_Pwf_PanHd_atma - расчет забойного давления через динамический уровень
' @param Pan - затрубное давление
' @param Hd - динамический уровень
' @param Tbh_C - температура на забое скважины
' @return Подсчитанное для заданного динамического уровня давление
On Error GoTo err1:
    Set Curve(str_Hd_Depend_Pwf) = Build_HdPwfcurve(Pan_atma, Tbh_C)
    ' 3. По построенной кривой находим значение забойного давления соответствующее заданному динамическому уровню
    p_PTwf.P_atma = Curve(str_Hd_Depend_Pwf).FindMinOneSolution(Hd_m)
    ' 4. Для обеспечение целостности данных по скважине проводим расчет распределения давления по скважине для найденного забойного давления
    ' расчет давления на устье через забойное давление
    Call calc_Plin_Pwf_atma(p_PTwf.P_atma)
    p_PTcas.P_atma = Pan_atma
   ' Me.Hdyn_m = Hd_m
    calc_Pwf_PanHd_atma = p_PTwf
    Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.Slow_Pwf_Plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
End Function
Private Function is_Hdyn_Larger_Hsp() As Boolean
' Динамический уровень Hdyn больше глубины спуска насоса Hpump,
    is_Hdyn_Larger_Hsp = IsESP() And p_Hd_m > p_Hsp_m
End Function
        
'Public Function Calc_PinGasFrac_simple_atma(GasFrac_d As Double, T_C As Double, Optional Ksepar As Double = 0)
''  расчет давления на приеме обеспечивающего заданную долю газа при определенное температуре
'
'Dim PinMin As Double, PInMax As Double  ' оценки снизу и сверху для доли газа
'Dim eps As Double
'Dim Pcalc As Double
'Dim i As Integer
'Dim gasfr As Double
'
'i = 0
'eps = 0.1 '  погрешность расчета
'
'If Ksepar < 0 Then Ksepar = 0
'If Ksepar > 1 Then Ksepar = 1
'
'
'PinMin = 1
'If GasFraction_d(PinMin, T_C, Fluid, Ksep:=Ksepar) < GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac больше единицы задан, должно в расчете быть 1
'    Calc_PinGasFrac_simple_atma = 0
'  '  Debug.Assert False
'    Exit Function
'End If
'
'PInMax = Fluid.Calc_Pb_atma(Fluid.rsb_m3m3, T_C)
'If GasFraction_d(PInMax, T_C, Fluid, Ksep:=Ksepar) > GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac менее нуля задан - должно в расчете быть ноль
'    Calc_PinGasFrac_simple_atma = PInMax
'  ' Debug.Assert False
'    Exit Function
'End If
'
'
'Do
'    i = i + 1   ' предохранитель от сваливания в бесконечный цикл
'    Pcalc = (PinMin + PInMax) / 2
'    gasfr = GasFraction_d(Pcalc, T_C, Fluid, Ksep:=Ksepar)
'    If GasFrac_d < gasfr Then
'        PinMin = Pcalc
'    Else
'        PInMax = Pcalc
'    End If
'
'Loop Until (Abs(PinMin - PInMax) < eps) Or (i > 100)
'Calc_PinGasFrac_simple_atma = Pcalc
'
'End Function
'Public Function Calc_PwfGasFrac_atma(GasFrac_d As Double, Tbh_C As Double)
''  расчет давления на приеме обеспечивающего заданную долю газа при определенное температуре
'
'Dim PwfMin As Double, PwfMax As Double  ' оценки снизу и сверху для доли газа
'Dim PinMin As Double, PInMax As Double
'Dim eps As Double
'Dim Pcalc As Double
'Dim i As Integer
'Dim gasfr As Double
'
'i = 0
'eps = 0.1 '  погрешность расчета
'
'
'
'PinMin = 1
'PwfMin = Calc_Pwf_PIn_atma(PinMin, Tbh_C)
'
'Call Calc_Plin_Pwf_atma(SetPT(PwfMin, Tbh_C), CalcCasing:=False)
'
'If GasFraction_PumpIntake_d < GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac больше единицы задан, должно в расчете быть 1
'    Calc_PwfGasFrac_atma = 0
'  '  Debug.Assert False
'    Exit Function
'End If
'
'PInMax = Fluid.Calc_Pb_atma(Fluid.rsb_m3m3, Tbh_C)
'PwfMax = Calc_Pwf_PIn_atma(PInMax, Tbh_C)
'
'Call Calc_Plin_Pwf_atma(SetPT(PwfMax, Tbh_C), CalcCasing:=False)
'
'If GasFraction_PumpIntake_d > GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac менее нуля задан - должно в расчете быть ноль
'    Calc_PwfGasFrac_atma = PInMax
'  ' Debug.Assert False
'    Exit Function
'End If
'
'
'Do
'    i = i + 1   ' предохранитель от сваливания в бесконечный цикл
'    Pcalc = (PinMin + PInMax) / 2
'
'    Call Calc_Plin_Pwf_atma(SetPT(Pcalc, Tbh_C), CalcCasing:=False)
'    gasfr = GasFraction_PumpIntake_d
'    If GasFrac_d < gasfr Then
'        PinMin = Pcalc
'    Else
'        PInMax = Pcalc
'    End If
'
'Loop Until (Abs(PinMin - PInMax) < eps) Or (i > 100)
'Calc_PwfGasFrac_atma = Pcalc
'
'End Function
Public Function Build_PwhPwfcurve( _
                Optional ByVal PlinMax As Double = -1, _
                Optional ByVal Pwf1_atma As Double = -1, _
                Optional ByVal Pstep As Integer = DEFAULT_PAN_STEP, _
                Optional ByVal calcFast As Boolean = False _
                                 ) As TInterpolation
' @brief Build_PwhPwfcurve построение кривой зависимости буферного и линейного давлений на скважине от забойного давления
'               на кривой есть две особые точки, на которых теряется гладкость
'                   1 - там где буферное давление становится больше нуля (граница работы скважины по забойному)
'                   2 - там где линейное давление становится больше нуля
'               эти точки ищутся более точным алгоритмом для правильной отрисовки графика
' @param PlinMax - ограничение величины линейного давления определяющее границы построения кривой
' @param Pwf1_atma - значение забойного давления, которое останется после проведения расчета
' @param Pstep  - шаг поиска значений
' @param calcFast - флаг показывающий насколько точно надо строить кривую (влияет на поиск пересечений с нулем)
    Dim Pwf_temp As Double
    Dim P_step As Double
    Dim processing As Boolean
    Dim Pwf_temp1 As Double ' забойное давление минимальное с которого надо начинать поиск
    Dim Pwf_temp_old As Double
    Dim Pwf_temp_new As Double
    
    Dim iter  As Integer
    
    Dim Pwfmin_atma As Double   ' временная переменная для хранения минимального забойного давления с которого надо начинать поиск зайбоного давления
On Error GoTo err1:
    Pwfmin_atma = 1
    
    If (PlinMax < 0) And (Pline_atma > 0) Then
        PlinMax = Pline_atma
    End If
    
    If Pwf1_atma < 0 Then
        Pwf1_atma = Pwf_atma
    End If
   
    ' 1. Начало расчета. Заданы линейное давление Pline,
    '    Температура на забое скважины Tbh определяется температурной моделью
    P_step = Pstep
    ' 2. Строим графическую зависимость линейного давления от забойного давления для заданных параметров скважины
    Curve(str_Plin_Depend_Pwf).ClearPoints
    Curve(str_Pbuf_Pwf_curve).ClearPoints
    processing = True
    isCalcCasing = False
    
    Pwf_temp = Pwfmin_atma     ' здесь надо получше выбирать начальное приближения для расчета для ускорения
    Do
        Pwf_temp = Pwf_temp + P_step
        
        p_PTlin.P_atma = calc_Plin_Pwf_atma(Pwf_temp)
        
        If (Pbuf_atma > const_minPpipe_atma) Then    ' вышли в область больших буферных давлений
            If Curve(str_Pbuf_Pwf_curve).numPoints = 0 Then  ' первый раз тут - ищем поточнее начало
                Curve(str_Pbuf_Pwf_curve).AddPoint Pwf_temp, Pbuf_atma
                
                Pwf_temp_old = Pwf_temp - P_step
                Pwf_temp_new = Pwf_temp
                iter = 1
                ' надо точнее искать точку если нет противопоказаний
                While (Pbuf_atma > const_minPpipe_atma * 1.1) And processing And Not calcFast
                    Pwf_temp = (Pwf_temp_old + Pwf_temp_new) / 2
                    p_PTlin.P_atma = calc_Plin_Pwf_atma(Pwf_temp)
                    If Pbuf_atma > const_minPpipe_atma Then
                        Pwf_temp_new = Pwf_temp
                    Else
                        Pwf_temp_old = Pwf_temp
                    End If
                    iter = iter + 1
                    If iter > 10 Then processing = False
                Wend
                If processing = False Then
                     p_PTlin.P_atma = 0
                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
                     addLogMsg "Build_PwhPwfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости ,буферного давления от забойного. Pwf = " _
                                                    & Pwf_temp & " итераций = " & iter & " дебит = " & Qliq_scm3day & " Рбуф = " & Pbuf_atma
                End If
                Curve(str_Pbuf_Pwf_curve).AddPoint Pwf_temp, Pbuf_atma
                Curve(str_Plin_Depend_Pwf).AddPoint Pwf_temp, Pline_atma
            End If
            Pstep = DEFAULT_PAN_STEP / 3
        Else
            Pwfmin_atma = Pwf_temp
        End If
        
        
        
        If (Pline_atma > -1) And (Not isEqual(Pline_atma, Pbuf_atma)) Then      ' вышли в область больших линейных давлений
            
            If Curve(str_Plin_Depend_Pwf).numPoints = 0 Then   ' первый раз тут - ищем поточнее начало
                Pwf_temp_old = Pwf_temp - P_step
                Pwf_temp_new = Pwf_temp
                iter = 1
                While (Pline_atma <> 0) And processing And Not calcFast  ' Then   ' надо точнее искать точку
                    Pwf_temp = (Pwf_temp_old + Pwf_temp_new) / 2
                    isCalcCasing = False
                    p_PTlin.P_atma = calc_Plin_Pwf_atma(Pwf_temp)
                    If Pline_atma > 0 Then
                        Pwf_temp_new = Pwf_temp
                    Else
                        Pwf_temp_old = Pwf_temp
                    End If
                    iter = iter + 1
                    If iter > 20 Then processing = False
                    If (Pline_atma >= 0) Then                          ' если ставить точки слишком часто - тогда проявляются неустойчивости - может надо будет сделать прореживание
                        Curve(str_Plin_Depend_Pwf).AddPoint Pwf_temp, Pline_atma
                        Curve(str_Pbuf_Pwf_curve).AddPoint Pwf_temp, Pbuf_atma
                    End If
                Wend
                If Pline_atma <> 0 Then
                     p_PTlin.P_atma = 0
                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
                     addLogMsg "Build_PwhPwfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости линейного давления от забойного. Pwf = " _
                                                    & Pwf_temp & " итераций = " & iter & " дебит = " & Qliq_scm3day & " Рбуф = " & Pbuf_atma
                End If
              
                Curve(str_Plin_Depend_Pwf).AddPoint Pwf_temp, Pline_atma
                Curve(str_Pbuf_Pwf_curve).AddPoint Pwf_temp, Pbuf_atma
            
            End If
            
        Else
            If isEqual(Pline_atma, Pbuf_atma) And (Pline_atma > 1) Then
                Curve(str_Plin_Depend_Pwf).AddPoint Pwf_temp, Pline_atma
                Curve(str_Pbuf_Pwf_curve).AddPoint Pwf_temp, Pbuf_atma
            End If
        End If
        If Pline_atma > 1 Then
           Curve(str_Plin_Depend_Pwf).AddPoint Pwf_temp, Pline_atma
           Curve(str_Pbuf_Pwf_curve).AddPoint Pwf_temp, Pbuf_atma
        End If
        ' ждем пока кривая перечеркнет уровень целевого линейного давления
    Loop While (Pline_atma < PlinMax + 10) Or (Curve(str_Plin_Depend_Pwf).numPoints < MinCountPoints_Calc_Pwf_PanHd_atma)
    isCalcCasing = True
    p_PTlin.P_atma = calc_Plin_Pwf_atma(Pwf1_atma)
    Set Build_PwhPwfcurve = Curve(str_Plin_Depend_Pwf)
    Exit Function
err1:
    Dim errMsg As String
    errMsg = "CWellESP.Build_PwhPwfcurve: ошибка" & sDELIM & Err.Description
    addLogMsg errMsg
    RaiseEvent ReportProgress(errMsg)
    Err.Raise kErrInitCalc, Err.Source, errMsg
End Function
Public Function Build_HdPwfcurve(Pan_atma As Double, Tbh_C As Double, Optional Pwf1_atma As Double = -1) As TInterpolation
' расчет зависимости динамического уровня от забойного давления для заданных условий
' @brief Build_HdPwfcurve - расчет забойного давления через динамический уровень
' @param Pan - затрубное давление
' @param Tbh_C - температура на забое скважины
' @return Подсчитанное для заданного динамического уровня давление
    
  On Error GoTo er1:
  
    Dim Pwf_temp As Double
    Dim Plin_temp As Double
    Dim P_step As Double
    Dim processing As Boolean
    Dim HdAtIntake As Boolean, Panold As Double
    Dim Pwfold As Double, Pwfold1 As Double
    Dim Hdold As Double
    Dim itr As Integer, itr2 As Integer, itr3 As Integer
    Dim Hdpump As Double
    
    If Pan_atma <= 0 Then
        addLogMsg "CWellESP.Build_HdPwfcurve: попытка построить график динамического уровня от забойного давления при затрубном давлении =" & Pan_atma
        Exit Function
    End If
    
    ' 1. Начало расчета. Заданы затрубное давление Pan, динамический уровень Hdyn, температура на забое скважины Tbh
  '  Pan_atma = Pan_atma
  '  p_Tbh_C = Tbh_C
    P_step = DEFAULT_PAN_STEP '/ 3
    ' 2. Строим графическую зависимость динамического уровня от забойного давления для заданных параметров скважины
    Curve(str_Hd_Depend_Pwf).ClearPoints
    processing = True
    
    If Pwf1_atma < 0 Then
        Pwf1_atma = Pwf_atma
    End If
    
    HdAtIntake = False
    itr3 = 0
    Do
       Pwf_temp = Pan_atma
       itr2 = 0
       Do
            p_PTcas.P_atma = Pan_atma
            isCalcCasing = True
            Plin_temp = calc_Plin_Pwf_atma(Pwf_temp)
            
            If Me.Pan_atma < Pan_atma Then
            ' уровень на приеме - надо найти точно точку начала слома
                HdAtIntake = True
                Panold = Me.Pan_atma
                Pwfold = Pwf_temp
                Hdold = p_Hd_m
                Hdpump = p_Hd_m
            Else
            ' вышли в зону где уровень выше приема насоса
                If HdAtIntake And Abs(Hdold - p_Hd_m) > 10 Then
                    ' погрешность около точки слома по дин уровню больше 10 метров - надо уточнить лучше
                    Pwfold1 = Pwf_temp
                    itr = 0
                    Do
                        itr = itr + 1
                        Pwf_temp = (Pwfold1 + Pwfold) / 2
                        p_PTcas.P_atma = Pan_atma
                        isCalcCasing = True
                        Plin_temp = calc_Plin_Pwf_atma(Pwf_temp)
                        If p_Hd_m = Hdpump Then
                            HdAtIntake = True
                            Panold = Me.Pan_atma
                            Pwfold = Pwf_temp
                            Hdold = p_Hd_m
                        Else
                            Pwfold1 = Pwf_temp
                        End If
                    Loop While ((Abs(Hdpump - p_Hd_m) > 10) Or Abs(Pan_atma - Me.Pan_atma) > 2) And itr < 10 '
                End If
'                Debug.Assert itr < 10
                itr = 0
                HdAtIntake = False ' сбросим флаг, что нашли точку слома
            End If
            
            Curve(str_Hd_Depend_Pwf).AddPoint Pwf_temp, p_Hd_m
            Curve(str_Pan_Depend_Pwf).AddPoint Pwf_temp, Pan_atma
           
            Pwf_temp = Pwf_temp + P_step
            
'            Debug.Assert Pwf_temp < 300
            itr2 = itr2 + 1
        Loop While (Not is_Hdyn_Larger_Hsp And p_Hd_m > 0) And (itr2 < 100)
        
        ' проверка условий продолжения цикла
        If (Curve(str_Hd_Depend_Pwf).numPoints >= MinCountPoints_Calc_Pwf_PanHd_atma) Then
            processing = False
        Else
            Curve(str_Hd_Depend_Pwf).ClearPoints
            P_step = P_step / 2
            
            ' проверка корректности. Если шаг слишком мелкий при этом точек решения мало - то это не здоровая ситуация - надо показать ее
            If P_step < 0.01 Then
                addLogMsg "CWellESP.Build_HdPwfcurve: Не удалось построить кривую зависимости динамического уровня от забойного давления. шаг перебора точек менее 0.01 атм"
                Err.Raise kErrBuildCurve, , "CWellESP.Build_HdPwfcurve нет получается построить кривую - мелкий шаг получился"
            End If
        
        End If
        itr3 = itr3 + 1
    Loop While (processing) And (itr3 < 5)
        
    'восстановим после расчета необходимое распределение в скважине
    p_PTcas.P_atma = Pan_atma
    isCalcCasing = True
    Plin_temp = calc_Plin_Pwf_atma(Pwf1_atma)
    
    Set Build_HdPwfcurve = Curve(str_Hd_Depend_Pwf)
   ' переводим в состояние "целостность нарушена"
  '  p_Calculated = False
    
    Exit Function
er1:
  ' Debug.Assert False
   Resume Next
End Function
Public Function Build_VLPcurve(Pline As Double, ByVal Tbh_C As Double, Optional maxQ As Double = 200, Optional Qnow As Double = -1) As TInterpolation
' расчет кривой лифта
' на выходе с расчета кривая лифта заданная в определенном формате кривой
'
    
    p_PTlin.P_atma = Pline
    Const VLPNumPoints = 20
    Dim i As Integer
    Dim Qstep As Double
    Dim Pwf As Double
    Dim Qliq_reserv As Double
    Qliq_reserv = Qliq_scm3day
    Qstep = maxQ / VLPNumPoints
    
    
    RaiseEvent ReportProgress("Build_VLPcurve. Начинаем строить кривую оттока. Точек =   " & VLPNumPoints)
    For i = 0 To VLPNumPoints
        Qliq_scm3day = i * Qstep
        Pwf = calc_Pwf_Plin_atma(Pline, Tbh_C)
        Curve(str_VLPcurve).AddPoint Qliq_scm3day, Pwf
        ' поднимем наверх событие по поводу длительного расчета
        RaiseEvent ReportProgress("Build_VLPcurve   i= " & i & " из " & VLPNumPoints)
    Next i
    ' вернем состояние скважины в исходное значение
    If Qnow = -1 Then
        Qnow = maxQ * 1.1
    End If
    
    Qliq_scm3day = Qnow
    Pwf = calc_Pwf_Plin_atma(Pline, Tbh_C)
    Curve(str_VLPcurve).AddPoint Qliq_scm3day, Pwf
    Set Build_VLPcurve = Curve(str_VLPcurve)
End Function
'Public Property Get PtubHmes_curve() As TInterpolation
' Set PtubHmes_curve = Curve(str_PtubHmes_curve)
'End Property
Property Get VLPCurve() As TInterpolation
  Set VLPCurve = Curve(str_VLPcurve)
End Property
Private Sub fillCurvesPT()
' формирование массивов свойств потока вдоль ствола скважины (давление температура и прочее)
Dim i As Integer
Dim pumpLenCorr As Double
Dim Hmes_m As Double   ' текущая глубина
Dim StableFlag As Boolean
StableFlag = False
' соберем точки по НКТ
If p_Pipe_WHeadHsp_Tubing.LengthMes_m > 0 Then
    For i = 1 To p_Pipe_WHeadHsp_Tubing.PCurve.numPoints
        
        If i = 1 Or i = p_Pipe_WHeadHsp_Tubing.PCurve.numPoints Then
            StableFlag = True
        Else
            StableFlag = False
        End If
        
        Hmes_m = p_Pipe_WHeadHsp_Tubing.PCurve.pointX(i)
        
        Curve(str_PtubHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.PCurve.PointY(i), StableFlag
        Curve(str_TtubHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_T").PointY(i), StableFlag
        Curve(str_RstubHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_Rs").PointY(i), StableFlag
        Curve(str_GasFracTubHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_gasfrac").PointY(i), StableFlag
        Curve(str_HLtubHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_Hl").PointY(i), StableFlag
        
        Curve(str_muoTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_muo").PointY(i), StableFlag
        Curve(str_muwTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_muw").PointY(i), StableFlag
        Curve(str_mugTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_mug").PointY(i), StableFlag
        Curve(str_mumixTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_mumix").PointY(i), StableFlag
         
        Curve(str_rhooTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_rhoo").PointY(i), StableFlag
        Curve(str_rhowTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_rhow").PointY(i), StableFlag
        Curve(str_rholTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_rhol").PointY(i), StableFlag
        Curve(str_rhogTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_rhog").PointY(i), StableFlag
        Curve(str_rhomixTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_rhomix").PointY(i), StableFlag
         
        Curve(str_qoTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_qo").PointY(i), StableFlag
        Curve(str_qwTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_qw").PointY(i), StableFlag
        Curve(str_qgTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_qg").PointY(i), StableFlag
         
        Curve(str_moTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_mo").PointY(i), StableFlag
        Curve(str_mwTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_mw").PointY(i), StableFlag
        Curve(str_mgTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_mg").PointY(i), StableFlag
         
        Curve(str_vlTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_vl").PointY(i), StableFlag
        Curve(str_vgTubCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Tubing.Curves("c_vg").PointY(i), StableFlag
        
    Next i
End If
' соберем точки по затрубному пространству
If p_Pipe_WHeadHsp_Casing.LengthMes_m > 0 Then
    For i = 1 To p_Pipe_WHeadHsp_Casing.PCurve.numPoints
        
        If i = 1 Or i = p_Pipe_WHeadHsp_Casing.PCurve.numPoints Then
            StableFlag = True
        Else
            StableFlag = False
        End If
    
        Hmes_m = p_Pipe_WHeadHsp_Casing.PCurve.pointX(i)
        Curve(str_PcasHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_P").PointY(i), StableFlag
        Curve(str_TcasHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_T").PointY(i), StableFlag
        
        Curve(str_RscasHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_Rs").PointY(i), StableFlag
        
        Curve(str_GasFracCasHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_gasfrac").PointY(i), StableFlag
        Curve(str_HLcasHmes_curve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_Hl").PointY(i), StableFlag
        
        Curve(str_muoCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_muo").PointY(i), StableFlag
        Curve(str_muwCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_muw").PointY(i), StableFlag
        Curve(str_mugCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_mug").PointY(i), StableFlag
        Curve(str_mumixCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_mumix").PointY(i), StableFlag
         
        Curve(str_rhooCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_rhog").PointY(i), StableFlag
        Curve(str_rhowCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_rhow").PointY(i), StableFlag
        Curve(str_rholCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_rhol").PointY(i), StableFlag
        Curve(str_rhogCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_rhog").PointY(i), StableFlag
        Curve(str_rhomixCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_rhomix").PointY(i), StableFlag
         
        Curve(str_qoCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_qo").PointY(i), StableFlag
        Curve(str_qwCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_qw").PointY(i), StableFlag
        Curve(str_qgCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_qg").PointY(i), StableFlag
         
        Curve(str_moCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_mo").PointY(i), StableFlag
        Curve(str_mwCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_mw").PointY(i), StableFlag
        Curve(str_mgCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_mg").PointY(i), StableFlag
         
        Curve(str_vlCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_vl").PointY(i), StableFlag
        Curve(str_vgCasCurve).AddPoint Hmes_m, p_Pipe_WHeadHsp_Casing.Curves("c_vg").PointY(i), StableFlag
        
    Next i
End If
'  соберем все точки ниже насоса
If p_Pipe_HspHvd.LengthMes_m > 0 Then
    For i = 1 To p_Pipe_HspHvd.PCurve.numPoints
        pumpLenCorr = 0
        If i = 1 Then
            ' первая точка ниже насоса - глубина спуска насоса - скорректируем учтем длину насоса, чтобы графики выглядели красиво
            pumpLenCorr = const_ESP_length
        End If
        If i = 1 Or i = p_Pipe_HspHvd.PCurve.numPoints Then
            StableFlag = True
        Else
            StableFlag = False
        End If
        Hmes_m = p_Pipe_HspHvd.PCurve.pointX(i)
        Curve(str_PtubHmes_curve).AddPoint Hmes_m + pumpLenCorr, p_Pipe_HspHvd.Curves("c_P").PointY(i), StableFlag
        Curve(str_PcasHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_P").PointY(i), StableFlag
        
        Curve(str_TtubHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_T").PointY(i), StableFlag   ' все свойства с одной трубы пишутся в одних точках, поэтому можно писать по индексам (по координатам будет дольше)
        Curve(str_TcasHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_T").PointY(i), StableFlag
        Curve(str_RstubHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_Rs").PointY(i), StableFlag
        Curve(str_GasFracTubHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_gasfrac").PointY(i), StableFlag
        Curve(str_HLtubHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_Hl").PointY(i), StableFlag
        
        Curve(str_RscasHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_Rs").PointY(i), StableFlag
        Curve(str_GasFracCasHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_gasfrac").PointY(i), StableFlag
        Curve(str_HLcasHmes_curve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_Hl").PointY(i), StableFlag
        
        Curve(str_muoTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_muo").PointY(i), StableFlag
        Curve(str_muwTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_muw").PointY(i), StableFlag
        Curve(str_mugTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mug").PointY(i), StableFlag
        Curve(str_mumixTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mumix").PointY(i), StableFlag
         
        Curve(str_rhooTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhoo").PointY(i), StableFlag
        Curve(str_rhowTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhow").PointY(i), StableFlag
        Curve(str_rholTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhol").PointY(i), StableFlag
        Curve(str_rhogTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhog").PointY(i), StableFlag
        Curve(str_rhomixTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhomix").PointY(i), StableFlag
         
        Curve(str_qoTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_qo").PointY(i), StableFlag
        Curve(str_qwTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_qw").PointY(i), StableFlag
        Curve(str_qgTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_qg").PointY(i), StableFlag
         
        Curve(str_moTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mo").PointY(i), StableFlag
        Curve(str_mwTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mw").PointY(i), StableFlag
        Curve(str_mgTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mg").PointY(i), StableFlag
         
        Curve(str_vlTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_vl").PointY(i), StableFlag
        Curve(str_vgTubCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_vg").PointY(i), StableFlag
         
        Curve(str_muoCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_muo").PointY(i), StableFlag
        Curve(str_muwCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_muw").PointY(i), StableFlag
        Curve(str_mugCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mug").PointY(i), StableFlag
        Curve(str_mumixCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mumix").PointY(i), StableFlag
         
        Curve(str_rhooCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhog").PointY(i), StableFlag
        Curve(str_rhowCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhow").PointY(i), StableFlag
        Curve(str_rholCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhol").PointY(i), StableFlag
        Curve(str_rhogCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhog").PointY(i), StableFlag
        Curve(str_rhomixCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_rhomix").PointY(i), StableFlag
         
        Curve(str_qoCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_qo").PointY(i), StableFlag
        Curve(str_qwCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_qw").PointY(i), StableFlag
        Curve(str_qgCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_qg").PointY(i), StableFlag
         
        Curve(str_moCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mo").PointY(i), StableFlag
        Curve(str_mwCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mw").PointY(i), StableFlag
        Curve(str_mgCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_mg").PointY(i), StableFlag
         
        Curve(str_vlCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_vl").PointY(i), StableFlag
        Curve(str_vgCasCurve).AddPoint Hmes_m, p_Pipe_HspHvd.Curves("c_vg").PointY(i), StableFlag
        
        
    Next i
End If
End Sub
    
 
Public Property Get Kseptotal_d() As Double
   If IsESP Then
       Kseptotal_d = ESP.KsepTotal_fr
   Else
       Kseptotal_d = 0
   End If
End Property
 
Public Sub SetKseptotal_d(calc_method As SEPAR_CALC_METHOD, KsepNat_fr As Double, _
                          Optional KsepGS_fr As Double = 0, _
                          Optional Psep_atma As Double = -1, _
                          Optional Tsep_C As Double = -1)
   ' установка значения коэффициента сепарации извне
   ' если значение равно = -1 то расчет по корреляции
   ' если задано какое то значение, то оно будет использовано в расчете
   ' если заданы значения давления и температуры, то они будут использоваться в расчете
    Call ESP.SetKseptotal(calc_method, KsepNat_fr, KsepGS_fr, Psep_atma, Tsep_C)
End Sub
' ======================================================================
' Iwell implementation
' ======================================================================
Private Function IWell_CalcDown(Pline_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
    IWell_CalcDown = calc_Pwf_Plin_atma(Pline_atma, Tbh_C, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcUp(Pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
    IWell_CalcUp = calc_Plin_Pwf_atma(Pwf_atma, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcWell(Pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
End Function
Private Property Get IWell_cfBettaFric() As Double
    IWell_cfBettaFric = betta_fric
End Property
Private Property Get IWell_cfBettaGrav() As Double
    IWell_cfBettaGrav = betta_grav
End Property
Private Property Get IWell_cfChoke() As Double
    IWell_cfChoke = Choke.cfChoke
End Property
Private Property Get IWell_cfESP() As Double
    IWell_cfESP = ESP.cfHead_fr
    ' пока учитывается только по напору
    ' наверное потом надо будет добавить по дебиту и по мощности как то
End Property
Private Property Get IWell_cfFw() As Double
    IWell_cfFw = 0
End Property
Private Property Get IWell_cfGLinj() As Double
    IWell_cfGLinj = 0
End Property
Private Property Get IWell_cfRp() As Double
    IWell_cfRp = 0
End Property
Private Property Get IWell_fw() As Double
    IWell_fw = Fluid.fw_perc
End Property
Private Property Get IWell_Pintake() As Double
    IWell_Pintake = p_PTintake.P_atma
End Property
Private Property Get IWell_Pline() As Double
    IWell_Pline = p_PTlin.P_atma
End Property
Private Property Get IWell_Pwf() As Double
    IWell_Pwf = p_PTwf.P_atma
End Property
Private Property Get IWell_Pwh() As Double
    IWell_Pwh = p_PTbuf.P_atma
End Property
Private Property Get IWell_Qgascas() As Double
    IWell_Qgascas = 0
End Property
Private Property Get IWell_Qgasinj() As Double
    IWell_Qgasinj = 0
End Property
Private Property Let IWell_Qliq(RHS As Double)
    Fluid.Qliq_scm3day = RHS
End Property
Private Property Get IWell_Qliq() As Double
    IWell_Qliq = Fluid.Qliq_scm3day
End Property
