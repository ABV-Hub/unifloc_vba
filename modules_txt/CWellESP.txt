'=======================================================================================
'Unifloc 7.12  Apodemus agrarius                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' класс для расчета свойств скважины c УЭЦН - распределение давления и температуры в скважине
Option Explicit
Option Base 0
Implements IWell
Public Event ReportProgress(msg As String)
Public curve As New CCurves           ' коллекция кривых с результатами расчетов
Public trajectory_tub As New CPipeTrajectory         ' полная траектория скважины с инклинометрии (основной способ задания скважины)
Public trajectory_cas As New CPipeTrajectory         ' полная траектория скважины с инклинометрии (основной способ задания скважины)
Public h_perf_m As Double
Public h_tub_m As Double
Public isCalcCasing As Boolean
Public isCalcESPtemp As Boolean            '
' ============ general well objects ===========
' штуцер установленный на поверхности
' choke always exist in well (but can have diam = 0 which means - no influence on flow)
Private choke_ As New Cchoke
' input fluid object
Private fluid_ As New CPVT                  ' флюид из пласта
' параметры УЭЦН
Private ESP_ As CESPsystemSimple
' abbient formation object needed for full temperature calculation
' must be accessed through property - in order to pass it to pipes properly
Private ambient_formation_ As New CAmbientFormation
' calculated parameters for well
Private PT_buf_ As PTtype
Private PT_lin_ As PTtype
Private PT_cas_ As PTtype
Private PT_wf_ As PTtype
Private PT_int_ As PTtype
Private PT_dis_ As PTtype
' temperature params
' температура задается отдельно, поэтому для удобства прямые параметры для работы с температурной моделью скважины заданы
Private t_wh_C_ As Double
Private t_surf_C_ As Double
Private t_bh_C_ As Double
Private t_int_C_ As Double
Private tres_C_ As Double
Private param_ As PARAMCALC                 ' параметры расчета по трубе
 ' поправочные коэффициенты для расчета распределения давления
Private c_calibr_grav_ As Double
Private c_calibr_fric_ As Double
' ============ESP well objects =======================================
' ключевые элементы конструкции
Private pipe_HspHvd_ As New CPipe           ' от приема насоса до забоя (перфорации)      ' pipe segment from bottom to tubing setting depth
Private pipe_WHeadHsp_Tubing_ As New CPipe  ' от приема насоса по устья скважины до нкт
Private pipe_WHeadHsp_Casing_ As New CPipe  ' от приема насоса до устья
Private pipe_WHeadHsp_Casing_Gas_ As New CPipe  ' от приема насоса до устья газовая шапка в затрубе с учетом плотности газа
' ===========================================
'данные расчета
Private h_sp_m_ As Double                   ' tubing depth
Private H_dyn_m_ As Double                    ' динамический уровень
Private ESP__on As Boolean                 '  УЭЦН включен или нет (флаг)
' ============ constructor ====================
Private Sub Class_Initialize()
    With param_
        .correlation = BeggsBrill
        '.FlowDirection = FlowAgainstCoord
        .FlowAlongCoord = False
        .temp_method = StartEndTemp
    End With
    param = param_                         ' здесь распространим все настройки на трубы
    ESP__on = False                        ' по умолчанию УЭЦН отключен
    c_calibr_grav_ = 1
    c_calibr_fric_ = 1
    isCalcCasing = True
    isCalcESPtemp = False
    init_well_construction 2500, 2000     ' init with some dummy data
    init_well_temperature                 ' init temp with some data
End Sub
'------------------------------------------------------------
' choke general  properties
'------------------------------------------------------------
Property Get choke() As Cchoke
   Set choke = choke_
End Property
Public Sub set_choke(dchoke_mm, Optional dtub_mm = 62)
' установка параметров штуцера
   choke_.d_choke_m = dchoke_mm / 1000
   choke_.d_down_m = dtub_mm / 1000
   choke_.d_up_m = dtub_mm / 1000
End Sub
Public Sub clearChoke()
   choke_.d_choke_m = 0
End Sub
Private Function is_choke() As Boolean
   is_choke = choke_.d_choke_m > 0
End Function
'------------------------------------------------------------
' fluid general properties
'------------------------------------------------------------
Public Property Get fluid() As CPVT
   Set fluid = fluid_
End Property
Public Property Get fluid_tub() As CPVT
   If is_ESP Then Set fluid_tub = ESP.fluid_tub
End Property
Public Property Get fluid_cas() As CPVT
   If is_ESP Then Set fluid_cas = ESP.fluid_cas
End Property
Public Property Set fluid(val As CPVT)
' Установка PVT свойств для скважины
' Для разных сегментов скважины задается один и тот же флюид. После расчета скважины некоторые флюиды могут модифицироваться
  Set fluid_ = val
  Set pipe_HspHvd_.fluid = fluid
  Set pipe_WHeadHsp_Casing_.fluid = fluid
  Set pipe_WHeadHsp_Casing_Gas_.fluid = fluid
  Set pipe_WHeadHsp_Tubing_.fluid = fluid
  Set choke.fluid = fluid
  If is_ESP Then
      Set ESP.fluid = fluid
  End If
End Property
' ---------------------------------------------------------------
' flow correlations tuning methods
' ---------------------------------------------------------------
Public Property Get c_calibr_grav() As Double
   c_calibr_grav = c_calibr_grav_
End Property
Public Property Get c_calibr_fric() As Double
   c_calibr_fric = c_calibr_fric_
End Property
Public Property Let c_calibr_grav(val As Double)
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       pipe_HspHvd_.c_calibr_grav = val
       pipe_WHeadHsp_Casing_.c_calibr_grav = val
       pipe_WHeadHsp_Casing_Gas_.c_calibr_grav = val
       pipe_WHeadHsp_Tubing_.c_calibr_grav = val
'       p_Pipe_WHeadHspFact_Tubing.c_calibr_grav = val
       c_calibr_grav_ = val
       If val <> 1 Then addLogMsg_debug "CWellESP.c_calibr_grav = " & str(val) & " warning. correction to multiphase flow correlation active!"
   Else
       addLogMsg_debug "CWellESP.c_calibr_grav: value " & str(val) & " not set. Out of range"
   End If
End Property
Public Property Let c_calibr_fric(val As Double)
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       pipe_HspHvd_.c_calibr_fric = val
       pipe_WHeadHsp_Casing_.c_calibr_fric = val
       pipe_WHeadHsp_Casing_Gas_.c_calibr_fric = val
       pipe_WHeadHsp_Tubing_.c_calibr_fric = val
'       p_Pipe_WHeadHspFact_Tubing.c_calibr_fric = val
       c_calibr_fric_ = val
       If val <> 1 Then addLogMsg_debug "CWellESP.c_calibr_fric = " & str(val) & " warning. correction to multiphase flow correlation friction active!"
   Else
       addLogMsg_debug "CWellESP.c_calibr_fric: value " & str(val) & " not set. Out of range"
   End If
End Property
Public Property Get hydraulic_correlation() As H_CORRELATION
    hydraulic_correlation = param.correlation
End Property
Public Property Let hydraulic_correlation(val As H_CORRELATION)
    Dim prm As PARAMCALC
    prm = param
    prm.correlation = val
    param = prm
End Property
Public Property Get temp_correlation() As TEMP_CALC_METHOD
    temp_correlation = param.temp_method
End Property
Public Property Let temp_correlation(val As TEMP_CALC_METHOD)
    Dim prm As PARAMCALC
    prm = param
    prm.temp_method = val
    param = prm
End Property
Public Property Get param() As PARAMCALC
    param = param_
End Property
Public Property Let param(val As PARAMCALC)
    param_ = val
    pipe_HspHvd_.param = val
    pipe_WHeadHsp_Casing_.param = val
    pipe_WHeadHsp_Casing_Gas_.param = val
    pipe_WHeadHsp_Tubing_.param = val
End Property
'------------------------------------------------------------
' temperature general properties
'------------------------------------------------------------
Public Property Get Tline_C() As Double
    Tline_C = PT_lin_.t_C
End Property
Public Property Get t_buf_C() As Double
    t_buf_C = PT_buf_.t_C
End Property
Public Property Get t_bh_C() As Double
    t_bh_C = PT_wf_.t_C
End Property
Public Property Get t_wh_C() As Double
    t_wh_C = PT_buf_.t_C
End Property
Public Property Get t_surf_C() As Double
    On Error Resume Next
    t_surf_C = PT_buf_.t_C
    t_surf_C = ambient_formation.amb_temp_C(0)
End Property
Public Property Get ambient_formation() As CAmbientFormation
    Set ambient_formation = ambient_formation_
End Property
Public Property Set ambient_formation(ByVal vNewValue As CAmbientFormation)
    Set ambient_formation_ = vNewValue
    Set pipe_HspHvd_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Casing_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Casing_Gas_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Tubing_.ambient_formation = ambient_formation_
    ' после ручного задания объекта - периинициализируем параметры температурного расчета
    Call init_well_temperature
End Property
'------------------------------------------------------------
' pressure general properties
'------------------------------------------------------------
Public Property Get p_line_atma() As Double
   p_line_atma = PT_lin_.p_atma
End Property
Public Property Get pbuf_atma() As Double
' buffer pressure
   pbuf_atma = PT_buf_.p_atma
End Property
Public Property Get pwf_atma() As Double
' давление на забое
   pwf_atma = PT_wf_.p_atma
End Property
Public Property Get p_an_atma() As Double
' annulus presure
   p_an_atma = PT_cas_.p_atma
End Property
Public Property Get pcas_atma() As Double
    pcas_atma = PT_cas_.p_atma
End Property
Public Property Let pcas_atma(ByVal pcas_atma As Double)
    PT_cas_.p_atma = pcas_atma
End Property
'------------------------------------------------------------
' well rates general properties
'------------------------------------------------------------
Property Let qliq_sm3day(Qval_scm3day As Double)
   fluid.qliq_sm3day = Qval_scm3day
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid
End Property
' дебит жидкости из скважины в поверхностных условиях
Public Property Get qliq_sm3day() As Double
   qliq_sm3day = fluid_.qliq_sm3day
End Property
Public Property Get w_kgsec() As Double
'    массовый расход продукции рассчитаем
   w_kgsec = fluid_.wm_kgsec
End Property
Public Property Get q_oil_sm3day() As Double
   q_oil_sm3day = fluid_.q_oil_sm3day
End Property
Public Property Get q_oil_sctday() As Double
   q_oil_sctday = qliq_sm3day * (1 - fluid_.fw_fr) * fluid_.gamma_o
End Property
Public Property Get q_wat_sm3day() As Double
   q_wat_sm3day = qliq_sm3day * fluid_.fw_fr
End Property
Public Property Get q_gas_scm3day() As Double
   q_gas_scm3day = fluid_.q_gas_sm3day
End Property
Property Get fw_perc() As Double
    fw_perc = fluid_.fw_perc
End Property
Property Let fw_perc(wcval As Double)
   Dim Wc As Double
   Wc = wcval / 100
   fluid.fw_fr = Wc
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid_
End Property
Property Let rp_m3m3(Rpval As Double)
   fluid.rp_m3m3 = Rpval
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid_
End Property
' ---------------------------------------------------------------
' service function
' ---------------------------------------------------------------
 Public Function clone() As CWellESP
    Dim wl As New CWellESP
    Dim i As Integer
    Set wl.trajectory_tub = trajectory_tub
    Set wl.trajectory_cas = trajectory_cas
    Set wl.ambient_formation = ambient_formation
    Call wl.choke.Copy(choke)
    Dim ESP_1 As New CESPpump
    Call ESP_1.Copy(ESP)
    Set wl.ESP = ESP_1
    Set wl.fluid = fluid.clone
    Set clone = wl
 End Function
' =======================================
' методы инициализации скважины
' =======================================
Public Sub init_well_construction(ByVal h_perf_m As Double, _
                                ByVal h_tub_m As Double, _
                       Optional ByVal d_cas_mm As Double = 125, _
                       Optional ByVal dtub_mm As Double = 72, _
                       Optional ByVal udl_m As Double = 0, _
                       Optional ByVal hmes_incl_range_m_ = -1, _
                       Optional ByVal hvert_incl_range_m_ = -1, _
                       Optional ByVal hmes_dcas_range_m_ = -1, _
                       Optional ByVal dcas_range_mm_ = -1, _
                       Optional ByVal hmes_dtub_range_m_ = -1, _
                       Optional ByVal dtub_range_mm_ = -1)
    ' универсальный метод инициализации скважины - должен использоваться для инициализации скважины
    ' поддерживает три варианта инициалиции
    '       - с упрощенным набором данных с удлинением (загрузка из тех режима)
    '       - с заданием инклинометрии через range и упрощенным набором труб (диаметры)
    '       - с заданием инклинометрии и диаметров с использованием range
    '
    ' параметры обязательные для всех вариантов задания
    ' h_perf_m               - глубина перфорации измеренная, м. Используется для расчета забойного давления
    ' h_tub_m                - глубина спуска НКТ измеренная, м. Соответствует глубине спуска насоса
    '
    ' параметры упрощенного режима задания
    ' d_cas_mm               - внутренний диамет эксплуатационной колонны, мм
    ' dtub_mm               - внешний диамет НКТ, мм (толщина стенки 10 мм)
    ' udl_m                 - удлинение на глубину перфорации, м (разница между измеренной и вертикальной глубиной)
    '
    ' параметры детального задания скважины  (все - вертикальные range)
    ' hmes_incl_range_m_    - измеренная глубина скважины для задания инклинометрии
    ' hvert_incl_range_m_   - вертикальная глубина скважины для задания инклинометрии
    '                       - если инклинометрии как range задана, то удлинение игнорируется
    '
    ' hmes_dcas_range_m_    - измеренная глубина для задания диаметра эксплуатационной колонны (начинается с 0)
    ' dcas_range_mm_        - диаметр эксплуатационной колонны на соответствующей глубине (действует от глубины и вниз до след изменения)
    ' hmes_dtub_range_m_    - измеренная глубина для задания диаметра НКТ
    ' dtub_range_mm_        - диаметр НКТ внешний на соответствующей глубине (действует от глубины и вниз до след изменения)
    '                       - для полного задания скважины все range должны быть заданы
    Dim simpleNumbers As Boolean
    Dim fullRange As Boolean
    Dim inclRange As Boolean
    Dim fullArray As Boolean
On Error GoTo er1:
    simpleNumbers = IsNumeric(hmes_incl_range_m_)
    inclRange = IsObject(hmes_incl_range_m_) And IsObject(hvert_incl_range_m_)
    fullRange = inclRange And IsObject(hmes_dcas_range_m_) And IsObject(dcas_range_mm_) And _
                              IsObject(hmes_dtub_range_m_) And IsObject(dtub_range_mm_)
    If simpleNumbers Then
    ' use simple numbers here
        Call FillWellConstructionSimple(h_perf_m, h_tub_m, udl_m, d_cas_mm, dtub_mm)
    ElseIf fullRange Then
        Call FillWellConstructionRangeAll(hmes_incl_range_m_, hvert_incl_range_m_, hmes_dcas_range_m_, _
                              dcas_range_mm_, hmes_dtub_range_m_, dtub_range_mm_, _
                              h_perf_m, h_tub_m)
    ElseIf inclRange Then
        Call FillWellConstructionRange(hmes_incl_range_m_, hvert_incl_range_m_, h_perf_m, h_tub_m, d_cas_mm, dtub_mm)
    End If
    Exit Sub
er1:
    ' стандартная схема обработки ошибок
    Dim err_str As String
    err_str = "CWellESP.init_well_construction: error" & sDELIM & Err.Description
    addLogMsg err_str
    RaiseEvent ReportProgress(err_str)
    Err.Raise Err.Number, Err.Source, err_str
End Sub
Public Sub init_well_temperature(Optional ByVal t_bh_C As Double = -1, _
                               Optional ByVal t_wh_C As Double = -1, _
                               Optional ByVal hmes_tamb_arr_m_ = -1, _
                               Optional ByVal tamb_arr_C_ = -1)
   ' основная функция инициализации температуры в скважине
   ' задает по исходным данным объект ambient_formation, который определяет параметры температуры в скважине
   '
   ' если никакие параметры не заданы, скважине переинициализируется используя уже заданный объект ambient_formation_
   '
   ' t_bh_C              - температура на забое скважины
   ' t_wh_C              - температура на устье скважины
   ' hmes_tamb_arr_m_   - массив (range) измеренных глубин для задания распределения температуры по глубине
   ' tamb_arr_C_        - значения температуры по глубине
    Dim simpleNumbers As Boolean
    Dim ambRange As Boolean
    Dim newTempValues As Boolean
    Dim geoGrad As New CInterpolation
    Dim ambTemp As New CAmbientFormation
    Dim RangX As Range, RangY As Range
On Error GoTo err1:
    simpleNumbers = IsNumeric(hmes_tamb_arr_m_)
    ambRange = IsObject(hmes_tamb_arr_m_) And IsObject(tamb_arr_C_)
    newTempValues = ((t_bh_C > 20) And (t_wh_C > 0)) Or ambRange
    If newTempValues Then
        If simpleNumbers Then
            geoGrad.AddPoint 0, t_wh_C
            geoGrad.AddPoint trajectory_cas.h_abs_hmes_m(h_perf_m), t_bh_C
        ElseIf ambRange Then
            Set RangX = hmes_tamb_arr_m_
            Set RangY = tamb_arr_C_
            Call geoGrad.loadFromVertRange(RangX, RangY)
        End If
        Set ambTemp.amb_temp_curve = geoGrad
        Set ambient_formation_ = ambTemp
    End If
    ' here we must have ambient_formation_ ready for initialisation
    t_bh_C_ = ambient_formation_.amb_temp_C(trajectory_cas.h_abs_hmes_m(h_perf_m))
    t_wh_C_ = ambient_formation_.amb_temp_C(0)
    t_surf_C_ = t_wh_C_
    tres_C_ = fluid.tres_C
    ' инициализируем все элементы скважины для расчета по линейной зависимости от измеренной глубине
    ' это метод расчета по умолчанию
    ' все другие режимы расчета используют объект ambient_formation_ и не зависят от этой инициализации
    Dim TempGrad As Double
    Dim t_int_C As Double
    TempGrad = (t_bh_C_ - t_wh_C_) / h_perf_m
    t_int_C_ = t_bh_C_ - TempGrad * pipe_HspHvd_.length_mes_m
    pipe_HspHvd_.InitTlinear t_int_C_, t_bh_C_
    pipe_WHeadHsp_Tubing_.InitTlinear t_wh_C_, t_int_C_
    pipe_WHeadHsp_Casing_.InitTlinear t_wh_C_, t_int_C_
    pipe_WHeadHsp_Casing_Gas_.InitTlinear t_wh_C_, t_int_C_
    ' зададим значения всех температур в ключевых точках в соответствии с исходными параметрами
    ' некоторые из этих параметров потом могут быть перевычисленны
    PT_buf_.t_C = t_wh_C_
    PT_lin_.t_C = t_wh_C_
    PT_cas_.t_C = t_wh_C_
    PT_wf_.t_C = t_bh_C_
    PT_dis_.t_C = t_int_C_
    PT_int_.t_C = t_int_C_
    Exit Sub
err1:
    Dim errmsg As String
    errmsg = "CWellESP.init_well_temperature: error in temperature init " & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
Private Sub FillWellConstructionSimple( _
                                h_perf_m As Double, _
                                h_tub_m As Double, _
                                udl_m As Double, _
                                d_cas_mm As Double, _
                                dtub_mm As Double _
                                       )
' метод для инициализации скважины простыми числами
On Error GoTo err1:
   Dim errmsg As String
   Dim habs_curve_m As New CInterpolation
   habs_curve_m.AddPoint 0, 0
   habs_curve_m.AddPoint h_perf_m, h_perf_m - udl_m
   Dim dcas_curve_mm As New CInterpolation
   dcas_curve_mm.AddPoint 0, d_cas_mm
   dcas_curve_mm.AddPoint h_perf_m, d_cas_mm
   Dim dtub_curve_mm As New CInterpolation
   dtub_curve_mm.AddPoint 0, dtub_mm
   dtub_curve_mm.AddPoint h_tub_m, dtub_mm
   Me.h_perf_m = h_perf_m
   Me.h_tub_m = h_tub_m
   Call trajectory_tub.init_trajectory_h_abs(habs_curve_m, dtub_curve_mm)
   Call trajectory_cas.init_trajectory_h_abs(habs_curve_m, dcas_curve_mm)
   
   Call FillWellConstructionTr
   Exit Sub
err1:
   errmsg = "CWellESP.FillWellConstructionSimple: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errmsg)
   Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
Private Sub FillWellConstructionRange( _
                          ByVal Incl_h_mes_m_ As Range, _
                          ByVal Incl_h_vert_m_ As Range, _
                          ByVal h_perf_m As Double, _
                          ByVal h_tub_m As Double, _
                          ByVal d_cas_mm As Double, _
                          ByVal dtub_mm As Double _
                                      )
' метод для инициализации скважины данными инсклинометрии и числами для остальных параметров
On Error GoTo err1:
   Dim habs_curve_m As New CInterpolation
   Dim dcas_curve_mm As New CInterpolation
   Dim dtub_curve_mm As New CInterpolation
   Dim geoGrad As New CInterpolation
   Dim ambTemp As New CAmbientFormation
  ' Dim tr As New CTrajectory
   Dim errmsg As String
   Call habs_curve_m.loadFromVertRange(Incl_h_mes_m_, Incl_h_vert_m_)
   dcas_curve_mm.AddPoint 0, d_cas_mm
   dcas_curve_mm.AddPoint h_perf_m, d_cas_mm
   dtub_curve_mm.AddPoint 0, dtub_mm
   dtub_curve_mm.AddPoint h_tub_m, dtub_mm
   Me.h_perf_m = h_perf_m
   Me.h_tub_m = h_tub_m
   
   Call trajectory_cas.init_trajectory_h_abs(habs_curve_m, dcas_curve_mm)
   Call trajectory_tub.init_trajectory_h_abs(habs_curve_m, dtub_curve_mm)
   
   Call FillWellConstructionTr
   Exit Sub
err1:
   errmsg = "CWellESP.FillWellConstructionRange: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errmsg)
   Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
Private Sub FillWellConstructionRangeAll(ByVal Incl_h_mes_m_ As Range, _
                           ByVal Incl_h_vert_m_ As Range, _
                           ByVal hmes_d_cas_m_ As Range, _
                           ByVal dcas_arr_mm_ As Range, _
                           ByVal hmes_d_tub_m_ As Range, _
                           ByVal dtub_arr_mm_ As Range, _
                           ByVal h_perf_m As Double, _
                           ByVal h_tub_m As Double)
' метод для инициализации скважины из диапазонов измнения ключевых параметров
On Error GoTo err1:
   Dim habs_curve_m As New CInterpolation
   Dim dcas_curve_mm As New CInterpolation
   Dim dtub_curve_mm As New CInterpolation
   Dim geoGrad As New CInterpolation
   Dim ambTemp As New CAmbientFormation
  ' Dim h_perf_m As Double, h_tub_m As Double
   Dim errmsg As String
   Call habs_curve_m.loadFromVertRange(Incl_h_mes_m_, Incl_h_vert_m_)
   Call dcas_curve_mm.loadFromVertRange(hmes_d_cas_m_, dcas_arr_mm_)
   Call dtub_curve_mm.loadFromVertRange(hmes_d_tub_m_, dtub_arr_mm_)
  ' h_perf_m = dcas_curve_mm.maxx
  ' h_tub_m = dtub_curve_mm.maxx
   Me.h_perf_m = h_perf_m
   Me.h_tub_m = h_tub_m
   Call trajectory_cas.init_trajectory_h_abs(habs_curve_m, dcas_curve_mm)
   Call trajectory_tub.init_trajectory_h_abs(habs_curve_m, dtub_curve_mm)
   Call FillWellConstructionTr
   Exit Sub
err1:
   errmsg = "CWellESP.FillWellConstructionRangeAll: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errmsg)
   Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
' ============================================================
' основные расчетные функции
' ============================================================
Public Function calc_Pintake_pwf_atma( _
                             ByVal pwf_atma As Double) As Double
' @brief расчет давления на приеме через забойное давление (снизу -> вверх)
' @param pwf_atma - исходное забойное давление
On Error GoTo err1:
    ' 1. Начало расчета. Заданы забойное давление p_wf, температура на забое скважины Tbh
    PT_wf_.p_atma = pwf_atma
    PT_wf_.t_C = t_bh_C
    ' 2. Рассчитывается давление на приеме насоса PIn и температура в потоке перед насосом TbIт
    ' pipe_HspHvd_ - труба от забоя до приема, задаем расчет параметров снизу-вверх
    'pipe_HspHvd_.param = param_calc_along_flow(hydraulic_correlation, temp_correlation)
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=True, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    pipe_HspHvd_.t_calc_C = t_bh_C
    PT_int_ = pipe_HspHvd_.calc_dPipe(pwf_atma)
    calc_Pintake_pwf_atma = PT_int_.p_atma
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.calc_Pintake_pwf_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Public Function calc_pwf_pint_atma( _
                             ByVal pintake_atma As Double) As Double
' @brief расчет забойного давления через давление на приеме   (сверху -> вниз)
' @param pwf_atma - исходное забойное давление
On Error GoTo err1:
    ' 1. Начало расчета. Задано давление на приеме Pintake_atma
    '    температуру на приеме явно задавать не надо - она определится из температурной модели
    '                                           сработают только простые температурные модели
    PT_int_.p_atma = pintake_atma
    Dim t_int_C As Double
    t_int_C = PT_int_.t_C
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=True, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    ' todo 30/07/2019 надо тут разобраться с температурой
    PT_wf_ = pipe_HspHvd_.calc_dPipe(pintake_atma)
    calc_pwf_pint_atma = PT_int_.p_atma
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.calc_pwf_pint_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Public Function calc_plin_pwf_atma( _
                             ByVal pwf_atma As Double, _
                    Optional ByVal saveCurve As CALC_RESULTS = nocurves _
                                  ) As Double
' @brief расчет давления на устье через забойное давление (снизу -> вверх)
' @param pwf_atma - исходное забойное давление
' @@param saveCurve - показывает насколько детально надо сохранять результаты расчета
Dim Tintake_esp_C As Double
Dim PT_cas__temp As PTtype
Dim p_PTintgas_temp As PTtype
Dim Tan_C As Double
Dim pcur As CInterpolation
On Error GoTo err1:
    ' 1. Начало расчета. Заданы забойное давление p_wf, температура на забое скважины Tbh
    PT_wf_.p_atma = pwf_atma
    PT_wf_.t_C = t_bh_C
    ' 2. Рассчитывается давление на приеме насоса PIn и температура в потоке перед насосом TbIт
    ' pipe_HspHvd_ - труба от забоя до приема, задаем расчет параметров снизу-вверх
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=False, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    pipe_HspHvd_.t_calc_C = t_bh_C
    PT_int_ = pipe_HspHvd_.calc_dPipe(PT_wf_.p_atma, saveCurve)
    ' еслт давление на приеме меньше 1 значит поток не доходит до насоса, значит надо поправить расчеты
    If PT_int_.p_atma < 1 Then
'        pipe_HspHvd_.Param = ParamCalcAlongFlow(hydraulic_correlation, temp_correlation)
'        PT_int_.p_atma = 1
'        PT_wf_ = pipe_HspHvd_.calc_dPipe (PT_int_, SaveCurve)              ' стрельнем назад и определим новое давление на приеме
        calc_plin_pwf_atma = 0
        Exit Function
    End If
    If is_ESP() Then                                                 ' Если есть насос
        ' 3. Расчет изменения температуры в насосе
        ' сначала считаем сепарацию и модификацию флюидов
        Call ESP.calc_separation(PT_int_.p_atma, PT_int_.t_C)
        ESP.t_int_C = PT_int_.t_C
        Call ESP.calc_ESPsys(PT_int_.p_atma, calc_temperature:=isCalcESPtemp)
        PT_dis_ = SetPT(ESP.ESP_pump.p_dis_atma, ESP.ESP_pump.t_dis_C)
        Set pipe_WHeadHsp_Tubing_.fluid = ESP.fluid_tub       ' учитываем что выше насоса пойдет модифицированный флюид
        Set pipe_WHeadHsp_Casing_.fluid = ESP.fluid_cas
        Set pipe_WHeadHsp_Casing_Gas_.fluid = ESP.fluid_cas
    Else                                                            ' Если насоса нет, то совпадают
        PT_dis_ = PT_int_
    End If
    ' calc casing (dynamic level) if data given
    If isCalcCasing And is_ESP() And pcas_atma >= 1 Then
        Call calc_casing
    End If
    ' 7. Расчет распределения давления в НКТ и расчет буферного давления c учетом движения в НКТ нефти после сепарации PVTtub
    pipe_WHeadHsp_Tubing_.param = set_calc_flow_param(calc_along_coord:=False, _
                                                      flow_along_coord:=False, _
                                                      hcor:=hydraulic_correlation, _
                                                      temp_method:=temp_correlation)
    pipe_WHeadHsp_Tubing_.t_calc_C = PT_dis_.t_C
    PT_buf_ = pipe_WHeadHsp_Tubing_.calc_dPipe(PT_dis_.p_atma, saveCurve)      'calc_Pipe_PIncl_atma(p_dis_atma_, t_dis_C_)
    ' 8. Расчет линейного давления по штуцеру
    On Error GoTo err_choke:
        If choke_.d_choke_m > 0 Then       ' пока отключено
            PT_lin_ = choke.calc_choke_p_lin(PT_buf_)
            If PT_lin_.p_atma <= 0 Then
                PT_lin_.p_atma = 0
            End If
        Else
            PT_lin_ = PT_buf_
        End If
B:
    On Error GoTo err1:
    ' Если при заданном затрубном давлении Pan существует отличный от нуля динамический уровень Hdyn
    ' то в качестве результатов расчетов сохраняются эти значения
    ' уже подсчитано
    calc_plin_pwf_atma = PT_lin_.p_atma
    Call Savecurves(saveCurve)
    Exit Function
err_choke:
    addLogMsg "CWellESP.calc_plin_pwf_atma: error in choke calculation. p_buf = ", S(PT_buf_.p_atma)
    Resume B:
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.calc_plin_pwf_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
 Public Function calc_pwf_plin_atma(ByVal plin_atma As Double, _
                                    ByVal t_bh_C As Double, _
                                    Optional fast As Boolean = True, _
                                    Optional saveCurve As CALC_RESULTS = nocurves)
 ' функция расчета сверху вниз
 ' тут смотрим можно ли провести расчет быстро
 ' или надо вызывать медленный метод (итерациями снизу вверх)
    ' надо сделать приближение по расчету давления - чтобы сработала сепарация
    If p_int_atma = 0 Then PT_int_ = SetPT(50, t_bh_C)
    If fast And param_.temp_method <> AmbientTemp Then
       calc_pwf_plin_atma = fast_pwf_plin_atma(plin_atma, t_bh_C, saveCurve)
    Else
       calc_pwf_plin_atma = slow_pwf_plin_atma(plin_atma, t_bh_C, saveCurve)
    End If
 End Function
Public Function calc_well(ByVal plin_atma As Double, _
                          ByVal pbuf_atma As Double, _
                          ByVal pwf_atma As Double, _
                          ByVal pcas_atma As Double) As Boolean
'функция анализа работы скважины и определения ключевых параметров по скважине
'надо еще сюда добавить расчет забойного давления по динамическому уровню или давлению на приеме и получится замкнутый анализ скважины
'надо еще сюда добавить построение всех графиков по скважине
' после выполнения этой функции можно сказать что расчет по скважине проведен в полном объеме
   Dim i As Integer
   Dim p_linTemp_atma As Double
   Dim PbufTemp_atma As Double
   Dim ESPdegrDir As Double
   Dim p_linOld1 As Double, p_linOld2 As Double
   Dim foundDegr As Boolean
On Error GoTo err1:
   calc_well = True    ' по умолчанию ждем что все будет хорошо
   ESP.c_calibr_head = 0   ' деградация УЭЦН = 0
   ' расчет параетров калибровки штуцера
   '     - проводится если только данные для штуцера коррекно заданы
   '     - если линейное давление и оно меньше буферного
   If plin_atma > 0 And pbuf_atma > plin_atma And choke.d_choke_m > 0 Then
       '  ищем распределение давления в скважине соответствующее текущим условиям
       Call choke.calc_choke_calibration(pbuf_atma, plin_atma, t_wh_C)
       ' определили поправочный коэффициент для штуцера
   End If
   isCalcCasing = False
   p_linTemp_atma = calc_plin_pwf_atma(pwf_atma)
   ' получаем на выходе коэффициент сепарации и параметры флюида на участке выше насоса
   If isEqual(PT_dis_.p_atma, PT_int_.p_atma) Then ' значит насос не развивает перепад давления и подобрать коэффициент деградации не удасться
       calc_well = False     ' расчет провести не удалось
       ESP.c_calibr_head = 0   ' возвращаем насос в исходное состояние
       Exit Function
   End If
   ESP.c_calibr_head = FindDegradation(plin_atma, pwf_atma)
   ' перерасчитываем распределения давления в скважине с учетом деградации
   isCalcCasing = True
   p_linTemp_atma = calc_plin_pwf_atma(pwf_atma)
   ' после этого расчета определили все параметры по скважине которые нас могут интересовать
   Exit Function
err1:
    If Err.Number = kErrDegradationNotFound Then
        calc_well = False     ' расчет провести не удалось
        ESP.c_calibr_head = 0   ' возвращаем насос в исходное состояние
        Exit Function
    Else
        Dim errmsg As String
        errmsg = "CWellESP.calc_well: ошибка" & sDELIM & Err.Description
        addLogMsg errmsg
        RaiseEvent ReportProgress(errmsg)
        Err.Raise kErrInitCalc, Err.Source, errmsg
    End If
End Function
' =============================================================================
' specific properties and functions
' =============================================================================
'------------------------------------------------------------
' ESP  properties
'------------------------------------------------------------
Public Sub Set_ESPwell_data(Optional p_int_atma As Double = -1, _
                            Optional h_dyn_m As Double = -1, _
                            Optional p_dis_atma As Double = -1)
' sub set additional ESP well props needed for ESP full calc
End Sub
' доступ к насосу
Public Property Get ESP() As CESPsystemSimple
   Set ESP = ESP_
End Property
Public Property Set ESP(val As CESPsystemSimple)
  Set ESP_ = val
  If val Is Nothing Then GoTo noESP:
  ' переводим в состояние "целостность нарушена"
'  p_Calculated = False
On Error GoTo noESP
  ESP__on = True
  Set ESP_.fluid = fluid
  ' after ESP installation consruction must be reset to account ESP length
  Call FillWellConstructionTr
  Exit Property
noESP:
  ESP__on = False
  addLogMsg_debug "насос отключен"
End Property
 Public Property Get is_ESP() As Boolean
    is_ESP = ESP__on
 End Property
'------------------------------------------------------------
' ESP well specific properties
'------------------------------------------------------------
Public Property Get p_int_atma() As Double
' давление на приеме
   p_int_atma = PT_int_.p_atma
End Property
Public Property Get p_dis_atma() As Double
 ' давление на приеме
   p_dis_atma = PT_dis_.p_atma
End Property
Public Property Get t_int_C() As Double
   t_int_C = PT_int_.t_C
End Property
Public Property Get t_dis_C() As Double
   t_dis_C = PT_dis_.t_C
End Property
Public Property Get h_dyn_m() As Double
   h_dyn_m = H_dyn_m_
End Property
Private Sub FillWellConstructionTr()
Dim ESPbottom_m As Double   ' ESP bottom - todo - move to main definition and account pressure drop along ESP
' инициализация скважины по данным траектории скважин
   Call pipe_WHeadHsp_Tubing_.init_pipe_constr_by_trajectory(trajectory_tub, 0, h_tub_m)
   h_sp_m_ = h_tub_m ' определим глубину спуска установки
   If is_ESP Then
       ESP.h_mes_top_m = h_sp_m_  ' установим глубину спуска оборудования
       ESPbottom_m = ESP.HmesBottom_m
   Else
       ESPbottom_m = h_sp_m_
   End If
   Call pipe_WHeadHsp_Casing_.init_pipe_constr_by_trajectory(trajectory_tub, 0, ESPbottom_m, trajectory_cas)
   Call pipe_WHeadHsp_Casing_Gas_.init_pipe_constr_by_trajectory(trajectory_tub, 0, ESPbottom_m, trajectory_cas)
   Call pipe_HspHvd_.init_pipe_constr_by_trajectory(trajectory_cas, ESPbottom_m, h_perf_m)
   choke.d_up_m = 0.06
   choke.d_down_m = 0.06
   Set pipe_HspHvd_.ambient_formation = ambient_formation_
   Set pipe_WHeadHsp_Casing_.ambient_formation = ambient_formation_
   Set pipe_WHeadHsp_Casing_Gas_.ambient_formation = ambient_formation_
   Set pipe_WHeadHsp_Tubing_.ambient_formation = ambient_formation_
End Sub
Private Function FindDegradation(ByVal plin_targ As Double, _
                                 ByVal pwf_atma As Double)
' функция для поиска значения деградации УЭЦН
' plin_targ  - целевое значение линейного давления
' pwf_atma   - забойное давление
'
' kESP = 1 - degr  поправочный коэффициент на насос
   Dim kESP1 As Double ', degr2 As Double
   Dim p_lin1 As Double ', p_lin2 As Double
   Dim kESP_Up As Double   ' верхняя граница значения деградации
   Dim kESP_Down As Double ' нижняя граница значения деградации
   Dim plin_Up As Double
   Dim plin_Down As Double
   Dim found_solution As Double
   Dim i As Integer
    Dim errmsg As String
On Error GoTo err1:
   i = 0
   ' first guess of cf cf=0
   curve(str_Pdisc_calibr_head_curve).ClearPoints
   isCalcCasing = False
   kESP1 = 1
   ' max cf
   kESP_Up = 10
   ESP.c_calibr_head = 1 - kESP_Up
   p_lin1 = calc_plin_pwf_atma(pwf_atma)
   curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP_Up
   ' check if high limit is ok
   If p_lin1 > plin_targ Then
       plin_Up = p_lin1
   Else
        errmsg = " CWellESP.FindDegradation: cf must be too high (more that 10 times) " & sDELIM & Err.Description
        GoTo err2:
        Exit Function
   End If
   kESP_Down = -10
   ESP.c_calibr_head = 1 - kESP_Down
   p_lin1 = calc_plin_pwf_atma(pwf_atma)
   curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP_Up
   ' check if low limit is ok
   If p_lin1 < plin_targ Then
       plin_Down = p_lin1
   Else
       errmsg = " CWellESP.FindDegradation: can't find correction. flow without pump" & sDELIM & Err.Description
       GoTo err2:
       Exit Function
   End If
   Do
       ESP.c_calibr_head = 1 - kESP1
       p_lin1 = calc_plin_pwf_atma(pwf_atma)
       curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP1
       ' посмотрим если вдруг нашли решение то запомним его и завершим расчет
       If (Abs(p_lin1 - plin_targ) < const_well_P_tolerance) Then
            found_solution = True
            FindDegradation = ESP.c_calibr_head
            Exit Function
       End If
       If Not found_solution Then
          If p_lin1 > plin_targ Then
               ' если новое лин давление больше целевого - значит нашли нижнюю границу деградации - искомое значение должно быть больше
              kESP_Up = kESP1
              plin_Up = p_lin1
              If (plin_Down >= 0) And (plin_Down < plin_targ) Then
                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (plin_targ - plin_Down) / (plin_Up - plin_Down) '
              Else
                  kESP1 = kESP1 - 1
              End If
          Else
              kESP_Down = kESP1
              plin_Down = p_lin1
              If (plin_Up > 0) And (plin_Up > plin_targ) Then
                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (plin_targ - plin_Down) / (plin_Up - plin_Down) '
              Else
                  kESP1 = kESP1 + 1
              End If
          End If
        End If
       i = i + 1
   Loop While Not found_solution And i < 20
   Exit Function
err1:
    errmsg = " CWellESP.FindDegradation: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrDegradationError, Err.Source, errmsg
   Exit Function
err2:
    On Error GoTo 0
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrDegradationNotFound, Err.Source, errmsg
End Function
Private Sub calc_casing()
'  расчет параметров затрубного простраства скважины
'  должно быть задано давление на приеме - от которого проводится расчет снизу вверх
'                     и затрубное давление - от которого проводится расчет сверзу вниз
'  результат расчет - распределение давление и значение динамического уровня
    Dim PT_cas__temp As PTtype
    Dim p_PTintgas_temp As PTtype
    Dim cas_crv As CInterpolation
    Dim num_Hd As Integer
On Error GoTo err_casing:
        ' 1. Расчет расхода свободного газа двигающегося через затрубное пространство после сепарации
        ' для затруба считаем снизу вверх
        pipe_WHeadHsp_Casing_.param = set_calc_flow_param(calc_along_coord:=False, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
        PT_cas__temp = pipe_WHeadHsp_Casing_.calc_dPipeZNLF(PT_int_, maincurves)
        ' 2. для затруба считаем распределение давления в газовом столбе сверху вниз
        pipe_WHeadHsp_Casing_Gas_.param = set_calc_flow_param(calc_along_coord:=False, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
        p_PTintgas_temp = pipe_WHeadHsp_Casing_Gas_.calc_dPipe(PT_cas_.p_atma, maincurves)
        ' 3. найдем пересечение  распределений газа и жидкости в затрубе по давлению
        Set cas_crv = pipe_WHeadHsp_Casing_.p_curve.SubtractCurve(pipe_WHeadHsp_Casing_Gas_.p_curve)
        num_Hd = cas_crv.FindSolutions(0, TS_NO_EXTRPOLATION)  ' ищем количество пересечений
        ' 4. если пересечение одно, то все в порядке - это Ндин если значение хорошее
        If num_Hd = 1 Then
            H_dyn_m_ = cas_crv.SolutionPointX(1)
            ' проверяем, чтобы значение динамического уровня было разумным, иначе фиксируем крайние значения
            If H_dyn_m_ < 0 Then H_dyn_m_ = 0
            If H_dyn_m_ >= h_sp_m_ Then H_dyn_m_ = h_sp_m_
            ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
            Set curve("Pcas_Hd") = pipe_WHeadHsp_Casing_.p_curve.CutByCurve(pipe_WHeadHsp_Casing_Gas_.p_curve)
        ElseIf num_Hd = 0 Then
        ' 5. если пересечение найти не удалось - то фиксируем крайние значения
            If PT_cas_.p_atma >= PT_int_.p_atma Then
                H_dyn_m_ = h_sp_m_
            Else
                H_dyn_m_ = 0
            End If
        Else
        '6. если пересечений не одно, то пытаемся применить устаревший алгоритм без учета плотности газа
            addLogMsg_debug "CWellESP.calc_plin_pwf_atma: abnormal casing behavior. Num of intersections =", num_Hd
            ' Если заданному затрубному давлению Pan соответствует отрицательный динамический уровень Hdyn,
            ' тогда ищется затрубное давление P(Hdyn=0)an соответствующее Hdyn=0 и данные значения сохраняются как результат
            If (PT_cas_.p_atma = 0 Or PT_cas_.p_atma >= PT_int_.p_atma) Then
                'p_p_an_atma = pipe_WHeadHsp_Casing_.p_curve.getPoint(0)
                H_dyn_m_ = h_sp_m_
                PT_cas_.p_atma = PT_int_.p_atma
            Else
                With pipe_WHeadHsp_Casing_.p_curve
                        H_dyn_m_ = .FindMinOneSolution(PT_cas_.p_atma)
                End With
            End If
            If (H_dyn_m_ < 0) Then
                H_dyn_m_ = 0
                PT_cas_.p_atma = pipe_WHeadHsp_Casing_.p_curve.getPoint(0)
            End If
            ' Если заданному затрубному давлению Pan соответствует динамический уровень Hdyn больше глубины спуска насоса Hpump, _
            ' тогда ищется затрубное давление P(Hdyn=Hpump)an соответствующее Hdyn=Hpump и данные значения сохраняются как результат
            If is_Hdyn_Larger_Hsp Then
                H_dyn_m_ = h_sp_m_
                PT_cas_.p_atma = pipe_WHeadHsp_Casing_.p_curve.getPoint(h_sp_m_)
            End If
            Set curve("Pcas_Hd") = pipe_WHeadHsp_Casing_.p_curve.CutByValue(H_dyn_m_)
        End If
        '7. сохраним параметры для расчета распределения давления
        ambient_formation_.h_dyn_m = H_dyn_m_
        ambient_formation_.h_pump_m = h_sp_m_
        Call pipe_WHeadHsp_Tubing_.add_h_mes_save_m(H_dyn_m_)
    Exit Sub
err_casing:
    ' стандартная схема обработки ошибок
    Dim err_str As String
    err_str = "CWellESP.calc_casing: error in casing calculation. Pcas = " & S(PT_cas_.p_atma) & sDELIM & Err.Description
    addLogMsg err_str
    RaiseEvent ReportProgress(err_str)
    Err.Raise Err.Number, Err.Source, err_str
 End Sub
 Private Sub Savecurves(saveCurve As CALC_RESULTS)
 On Error GoTo err1:
    If saveCurve > 0 Then
        Call curve(str_PtubHmes_curve).AddPointsCurve(pipe_WHeadHsp_Tubing_.p_curve, pipe_HspHvd_.p_curve)
        curve(str_PtubHmes_curve).xName = "hmes ptub"
        curve(str_PtubHmes_curve).yName = "Ptub"
        Call curve(str_TtubHmes_curve).AddPointsCurve(pipe_WHeadHsp_Tubing_.curves(str_t_curve), pipe_HspHvd_.curves(str_t_curve))
        curve(str_TtubHmes_curve).yName = "Ttub"
        Call curve(str_TambHmes_curve).AddPointsCurve(pipe_WHeadHsp_Tubing_.curves("c_Tamb"), pipe_HspHvd_.curves("c_Tamb"))
        curve(str_TambHmes_curve).yName = "Tamb"
        Call curve(str_PcasHmes_curve).AddPointsCurve(curve("Pcas_Hd"))
        curve(str_PcasHmes_curve).xName = "hmes pcas"
        If saveCurve > 1 Then
            Call curve(str_HlHmes_curve).AddPointsCurve(pipe_WHeadHsp_Tubing_.curvesOut("c_Hl"), pipe_HspHvd_.curvesOut("c_Hl"))
            curve(str_HlHmes_curve).yName = "Hl"
        End If
    End If
     Exit Sub
err1:
    Dim errmsg As String
    errmsg = "CWellESP.Savecurves: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
 End Sub
 Private Function fast_pwf_plin_atma( _
                         plin_atma As Double, _
                         ByVal t_bh_C As Double, _
                Optional saveCurve As CALC_RESULTS = nocurves _
                                    )
'@brief  быстрый метод расчета забойного давления через линейное (без итераций - прямой счет)
'         считает за один проход, за счет дополнительных упрощений и предположений
'@param plin_atma  линейное давление
'@param t_bh_C      температура на забое
'@param saveCurve  флаг показывает - что сохранять в качестве результатов
'       для уточнения оценки сепарации флюида желательно задать
'       оценочные значения давления и температуры на приеме УЭЦН p_int_atma t_int_C для объекта расчета
'       расчет температуры по заданной извне температурной корреляции, которая должны быть простой
On Error GoTo err1:
    If temp_correlation = AmbientTemp Then
        temp_correlation = GeoGradTemp
    End If
    ' 1. если есть ЭЦН пытаемся оценить сепарацию и модификацию флюида на основе предполагаемого давления на приеме насоса
    If is_ESP Then
        Call ESP.calc_separation(p_int_atma, t_int_C)
        Set pipe_WHeadHsp_Tubing_.fluid = ESP.fluid_tub
        If is_choke() Then Set choke.fluid = ESP.fluid_tub
    End If
    ' 2. фиксируем заданные линейные давления
    PT_lin_.p_atma = plin_atma
    PT_lin_.t_C = t_wh_C
    ' 3. Расчет буферного давления по штуцеру
    If is_choke() Then
        PT_buf_ = choke.calc_choke_p_buf(PT_lin_)
        If PT_buf_.p_atma < 0 Then PT_buf_.p_atma = 1
    Else
        PT_buf_ = PT_lin_
    End If
    ' 4. Расчет давления на выкиде по буферному
    pipe_WHeadHsp_Tubing_.param = set_calc_flow_param(calc_along_coord:=False, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    PT_dis_ = pipe_WHeadHsp_Tubing_.calc_dPipe(PT_buf_.p_atma, saveCurve)
    ' 5. если есть ЭЦН то считаем давление на приеме по давлению на выкиде сверху вниз
    If is_ESP() Then                                                 ' Если есть насос
        ' расчитываются параметры насоса включая сепарацию и модификацию флюидов
        Call ESP.calc_ESPsys(PT_dis_.p_atma, calc_along_flow:=False)
        PT_int_ = SetPT(ESP.ESP_pump.p_int_atma, ESP.ESP_pump.t_int_C)
    Else                                                            ' Если насоса нет, то совпадают
        PT_int_ = PT_dis_
    End If
    ' 6. По давлению на приеме считаем забойное давление
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=False, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    PT_wf_ = pipe_HspHvd_.calc_dPipe(PT_int_.p_atma, saveCurve)
    fast_pwf_plin_atma = PT_wf_.p_atma
    ' 7. если надо считаем затруб
    Dim PT_cas__temp As PTtype
    If isCalcCasing And pcas_atma >= 1 Then
        Call calc_casing
    End If
    Call Savecurves(saveCurve)
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.fast_pwf_plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Private Function slow_pwf_plin_atma(ByVal plin_atma As Double, _
                                        ByVal t_bh_C As Double, _
                                        Optional saveCurve As CALC_RESULTS = nocurves)
' @brief calc_pwf_plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
' @param plin_atma - давление в линии
' @param Hd - динамический уровень
' @param t_bh_C - температура на забое скважины
' @return Подсчитанное для заданного линейного давление
On Error GoTo err1:
    Dim p_wf1 As Double      ' первое приближение
    Dim p_wfUp As Double, p_wfDown As Double
    Dim p_linUp As Double, p_linDown As Double
    Dim p_lin0 As Double, p_lin1 As Double
    Dim found_solution As Boolean
    Dim i As Integer
    found_solution = False
    i = 0
    p_wf1 = 60
    p_wfUp = -1
    p_wfDown = -1
    Do
        ' ищем  приближения
        p_lin1 = calc_plin_pwf_atma(p_wf1, saveCurve:=nocurves)
        If (Abs(p_lin1 - plin_atma) < const_well_P_tolerance) Then
             found_solution = True
             PT_wf_.p_atma = p_wf1
             PT_wf_.t_C = t_bh_C
        End If
        If Not found_solution Then
          If p_lin1 > plin_atma Then
              p_wfUp = p_wf1
              p_linUp = p_lin1
              If p_wfDown < 0 Then
                  p_wf1 = p_wfUp / 2
              Else
                  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
              End If
          Else
              p_wfDown = p_wf1
              p_linDown = p_lin1
              If p_wfUp < 0 Then
                  p_wf1 = p_wf1 * 2
              Else
                  p_wf1 = (p_wfUp + p_wfDown) / 2
                '  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
              End If
          End If
        End If
        i = i + 1
    Loop While Not found_solution And i < 20
    ' calc more one time to restore all what needed
    PT_lin_.p_atma = calc_plin_pwf_atma(PT_wf_.p_atma, saveCurve:=saveCurve)
    If Abs(Me.p_line_atma - plin_atma) > const_well_P_tolerance Then
       addLogMsg "calc_pwf_plin_atma: ошибка расчета забойного давления больше " & const_well_P_tolerance & ". Равна = " & Abs(Me.p_line_atma - plin_atma)
    End If
    slow_pwf_plin_atma = PT_wf_.p_atma
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.slow_pwf_plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
 End Function
Public Function calc_pwf_pcas_hdyn_atma(ByVal p_an_atma As Double, ByVal Hd_m As Double, ByVal t_bh_C As Double) As PTtype
' @brief calc_pwf_pcas_hdyn_atma - расчет забойного давления через динамический уровень
' @param Pan - затрубное давление
' @param Hd - динамический уровень
' @param t_bh_C - температура на забое скважины
' @return Подсчитанное для заданного динамического уровня давление
On Error GoTo err1:
    Set curve(str_Hd_Depend_p_wf) = Build_Hdp_wfcurve(p_an_atma, t_bh_C)
    ' 3. По построенной кривой находим значение забойного давления соответствующее заданному динамическому уровню
    PT_wf_.p_atma = curve(str_Hd_Depend_p_wf).FindMinOneSolution(Hd_m)
    ' 4. Для обеспечение целостности данных по скважине проводим расчет распределения давления по скважине для найденного забойного давления
    ' расчет давления на устье через забойное давление
    Call calc_plin_pwf_atma(PT_wf_.p_atma)
    PT_cas_.p_atma = p_an_atma
   ' Me.h_dyn_m = Hd_m
    calc_pwf_pcas_hdyn_atma = PT_wf_
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.slow_pwf_plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Private Function is_Hdyn_Larger_Hsp() As Boolean
' Динамический уровень Hdyn больше глубины спуска насоса Hpump,
    is_Hdyn_Larger_Hsp = is_ESP() And H_dyn_m_ > h_sp_m_
End Function
'Public Function calc_PinGasFrac_simple_atma(GasFrac_d As Double, T_C As Double, Optional Ksepar As Double = 0)
''  расчет давления на приеме обеспечивающего заданную долю газа при определенное температуре
'
'Dim PinMin As Double, PInMax As Double  ' оценки снизу и сверху для доли газа
'Dim eps As Double
'Dim Pcalc As Double
'Dim i As Integer
'Dim gasfr As Double
'
'i = 0
'eps = 0.1 '  погрешность расчета
'
'If Ksepar < 0 Then Ksepar = 0
'If Ksepar > 1 Then Ksepar = 1
'
'
'PinMin = 1
'If gas_fraction_d(PinMin, T_C, fluid, Ksep:=Ksepar) < GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac больше единицы задан, должно в расчете быть 1
'    calc_PinGasFrac_simple_atma = 0
'  '  Debug.Assert False
'    Exit Function
'End If
'
'PInMax = fluid.calc_pb_atma(fluid.rsb_m3m3, T_C)
'If gas_fraction_d(PInMax, T_C, fluid, Ksep:=Ksepar) > GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac менее нуля задан - должно в расчете быть ноль
'    calc_PinGasFrac_simple_atma = PInMax
'  ' Debug.Assert False
'    Exit Function
'End If
'
'
'Do
'    i = i + 1   ' предохранитель от сваливания в бесконечный цикл
'    Pcalc = (PinMin + PInMax) / 2
'    gasfr = gas_fraction_d(Pcalc, T_C, fluid, Ksep:=Ksepar)
'    If GasFrac_d < gasfr Then
'        PinMin = Pcalc
'    Else
'        PInMax = Pcalc
'    End If
'
'Loop Until (Abs(PinMin - PInMax) < eps) Or (i > 100)
'calc_PinGasFrac_simple_atma = Pcalc
'
'End Function
'Public Function calc_p_wfGasFrac_atma(GasFrac_d As Double, t_bh_C As Double)
''  расчет давления на приеме обеспечивающего заданную долю газа при определенное температуре
'
'Dim p_wfMin As Double, p_wfMax As Double  ' оценки снизу и сверху для доли газа
'Dim PinMin As Double, PInMax As Double
'Dim eps As Double
'Dim Pcalc As Double
'Dim i As Integer
'Dim gasfr As Double
'
'i = 0
'eps = 0.1 '  погрешность расчета
'
'
'
'PinMin = 1
'p_wfMin = calc_pwf_p_intake_atma(PinMin, t_bh_C)
'
'Call calc_plin_pwf_atma(SetPT(p_wfMin, t_bh_C), CalcCasing:=False)
'
'If gas_fraction_PumpIntake_d < GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac больше единицы задан, должно в расчете быть 1
'    calc_p_wfGasFrac_atma = 0
'  '  Debug.Assert False
'    Exit Function
'End If
'
'PInMax = fluid.calc_pb_atma(fluid.rsb_m3m3, t_bh_C)
'p_wfMax = calc_pwf_p_intake_atma(PInMax, t_bh_C)
'
'Call calc_plin_pwf_atma(SetPT(p_wfMax, t_bh_C), CalcCasing:=False)
'
'If gas_fraction_PumpIntake_d > GasFrac_d Then
'    ' либо что то неправильно рассчиталось либо исходный gasfrac менее нуля задан - должно в расчете быть ноль
'    calc_p_wfGasFrac_atma = PInMax
'  ' Debug.Assert False
'    Exit Function
'End If
'
'
'Do
'    i = i + 1   ' предохранитель от сваливания в бесконечный цикл
'    Pcalc = (PinMin + PInMax) / 2
'
'    Call calc_plin_pwf_atma(SetPT(Pcalc, t_bh_C), CalcCasing:=False)
'    gasfr = gas_fraction_PumpIntake_d
'    If GasFrac_d < gasfr Then
'        PinMin = Pcalc
'    Else
'        PInMax = Pcalc
'    End If
'
'Loop Until (Abs(PinMin - PInMax) < eps) Or (i > 100)
'calc_p_wfGasFrac_atma = Pcalc
'
'End Function
Public Function Build_Pwhp_wfcurve( _
                Optional ByVal p_linMax As Double = -1, _
                Optional ByVal p_wf1_atma As Double = -1, _
                Optional ByVal Pstep As Integer = DEFAULT_PAN_STEP, _
                Optional ByVal calcFast As Boolean = False _
                                 ) As CInterpolation
' @brief Build_Pwhp_wfcurve построение кривой зависимости буферного и линейного давлений на скважине от забойного давления
'               на кривой есть две особые точки, на которых теряется гладкость
'                   1 - там где буферное давление становится больше нуля (граница работы скважины по забойному)
'                   2 - там где линейное давление становится больше нуля
'               эти точки ищутся более точным алгоритмом для правильной отрисовки графика
' @param p_linMax - ограничение величины линейного давления определяющее границы построения кривой
' @param p_wf1_atma - значение забойного давления, которое останется после проведения расчета
' @param Pstep  - шаг поиска значений
' @param calcFast - флаг показывающий насколько точно надо строить кривую (влияет на поиск пересечений с нулем)
    Dim pwf_temp As Double
    Dim P_step As Double
    Dim processing As Boolean
    Dim pwf_temp1 As Double ' забойное давление минимальное с которого надо начинать поиск
    Dim pwf_temp_old As Double
    Dim pwf_temp_new As Double
    Dim ITER  As Integer
    Dim p_wfmin_atma As Double   ' временная переменная для хранения минимального забойного давления с которого надо начинать поиск зайбоного давления
On Error GoTo err1:
    p_wfmin_atma = 1
    If (p_linMax < 0) And (p_line_atma > 0) Then
        p_linMax = p_line_atma
    End If
    If p_wf1_atma < 0 Then
        p_wf1_atma = pwf_atma
    End If
    ' 1. Начало расчета. Заданы линейное давление p_line,
    '    Температура на забое скважины Tbh определяется температурной моделью
    P_step = Pstep
    ' 2. Строим графическую зависимость линейного давления от забойного давления для заданных параметров скважины
    curve(str_plin_Depend_p_wf).ClearPoints
    curve(str_pbuf_pwf_curve).ClearPoints
    processing = True
    isCalcCasing = False
    pwf_temp = p_wfmin_atma     ' здесь надо получше выбирать начальное приближения для расчета для ускорения
    Do
        pwf_temp = pwf_temp + P_step
        PT_lin_.p_atma = calc_plin_pwf_atma(pwf_temp)
        If (pbuf_atma > const_minPpipe_atma) Then    ' вышли в область больших буферных давлений
            If curve(str_pbuf_pwf_curve).num_points = 0 Then  ' первый раз тут - ищем поточнее начало
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
                pwf_temp_old = pwf_temp - P_step
                pwf_temp_new = pwf_temp
                ITER = 1
                ' надо точнее искать точку если нет противопоказаний
                While (pbuf_atma > const_minPpipe_atma * 1.1) And processing And Not calcFast
                    pwf_temp = (pwf_temp_old + pwf_temp_new) / 2
                    PT_lin_.p_atma = calc_plin_pwf_atma(pwf_temp)
                    If pbuf_atma > const_minPpipe_atma Then
                        pwf_temp_new = pwf_temp
                    Else
                        pwf_temp_old = pwf_temp
                    End If
                    ITER = ITER + 1
                    If ITER > 10 Then processing = False
                Wend
                If processing = False Then
                     PT_lin_.p_atma = 0
                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
                     addLogMsg "Build_Pwhp_wfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости ,буферного давления от забойного. p_wf = " _
                                                    & pwf_temp & " итераций = " & ITER & " дебит = " & qliq_sm3day & " Рбуф = " & pbuf_atma
                End If
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
            End If
            Pstep = DEFAULT_PAN_STEP / 3
        Else
            p_wfmin_atma = pwf_temp
        End If
        If (p_line_atma > -1) And (Not isEqual(p_line_atma, pbuf_atma)) Then      ' вышли в область больших линейных давлений
            If curve(str_plin_Depend_p_wf).num_points = 0 Then   ' первый раз тут - ищем поточнее начало
                pwf_temp_old = pwf_temp - P_step
                pwf_temp_new = pwf_temp
                ITER = 1
                While (p_line_atma <> 0) And processing And Not calcFast  ' Then   ' надо точнее искать точку
                    pwf_temp = (pwf_temp_old + pwf_temp_new) / 2
                    isCalcCasing = False
                    PT_lin_.p_atma = calc_plin_pwf_atma(pwf_temp)
                    If p_line_atma > 0 Then
                        pwf_temp_new = pwf_temp
                    Else
                        pwf_temp_old = pwf_temp
                    End If
                    ITER = ITER + 1
                    If ITER > 20 Then processing = False
                    If (p_line_atma >= 0) Then                          ' если ставить точки слишком часто - тогда проявляются неустойчивости - может надо будет сделать прореживание
                        curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
                        curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
                    End If
                Wend
                If p_line_atma <> 0 Then
                     PT_lin_.p_atma = 0
                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
                     addLogMsg "Build_Pwhp_wfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости линейного давления от забойного. p_wf = " _
                                                    & pwf_temp & " итераций = " & ITER & " дебит = " & qliq_sm3day & " Рбуф = " & pbuf_atma
                End If
                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
            End If
        Else
            If isEqual(p_line_atma, pbuf_atma) And (p_line_atma > 1) Then
                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
            End If
        End If
        If p_line_atma > 1 Then
           curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
           curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
        End If
        ' ждем пока кривая перечеркнет уровень целевого линейного давления
    Loop While (p_line_atma < p_linMax + 10) Or (curve(str_plin_Depend_p_wf).num_points < MinCountPoints_calc_pwf_pcas_hdyn_atma)
    isCalcCasing = True
    PT_lin_.p_atma = calc_plin_pwf_atma(p_wf1_atma)
    Set Build_Pwhp_wfcurve = curve(str_plin_Depend_p_wf)
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.Build_Pwhp_wfcurve: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Public Function Build_Hdp_wfcurve(p_an_atma As Double, t_bh_C As Double, Optional p_wf1_atma As Double = -1) As CInterpolation
' расчет зависимости динамического уровня от забойного давления для заданных условий
' @brief Build_Hdp_wfcurve - расчет забойного давления через динамический уровень
' @param Pan - затрубное давление
' @param t_bh_C - температура на забое скважины
' @return Подсчитанное для заданного динамического уровня давление
  On Error GoTo er1:
    Dim pwf_temp As Double
    Dim plin_temp As Double
    Dim P_step As Double
    Dim processing As Boolean
    Dim HdAtIntake As Boolean, Panold As Double
    Dim p_wfold As Double, p_wfold1 As Double
    Dim Hdold As Double
    Dim itr As Integer, itr2 As Integer, itr3 As Integer
    Dim Hdpump As Double
    If p_an_atma <= 0 Then
        addLogMsg "CWellESP.Build_Hdp_wfcurve: попытка построить график динамического уровня от забойного давления при затрубном давлении =" & p_an_atma
        Exit Function
    End If
    ' 1. Начало расчета. Заданы затрубное давление Pan, динамический уровень Hdyn, температура на забое скважины Tbh
  '  p_an_atma = p_an_atma
  '  t_bh_C_ = t_bh_C
    P_step = DEFAULT_PAN_STEP '/ 3
    ' 2. Строим графическую зависимость динамического уровня от забойного давления для заданных параметров скважины
    curve(str_Hd_Depend_p_wf).ClearPoints
    processing = True
    If p_wf1_atma < 0 Then
        p_wf1_atma = pwf_atma
    End If
    HdAtIntake = False
    itr3 = 0
    Do
       pwf_temp = p_an_atma
       itr2 = 0
       Do
            PT_cas_.p_atma = p_an_atma
            isCalcCasing = True
            plin_temp = calc_plin_pwf_atma(pwf_temp)
            If Me.p_an_atma < p_an_atma Then
            ' уровень на приеме - надо найти точно точку начала слома
                HdAtIntake = True
                Panold = Me.p_an_atma
                p_wfold = pwf_temp
                Hdold = H_dyn_m_
                Hdpump = H_dyn_m_
            Else
            ' вышли в зону где уровень выше приема насоса
                If HdAtIntake And Abs(Hdold - H_dyn_m_) > 10 Then
                    ' погрешность около точки слома по дин уровню больше 10 метров - надо уточнить лучше
                    p_wfold1 = pwf_temp
                    itr = 0
                    Do
                        itr = itr + 1
                        pwf_temp = (p_wfold1 + p_wfold) / 2
                        PT_cas_.p_atma = p_an_atma
                        isCalcCasing = True
                        plin_temp = calc_plin_pwf_atma(pwf_temp)
                        If H_dyn_m_ = Hdpump Then
                            HdAtIntake = True
                            Panold = Me.p_an_atma
                            p_wfold = pwf_temp
                            Hdold = H_dyn_m_
                        Else
                            p_wfold1 = pwf_temp
                        End If
                    Loop While ((Abs(Hdpump - H_dyn_m_) > 10) Or Abs(p_an_atma - Me.p_an_atma) > 2) And itr < 10 '
                End If
'                Debug.Assert itr < 10
                itr = 0
                HdAtIntake = False ' сбросим флаг, что нашли точку слома
            End If
            curve(str_Hd_Depend_p_wf).AddPoint pwf_temp, H_dyn_m_
            curve(str_Pan_Depend_p_wf).AddPoint pwf_temp, p_an_atma
            pwf_temp = pwf_temp + P_step
'            Debug.Assert pwf_temp < 300
            itr2 = itr2 + 1
        Loop While (Not is_Hdyn_Larger_Hsp And H_dyn_m_ > 0) And (itr2 < 100)
        ' проверка условий продолжения цикла
        If (curve(str_Hd_Depend_p_wf).num_points >= MinCountPoints_calc_pwf_pcas_hdyn_atma) Then
            processing = False
        Else
            curve(str_Hd_Depend_p_wf).ClearPoints
            P_step = P_step / 2
            ' проверка корректности. Если шаг слишком мелкий при этом точек решения мало - то это не здоровая ситуация - надо показать ее
            If P_step < 0.01 Then
                addLogMsg "CWellESP.Build_Hdp_wfcurve: Не удалось построить кривую зависимости динамического уровня от забойного давления. шаг перебора точек менее 0.01 атм"
                Err.Raise kErrBuildCurve, , "CWellESP.Build_Hdp_wfcurve нет получается построить кривую - мелкий шаг получился"
            End If
        End If
        itr3 = itr3 + 1
    Loop While (processing) And (itr3 < 5)
    'восстановим после расчета необходимое распределение в скважине
    PT_cas_.p_atma = p_an_atma
    isCalcCasing = True
    plin_temp = calc_plin_pwf_atma(p_wf1_atma)
    Set Build_Hdp_wfcurve = curve(str_Hd_Depend_p_wf)
   ' переводим в состояние "целостность нарушена"
  '  p_Calculated = False
    Exit Function
er1:
  ' Debug.Assert False
   Resume Next
End Function
Public Function Build_VLPcurve(p_line As Double, ByVal t_bh_C As Double, Optional maxQ As Double = 200, Optional Qnow As Double = -1) As CInterpolation
' расчет кривой лифта
' на выходе с расчета кривая лифта заданная в определенном формате кривой
'
    PT_lin_.p_atma = p_line
    Const VLPNumPoints = 20
    Dim i As Integer
    Dim Qstep As Double
    Dim p_wf As Double
    Dim Qliq_reserv As Double
    Qliq_reserv = qliq_sm3day
    Qstep = maxQ / VLPNumPoints
    RaiseEvent ReportProgress("Build_VLPcurve. Начинаем строить кривую оттока. Точек =   " & VLPNumPoints)
    For i = 0 To VLPNumPoints
        qliq_sm3day = i * Qstep
        p_wf = calc_pwf_plin_atma(p_line, t_bh_C)
        curve(str_VLPcurve).AddPoint qliq_sm3day, p_wf
        ' поднимем наверх событие по поводу длительного расчета
        RaiseEvent ReportProgress("Build_VLPcurve   i= " & i & " из " & VLPNumPoints)
    Next i
    ' вернем состояние скважины в исходное значение
    If Qnow = -1 Then
        Qnow = maxQ * 1.1
    End If
    qliq_sm3day = Qnow
    p_wf = calc_pwf_plin_atma(p_line, t_bh_C)
    curve(str_VLPcurve).AddPoint qliq_sm3day, p_wf
    Set Build_VLPcurve = curve(str_VLPcurve)
End Function
'Public Property get PtubHmes_curve() As CInterpolation
' Set PtubHmes_curve = curve(str_PtubHmes_curve)
'End Property
Property Get VLPCurve() As CInterpolation
  Set VLPCurve = curve(str_VLPcurve)
End Property
Private Sub fillcurvesPT()
' формирование массивов свойств потока вдоль ствола скважины (давление температура и прочее)
Dim i As Integer
Dim pumpLenCorr As Double
Dim h_mes_m As Double   ' текущая глубина
Dim StableFlag As Boolean
StableFlag = False
' соберем точки по НКТ
If pipe_WHeadHsp_Tubing_.length_mes_m > 0 Then
    For i = 1 To pipe_WHeadHsp_Tubing_.p_curve.num_points
        If i = 1 Or i = pipe_WHeadHsp_Tubing_.p_curve.num_points Then
            StableFlag = True
        Else
            StableFlag = False
        End If
        h_mes_m = pipe_WHeadHsp_Tubing_.p_curve.pointX(i)
        curve(str_PtubHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.p_curve.PointY(i), StableFlag
        curve(str_TtubHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_T").PointY(i), StableFlag
        curve(str_RstubHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_Rs").PointY(i), StableFlag
        curve(str_GasFracTubHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_gasfrac").PointY(i), StableFlag
        curve(str_HLtubHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_Hl").PointY(i), StableFlag
        curve(str_muoTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_muo").PointY(i), StableFlag
        curve(str_muwTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_muw").PointY(i), StableFlag
        curve(str_mugTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_mug").PointY(i), StableFlag
        curve(str_mumixTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_mumix").PointY(i), StableFlag
        curve(str_rhooTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_rhoo").PointY(i), StableFlag
        curve(str_rhowTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_rhow").PointY(i), StableFlag
        curve(str_rholTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_rhol").PointY(i), StableFlag
        curve(str_rhogTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_rhog").PointY(i), StableFlag
        curve(str_rhomixTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_rhomix").PointY(i), StableFlag
        curve(str_qoTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_qo").PointY(i), StableFlag
        curve(str_qwTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_qw").PointY(i), StableFlag
        curve(str_qgTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_qg").PointY(i), StableFlag
        curve(str_moTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_mo").PointY(i), StableFlag
        curve(str_mwTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_mw").PointY(i), StableFlag
        curve(str_mgTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_mg").PointY(i), StableFlag
        curve(str_vlTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_vl").PointY(i), StableFlag
        curve(str_vgTubCurve).AddPoint h_mes_m, pipe_WHeadHsp_Tubing_.curves("c_vg").PointY(i), StableFlag
    Next i
End If
' соберем точки по затрубному пространству
If pipe_WHeadHsp_Casing_.length_mes_m > 0 Then
    For i = 1 To pipe_WHeadHsp_Casing_.p_curve.num_points
        If i = 1 Or i = pipe_WHeadHsp_Casing_.p_curve.num_points Then
            StableFlag = True
        Else
            StableFlag = False
        End If
        h_mes_m = pipe_WHeadHsp_Casing_.p_curve.pointX(i)
        curve(str_PcasHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_P").PointY(i), StableFlag
        curve(str_TcasHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_T").PointY(i), StableFlag
        curve(str_RscasHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_Rs").PointY(i), StableFlag
        curve(str_GasFracCasHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_gasfrac").PointY(i), StableFlag
        curve(str_HLcasHmes_curve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_Hl").PointY(i), StableFlag
        curve(str_muoCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_muo").PointY(i), StableFlag
        curve(str_muwCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_muw").PointY(i), StableFlag
        curve(str_mugCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_mug").PointY(i), StableFlag
        curve(str_mumixCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_mumix").PointY(i), StableFlag
        curve(str_rhooCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_rhog").PointY(i), StableFlag
        curve(str_rhowCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_rhow").PointY(i), StableFlag
        curve(str_rholCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_rhol").PointY(i), StableFlag
        curve(str_rhogCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_rhog").PointY(i), StableFlag
        curve(str_rhomixCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_rhomix").PointY(i), StableFlag
        curve(str_qoCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_qo").PointY(i), StableFlag
        curve(str_qwCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_qw").PointY(i), StableFlag
        curve(str_qgCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_qg").PointY(i), StableFlag
        curve(str_moCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_mo").PointY(i), StableFlag
        curve(str_mwCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_mw").PointY(i), StableFlag
        curve(str_mgCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_mg").PointY(i), StableFlag
        curve(str_vlCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_vl").PointY(i), StableFlag
        curve(str_vgCasCurve).AddPoint h_mes_m, pipe_WHeadHsp_Casing_.curves("c_vg").PointY(i), StableFlag
    Next i
End If
'  соберем все точки ниже насоса
If pipe_HspHvd_.length_mes_m > 0 Then
    For i = 1 To pipe_HspHvd_.p_curve.num_points
        pumpLenCorr = 0
        If i = 1 Then
            ' первая точка ниже насоса - глубина спуска насоса - скорректируем учтем длину насоса, чтобы графики выглядели красиво
            pumpLenCorr = const_ESP_length
        End If
        If i = 1 Or i = pipe_HspHvd_.p_curve.num_points Then
            StableFlag = True
        Else
            StableFlag = False
        End If
        h_mes_m = pipe_HspHvd_.p_curve.pointX(i)
        curve(str_PtubHmes_curve).AddPoint h_mes_m + pumpLenCorr, pipe_HspHvd_.curves("c_P").PointY(i), StableFlag
        curve(str_PcasHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_P").PointY(i), StableFlag
        curve(str_TtubHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_T").PointY(i), StableFlag   ' все свойства с одной трубы пишутся в одних точках, поэтому можно писать по индексам (по координатам будет дольше)
        curve(str_TcasHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_T").PointY(i), StableFlag
        curve(str_RstubHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_Rs").PointY(i), StableFlag
        curve(str_GasFracTubHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_gasfrac").PointY(i), StableFlag
        curve(str_HLtubHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_Hl").PointY(i), StableFlag
        curve(str_RscasHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_Rs").PointY(i), StableFlag
        curve(str_GasFracCasHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_gasfrac").PointY(i), StableFlag
        curve(str_HLcasHmes_curve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_Hl").PointY(i), StableFlag
        curve(str_muoTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_muo").PointY(i), StableFlag
        curve(str_muwTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_muw").PointY(i), StableFlag
        curve(str_mugTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mug").PointY(i), StableFlag
        curve(str_mumixTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mumix").PointY(i), StableFlag
        curve(str_rhooTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhoo").PointY(i), StableFlag
        curve(str_rhowTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhow").PointY(i), StableFlag
        curve(str_rholTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhol").PointY(i), StableFlag
        curve(str_rhogTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhog").PointY(i), StableFlag
        curve(str_rhomixTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhomix").PointY(i), StableFlag
        curve(str_qoTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_qo").PointY(i), StableFlag
        curve(str_qwTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_qw").PointY(i), StableFlag
        curve(str_qgTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_qg").PointY(i), StableFlag
        curve(str_moTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mo").PointY(i), StableFlag
        curve(str_mwTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mw").PointY(i), StableFlag
        curve(str_mgTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mg").PointY(i), StableFlag
        curve(str_vlTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_vl").PointY(i), StableFlag
        curve(str_vgTubCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_vg").PointY(i), StableFlag
        curve(str_muoCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_muo").PointY(i), StableFlag
        curve(str_muwCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_muw").PointY(i), StableFlag
        curve(str_mugCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mug").PointY(i), StableFlag
        curve(str_mumixCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mumix").PointY(i), StableFlag
        curve(str_rhooCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhog").PointY(i), StableFlag
        curve(str_rhowCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhow").PointY(i), StableFlag
        curve(str_rholCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhol").PointY(i), StableFlag
        curve(str_rhogCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhog").PointY(i), StableFlag
        curve(str_rhomixCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_rhomix").PointY(i), StableFlag
        curve(str_qoCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_qo").PointY(i), StableFlag
        curve(str_qwCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_qw").PointY(i), StableFlag
        curve(str_qgCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_qg").PointY(i), StableFlag
        curve(str_moCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mo").PointY(i), StableFlag
        curve(str_mwCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mw").PointY(i), StableFlag
        curve(str_mgCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_mg").PointY(i), StableFlag
        curve(str_vlCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_vl").PointY(i), StableFlag
        curve(str_vgCasCurve).AddPoint h_mes_m, pipe_HspHvd_.curves("c_vg").PointY(i), StableFlag
    Next i
End If
End Sub
Public Property Get ksep_total_d() As Double
   If is_ESP Then
       ksep_total_d = ESP.ksep_total_fr
   Else
       ksep_total_d = 0
   End If
End Property
Public Sub Setksep_total_d(calc_method As SEPAR_CALC_METHOD, ksep_nat_fr As Double, _
                          Optional KsepGS_fr As Double = 0, _
                          Optional p_ksep_atma As Double = -1, _
                          Optional t_ksep_C As Double = -1)
   ' установка значения коэффициента сепарации извне
   ' если значение равно = -1 то расчет по корреляции
   ' если задано какое то значение, то оно будет использовано в расчете
   ' если заданы значения давления и температуры, то они будут использоваться в расчете
    Call ESP.setksep_total(calc_method, ksep_nat_fr, KsepGS_fr, p_ksep_atma, t_ksep_C)
End Sub
' ======================================================================
' Iwell implementation
' ======================================================================
Private Function IWell_CalcDown(p_line_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
    IWell_CalcDown = calc_pwf_plin_atma(p_line_atma, t_bh_C, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcUp(pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
    IWell_CalcUp = calc_plin_pwf_atma(pwf_atma, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcWell(pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
End Function
Private Property Get IWell_cfBettaFric() As Double
    IWell_cfBettaFric = c_calibr_fric
End Property
Private Property Get IWell_cfBettaGrav() As Double
    IWell_cfBettaGrav = c_calibr_grav
End Property
Private Property Get IWell_cDegradChoke() As Double
    IWell_cDegradChoke = choke.c_degrad_fr
End Property
Private Property Get IWell_cfESP() As Double
    IWell_cfESP = ESP.c_calibr_head
    ' пока учитывается только по напору
    ' наверное потом надо будет добавить по дебиту и по мощности как то
End Property
Private Property Get IWell_cfFw() As Double
    IWell_cfFw = 0
End Property
Private Property Get IWell_cfGLinj() As Double
    IWell_cfGLinj = 0
End Property
Private Property Get IWell_cfRp() As Double
    IWell_cfRp = 0
End Property
Private Property Get IWell_fw() As Double
    IWell_fw = fluid.fw_perc
End Property
Private Property Get IWell_Pintake() As Double
    IWell_Pintake = PT_int_.p_atma
End Property
Private Property Get IWell_Pline() As Double
    IWell_Pline = PT_lin_.p_atma
End Property
Private Property Get IWell_Pwf() As Double
    IWell_Pwf = PT_wf_.p_atma
End Property
Private Property Get IWell_Pwh() As Double
    IWell_Pwh = PT_buf_.p_atma
End Property
Private Property Get IWell_Qgascas() As Double
    IWell_Qgascas = 0
End Property
Private Property Get IWell_Qgasinj() As Double
    IWell_Qgasinj = 0
End Property
Private Property Let IWell_Qliq(RHS As Double)
    fluid.qliq_sm3day = RHS
End Property
Private Property Get IWell_Qliq() As Double
    IWell_Qliq = fluid.qliq_sm3day
End Property

