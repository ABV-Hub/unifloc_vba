'=======================================================================================
'Unifloc 7.13  Lepus                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' класс для расчета свойств скважины c УЭЦН - распределение давления и температуры в скважине
Option Explicit
Option Base 0
Implements IWell
Public Event ReportProgress(msg As String)
Private ESP_ As CESPsystemSimple
Public curve As New CCurves                     ' коллекция кривых с результатами расчетов
Public trajectory_tub As New CPipeTrajectory    ' полная траектория скважины с инклинометрии (основной способ задания скважины)
Public trajectory_cas As New CPipeTrajectory    ' полная траектория скважины с инклинометрии (основной способ задания скважины)
Public h_perf_m As Double
Public h_tub_m As Double
Public isCalcCasing As Boolean
Public isCalcESPtemp As Boolean
' штуцер установленный на поверхности
' choke always exist in well (but can have diam = 0 which means - no influence on flow)
Public choke As New Cchoke
' input fluid object
Private fluid_ As New CPVT                      ' флюид из пласта
' ambient formation object needed for full temperature calculation
' must be accessed through property - in order to pass it to pipes properly
Private ambient_formation_ As New CAmbientFormation
' calculated parameters for well
Private PT_buf_ As PTtype
Private PT_lin_ As PTtype
Private PT_cas_ As PTtype
Private PT_wf_ As PTtype
Private PT_int_ As PTtype
Private PT_dis_ As PTtype
' temperature params
' температура задается отдельно, поэтому для удобства прямые параметры для работы с температурной моделью скважины заданы
Private t_wh_C_ As Double
Private t_surf_C_ As Double
Private t_bh_C_ As Double
Private t_int_C_ As Double
Private tres_C_ As Double
Private param_ As PARAMCALC                 ' параметры расчета по трубе
' поправочные коэффициенты для расчета распределения давления
Private c_calibr_grav_ As Double
Private c_calibr_fric_ As Double
' ключевые элементы конструкции
Private pipe_HspHvd_ As New CPipe           ' от приема насоса до забоя (перфорации)      ' pipe segment from bottom to tubing setting depth
Private pipe_WHeadHsp_Tubing_ As New CPipe  ' от приема насоса по устья скважины до нкт
Private pipe_WHeadHsp_Casing_ As New CPipe  ' от приема насоса до устья
Private pipe_WHeadHsp_Casing_Gas_ As New CPipe  ' от приема насоса до устья газовая шапка в затрубе с учетом плотности газа
'данные расчета
Private h_sp_m_ As Double                   ' tubing depth
Private Hdyn_Pcas_ As PCAS_HDYN_type                    ' динамический уровень
Private ESP_on As Boolean                 '  УЭЦН включен или нет (флаг)
' =============================================================================
' ============ constructor ====================================================
Private Sub Class_Initialize()
    With param_
        .correlation = BeggsBrill
        .FlowAlongCoord = False
        .CalcAlongCoord = False
        .temp_method = StartEndTemp
    End With
    param = param_                         ' здесь распространим все настройки на трубы
    ESP_on = False                        ' по умолчанию УЭЦН отключен
    c_calibr_grav_ = 1
    c_calibr_fric_ = 1
    isCalcCasing = True
    isCalcESPtemp = False
End Sub
'------------------------------------------------------------
' fluid general properties
'------------------------------------------------------------
Public Property Get fluid() As CPVT
   Set fluid = fluid_
End Property
Public Property Get fluid_tub() As CPVT
   If ESP_on Then Set fluid_tub = ESP.fluid_tub
End Property
Public Property Get fluid_cas() As CPVT
   If ESP_on Then Set fluid_cas = ESP.fluid_cas
End Property
Public Property Set fluid(val As CPVT)
' Установка PVT свойств для скважины
' Для разных сегментов скважины задается один и тот же флюид. После расчета скважины некоторые флюиды могут модифицироваться
  Set fluid_ = val
  Set pipe_HspHvd_.fluid = fluid
  Set pipe_WHeadHsp_Casing_.fluid = fluid
  Set pipe_WHeadHsp_Casing_Gas_.fluid = fluid
  Set pipe_WHeadHsp_Tubing_.fluid = fluid
  Set choke.fluid = fluid
  If ESP_on Then
      Set ESP.fluid = fluid
  End If
End Property
' ---------------------------------------------------------------
' flow correlations tuning methods
' ---------------------------------------------------------------
Public Property Get c_calibr_grav() As Double
   c_calibr_grav = c_calibr_grav_
End Property
Public Property Get c_calibr_fric() As Double
   c_calibr_fric = c_calibr_fric_
End Property
Public Property Let c_calibr_grav(val As Double)
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       pipe_HspHvd_.c_calibr_grav = val
       pipe_WHeadHsp_Casing_.c_calibr_grav = val
       pipe_WHeadHsp_Casing_Gas_.c_calibr_grav = val
       pipe_WHeadHsp_Tubing_.c_calibr_grav = val
'       p_Pipe_WHeadHspFact_Tubing.c_calibr_grav = val
       c_calibr_grav_ = val
       If val <> 1 Then addLogMsg_debug "CWellESP.c_calibr_grav = " & str(val) & " warning. correction to multiphase flow correlation active!"
   Else
       addLogMsg_debug "CWellESP.c_calibr_grav: value " & str(val) & " not set. Out of range"
   End If
End Property
Public Property Let c_calibr_fric(val As Double)
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
       pipe_HspHvd_.c_calibr_fric = val
       pipe_WHeadHsp_Casing_.c_calibr_fric = val
       pipe_WHeadHsp_Casing_Gas_.c_calibr_fric = val
       pipe_WHeadHsp_Tubing_.c_calibr_fric = val
'       p_Pipe_WHeadHspFact_Tubing.c_calibr_fric = val
       c_calibr_fric_ = val
       If val <> 1 Then addLogMsg_debug "CWellESP.c_calibr_fric = " & str(val) & " warning. correction to multiphase flow correlation friction active!"
   Else
       addLogMsg_debug "CWellESP.c_calibr_fric: value " & str(val) & " not set. Out of range"
   End If
End Property
Public Property Get hydraulic_correlation() As H_CORRELATION
    hydraulic_correlation = param.correlation
End Property
Public Property Let hydraulic_correlation(val As H_CORRELATION)
    Dim prm As PARAMCALC
    prm = param
    prm.correlation = val
    param = prm
End Property
Public Property Get temp_correlation() As TEMP_CALC_METHOD
    temp_correlation = param.temp_method
End Property
Public Property Let temp_correlation(val As TEMP_CALC_METHOD)
    Dim prm As PARAMCALC
    prm = param
    prm.temp_method = val
    param = prm
End Property
Public Sub set_param(Optional calc_along_coord As Boolean, _
                     Optional flow_along_coord As Boolean, _
                     Optional ByVal hcor As H_CORRELATION, _
                     Optional temp_method As TEMP_CALC_METHOD)
    If Not IsMissing(calc_along_coord) Then param_.CalcAlongCoord = calc_along_coord
    If Not IsMissing(flow_along_coord) Then param_.FlowAlongCoord = flow_along_coord
    If Not IsMissing(hcor) Then param_.correlation = hcor
    If Not IsMissing(temp_method) Then param_.temp_method = temp_method
    
    param = param_
End Sub
Public Property Get param() As PARAMCALC
    param = param_
End Property
Public Property Let param(val As PARAMCALC)
    param_ = val
    pipe_HspHvd_.param = val
    pipe_WHeadHsp_Casing_.param = val
    pipe_WHeadHsp_Casing_Gas_.param = val
    pipe_WHeadHsp_Tubing_.param = val
End Property
'------------------------------------------------------------
' temperature general properties
'------------------------------------------------------------
Public Property Get Tline_C() As Double
    Tline_C = PT_lin_.t_C
End Property
Public Property Get t_buf_C() As Double
    t_buf_C = PT_buf_.t_C
End Property
Public Property Get t_bh_C() As Double
    t_bh_C = PT_wf_.t_C
End Property
Public Property Get t_wh_C() As Double
    t_wh_C = PT_buf_.t_C
End Property
Public Property Get t_surf_C() As Double
    On Error Resume Next
    t_surf_C = PT_buf_.t_C
    t_surf_C = ambient_formation.amb_temp_C(0)
End Property
Public Property Get ambient_formation() As CAmbientFormation
    Set ambient_formation = ambient_formation_
End Property
Public Property Set ambient_formation(ByVal vNewValue As CAmbientFormation)
    Set ambient_formation_ = vNewValue
    Set pipe_HspHvd_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Casing_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Casing_Gas_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Tubing_.ambient_formation = ambient_formation_
    ' после ручного задания объекта - периинициализируем параметры температурного расчета
    Call fill_temperature_from_amb
End Property
'------------------------------------------------------------
' pressure general properties
'------------------------------------------------------------
Public Property Get p_line_atma() As Double
   p_line_atma = PT_lin_.p_atma
End Property
Public Property Get pbuf_atma() As Double
' buffer pressure
   pbuf_atma = PT_buf_.p_atma
End Property
Public Property Get pwf_atma() As Double
' давление на забое
   pwf_atma = PT_wf_.p_atma
End Property
Public Property Get p_an_atma() As Double
' annulus presure
   p_an_atma = PT_cas_.p_atma
End Property
Public Property Get pcas_atma() As Double
    pcas_atma = PT_cas_.p_atma
End Property
Public Property Let pcas_atma(ByVal pcas_atma As Double)
    PT_cas_.p_atma = pcas_atma
End Property
'------------------------------------------------------------
' well rates general properties
'------------------------------------------------------------
Property Let qliq_sm3day(Qval_scm3day As Double)
   fluid.qliq_sm3day = Qval_scm3day
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid
End Property
' дебит жидкости из скважины в поверхностных условиях
Public Property Get qliq_sm3day() As Double
   qliq_sm3day = fluid_.qliq_sm3day
End Property
Public Property Get w_kgsec() As Double
'    массовый расход продукции рассчитаем
   w_kgsec = fluid_.wm_kgsec
End Property
Public Property Get q_oil_sm3day() As Double
   q_oil_sm3day = fluid_.q_oil_sm3day
End Property
Public Property Get q_oil_sctday() As Double
   q_oil_sctday = qliq_sm3day * (1 - fluid_.fw_fr) * fluid_.gamma_o
End Property
Public Property Get q_wat_sm3day() As Double
   q_wat_sm3day = qliq_sm3day * fluid_.fw_fr
End Property
Public Property Get q_gas_scm3day() As Double
   q_gas_scm3day = fluid_.q_gas_sm3day
End Property
Property Get fw_perc() As Double
    fw_perc = fluid_.fw_perc
End Property
Property Let fw_perc(wcval As Double)
   Dim Wc As Double
   Wc = wcval / 100
   fluid_.fw_fr = Wc
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid_
End Property
Property Let rp_m3m3(Rpval As Double)
   fluid_.rp_m3m3 = Rpval
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid_
End Property
' ---------------------------------------------------------------
' service function
' ---------------------------------------------------------------
Public Function clone() As CWellESP
   Dim wl As New CWellESP
   Dim i As Integer
   Set wl.trajectory_tub = trajectory_tub
   Set wl.trajectory_cas = trajectory_cas
   Set wl.ambient_formation = ambient_formation
   Call wl.choke.Copy(choke)
   Dim ESP_1 As New CESPpump
   Call ESP_1.Copy(ESP)
   Set wl.ESP = ESP_1
   Set wl.fluid = fluid.clone
   Set clone = wl
End Function
Public Sub fill_temperature_from_amb()
    ' here we must have ambient_formation_ ready for initialisation
On Error GoTo err1:
    t_bh_C_ = ambient_formation_.amb_temp_C(trajectory_cas.h_abs_hmes_m(h_perf_m))
    t_wh_C_ = ambient_formation_.amb_temp_C(0)
    t_surf_C_ = t_wh_C_
    tres_C_ = fluid.tres_C
    ' инициализируем все элементы скважины для расчета по линейной зависимости от измеренной глубине
    ' это метод расчета по умолчанию
    ' все другие режимы расчета используют объект ambient_formation_ и не зависят от этой инициализации
    Dim TempGrad As Double
    Dim t_int_C As Double
    TempGrad = (t_bh_C_ - t_wh_C_) / h_perf_m
    t_int_C_ = t_bh_C_ - TempGrad * pipe_HspHvd_.length_mes_m
    pipe_HspHvd_.InitTlinear t_int_C_, t_bh_C_
    pipe_WHeadHsp_Tubing_.InitTlinear t_wh_C_, t_int_C_
    pipe_WHeadHsp_Casing_.InitTlinear t_wh_C_, t_int_C_
    pipe_WHeadHsp_Casing_Gas_.InitTlinear t_wh_C_, t_int_C_
    ' зададим значения всех температур в ключевых точках в соответствии с исходными параметрами
    ' некоторые из этих параметров потом могут быть перевычисленны
    PT_buf_.t_C = t_wh_C_
    PT_lin_.t_C = t_wh_C_
    PT_cas_.t_C = t_wh_C_
    PT_wf_.t_C = t_bh_C_
    PT_dis_.t_C = t_int_C_
    PT_int_.t_C = t_int_C_
    Exit Sub
err1:
    Dim errmsg As String
    errmsg = "CWellESP.init_well_temperature: error in temperature init " & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
' ============================================================
' основные расчетные функции
' ============================================================
Public Function calc_pintake_pwf_atma( _
                             ByVal pwf_atma As Double) As Double
' @brief расчет давления на приеме через забойное давление (снизу -> вверх)
' @param pwf_atma - исходное забойное давление
On Error GoTo err1:
    ' 1. Начало расчета. Заданы забойное давление p_wf, температура на забое скважины Tbh
    PT_wf_.p_atma = pwf_atma
    PT_wf_.t_C = t_bh_C
    ' 2. Рассчитывается давление на приеме насоса PIn и температура в потоке перед насосом TbIт
    '    pipe_HspHvd_ - труба от забоя до приема, задаем расчет параметров снизу-вверх
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=True, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    pipe_HspHvd_.t_calc_C = t_bh_C
    PT_int_ = pipe_HspHvd_.calc_dPipe(pwf_atma)
    calc_pintake_pwf_atma = PT_int_.p_atma
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.calc_Pintake_pwf_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Public Function calc_pwf_pint_atma( _
                             ByVal pintake_atma As Double) As Double
' @brief расчет забойного давления через давление на приеме   (сверху -> вниз)
' @param pwf_atma - исходное забойное давление
On Error GoTo err1:
    ' 1. Начало расчета. Задано давление на приеме Pintake_atma
    '    температуру на приеме явно задавать не надо - она определится из температурной модели
    '                                           сработают только простые температурные модели
    PT_int_.p_atma = pintake_atma
    Dim t_int_C As Double
    t_int_C = PT_int_.t_C
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=True, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    ' todo 30/07/2019 надо тут разобраться с температурой
    PT_wf_ = pipe_HspHvd_.calc_dPipe(pintake_atma)
    calc_pwf_pint_atma = PT_wf_.p_atma
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.calc_pwf_pint_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Public Function calc_plin_pwf_atma( _
                             ByVal pwf_atma As Double, _
                    Optional ByVal t_C As Double, _
                    Optional ByVal saveCurve As CALC_RESULTS = nocurves _
                                  ) As Double
' @brief расчет давления на устье через забойное давление (снизу -> вверх)
' @param pwf_atma - исходное забойное давление
' @@param saveCurve - показывает насколько детально надо сохранять результаты расчета
Dim Tintake_esp_C As Double
Dim PT_cas__temp As PTtype
Dim p_PTintgas_temp As PTtype
Dim Tan_C As Double
Dim pcur As CInterpolation
On Error GoTo err1:
    ' 1. Начало расчета. Заданы забойное давление p_wf, температура на забое скважины Tbh
    PT_wf_.p_atma = pwf_atma
    If Not IsMissing(t_C) Then t_bh_C_ = t_C
    PT_wf_.t_C = t_bh_C
    ' 2. Рассчитывается давление на приеме насоса PIn и температура в потоке перед насосом TbIт
    '    pipe_HspHvd_ - труба от забоя до приема, задаем расчет параметров снизу-вверх
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=False, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    ' Расчитываем давление на приеме (p_wf - забойное давление на работающей скважине, Pws - забойное давление на неработающей скважине,)
    'pipe_HspHvd_.t_calc_C = t_bh_C
    PT_int_ = pipe_HspHvd_.calc_dPipe(PT_wf_.p_atma, t_bh_C_, saveCurve:=saveCurve)
    ' если давление на приеме меньше 1 значит поток не доходит до насоса, значит надо поправить расчеты
    If PT_int_.p_atma < 1 Then
        calc_plin_pwf_atma = 0
        Exit Function
    End If
    If ESP_on Then                                                 ' Если есть насос
        ' 3. Расчет изменения температуры в насосе
        ' сначала считаем сепарацию и модификацию флюидов
        Call ESP.calc_separation(PT_int_.p_atma, PT_int_.t_C)
        ESP.t_int_C = PT_int_.t_C
        Call ESP.calc_ESPsys(PT_int_.p_atma, calc_temperature:=isCalcESPtemp)
        PT_dis_ = SetPT(ESP.ESP_pump.p_dis_atma, ESP.ESP_pump.t_dis_C)
        Set pipe_WHeadHsp_Tubing_.fluid = ESP.fluid_tub       ' учитываем что выше насоса пойдет модифицированный флюид
        Set pipe_WHeadHsp_Casing_.fluid = ESP.fluid_cas
        Set pipe_WHeadHsp_Casing_Gas_.fluid = ESP.fluid_cas
    Else                                                            ' Если насоса нет, то совпадают
        PT_dis_ = PT_int_
    End If
    ' calc casing (dynamic level) if data given
    If isCalcCasing And ESP_on And pcas_atma >= 1 Then
        Call calc_casing
    End If
    ' 7. Расчет распределения давления в НКТ и расчет буферного давления c учетом движения в НКТ нефти после сепарации PVTtub
    pipe_WHeadHsp_Tubing_.param = set_calc_flow_param(calc_along_coord:=False, _
                                                      flow_along_coord:=False, _
                                                      hcor:=hydraulic_correlation, _
                                                      temp_method:=temp_correlation)
    pipe_WHeadHsp_Tubing_.t_calc_C = PT_dis_.t_C
    PT_buf_ = pipe_WHeadHsp_Tubing_.calc_dPipe(PT_dis_.p_atma, PT_dis_.t_C, saveCurve)     'calc_Pipe_PIncl_atma(p_dis_atma_, t_dis_C_)
    ' 8. Расчет линейного давления по штуцеру
    On Error GoTo err_choke:
        If choke.d_choke_m > 0 Then       ' пока отключено
            PT_lin_ = choke.calc_choke_p_lin(PT_buf_)
            If PT_lin_.p_atma <= 0 Then
                PT_lin_.p_atma = 0
            End If
        Else
            PT_lin_ = PT_buf_
        End If
b:
    On Error GoTo err1:
    ' Если при заданном затрубном давлении Pan существует отличный от нуля динамический уровень Hdyn
    ' то в качестве результатов расчетов сохраняются эти значения
    ' уже подсчитано
    calc_plin_pwf_atma = PT_lin_.p_atma
    Call save_curves(saveCurve)
    Exit Function
err_choke:
    addLogMsg "CWellESP.calc_plin_pwf_atma: error in choke calculation. p_buf = ", S(PT_buf_.p_atma)
    Resume b:
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.calc_plin_pwf_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Public Function calc_pwf_plin_atma(ByVal plin_atma As Double, _
                                   ByVal t_bh_C As Double, _
                                   Optional fast As Boolean = True, _
                                   Optional saveCurve As CALC_RESULTS = nocurves)
' функция расчета сверху вниз
' тут смотрим можно ли провести расчет быстро
' или надо вызывать медленный метод (итерациями снизу вверх)
   ' надо сделать приближение по расчету давления - чтобы сработала сепарация
   If p_int_atma = 0 Then PT_int_ = SetPT(50, t_bh_C)
   If fast And param_.temp_method <> AmbientTemp Then
      calc_pwf_plin_atma = fast_pwf_plin_atma(plin_atma, t_bh_C, saveCurve)
   Else
      calc_pwf_plin_atma = slow_pwf_plin_atma(plin_atma, t_bh_C, saveCurve)
   End If
End Function
Public Function calc_well(ByVal plin_atma As Double, _
                          ByVal pbuf_atma As Double, _
                          ByVal pwf_atma As Double, _
                          ByVal pcas_atma As Double) As Boolean
'функция анализа работы скважины и определения ключевых параметров по скважине
'надо еще сюда добавить расчет забойного давления по динамическому уровню или давлению на приеме и получится замкнутый анализ скважины
'надо еще сюда добавить построение всех графиков по скважине
' после выполнения этой функции можно сказать что расчет по скважине проведен в полном объеме
   Dim i As Integer
   Dim p_linTemp_atma As Double
   Dim PbufTemp_atma As Double
   Dim ESPdegrDir As Double
   Dim p_linOld1 As Double, p_linOld2 As Double
   Dim foundDegr As Boolean
On Error GoTo err1:
   calc_well = True    ' по умолчанию ждем что все будет хорошо
   ESP.c_calibr_head = 0   ' деградация УЭЦН = 0
   ' расчет параетров калибровки штуцера
   '     - проводится если только данные для штуцера коррекно заданы
   '     - если линейное давление и оно меньше буферного
   If plin_atma > 0 And pbuf_atma > plin_atma And choke.d_choke_m > 0 Then
       '  ищем распределение давления в скважине соответствующее текущим условиям
       Call choke.calc_choke_calibration(pbuf_atma, plin_atma, t_wh_C)
       ' определили поправочный коэффициент для штуцера
   End If
   isCalcCasing = False
   p_linTemp_atma = calc_plin_pwf_atma(pwf_atma)
   ' получаем на выходе коэффициент сепарации и параметры флюида на участке выше насоса
   If isEqual(PT_dis_.p_atma, PT_int_.p_atma) Then ' значит насос не развивает перепад давления и подобрать коэффициент деградации не удасться
       calc_well = False     ' расчет провести не удалось
       ESP.c_calibr_head = 0   ' возвращаем насос в исходное состояние
       Exit Function
   End If
   ESP.c_calibr_head = FindDegradation(plin_atma, pwf_atma)
   ' перерасчитываем распределения давления в скважине с учетом деградации
   isCalcCasing = True
   p_linTemp_atma = calc_plin_pwf_atma(pwf_atma)
   ' после этого расчета определили все параметры по скважине которые нас могут интересовать
   Exit Function
err1:
    If Err.Number = kErrDegradationNotFound Then
        calc_well = False     ' расчет провести не удалось
        ESP.c_calibr_head = 0   ' возвращаем насос в исходное состояние
        Exit Function
    Else
        Dim errmsg As String
        errmsg = "CWellESP.calc_well: ошибка" & sDELIM & Err.Description
        addLogMsg errmsg
        RaiseEvent ReportProgress(errmsg)
        Err.Raise kErrInitCalc, Err.Source, errmsg
    End If
End Function
'------------------------------------------------------------
' ESP  properties
'------------------------------------------------------------
' доступ к насосу
Public Property Get ESP() As CESPsystemSimple
   Set ESP = ESP_
End Property
Public Property Set ESP(val As CESPsystemSimple)
  Set ESP_ = val
  If val Is Nothing Then GoTo noESP:
  ' переводим в состояние "целостность нарушена"
On Error GoTo noESP
  ESP_on = True
  Set ESP_.fluid = fluid
  ' after ESP installation consruction must be reset to account ESP length
  Call FillWellConstructionTr
  Exit Property
noESP:
  ESP_on = False
  addLogMsg_debug "насос отключен"
End Property
'------------------------------------------------------------
' ESP well specific properties
'------------------------------------------------------------
Public Property Get p_int_atma() As Double
' давление на приеме
   p_int_atma = PT_int_.p_atma
End Property
Public Property Get p_dis_atma() As Double
 ' давление на приеме
   p_dis_atma = PT_dis_.p_atma
End Property
Public Property Get t_int_C() As Double
   t_int_C = PT_int_.t_C
End Property
Public Property Get t_dis_C() As Double
   t_dis_C = PT_dis_.t_C
End Property
Public Property Get h_dyn_m() As Double
    If Hdyn_Pcas_.correct Then
        h_dyn_m = Hdyn_Pcas_.hdyn_m
    Else
        h_dyn_m = 0
    End If
End Property
Public Sub FillWellConstructionTr()
    Dim ESPbottom_m As Double   ' ESP bottom - todo - move to main definition and account pressure drop along ESP
    ' инициализация скважины по данным траектории скважин
    
    Call pipe_WHeadHsp_Tubing_.init_pipe_constr_by_trajectory(trajectory_tub, 0, h_tub_m)
    h_sp_m_ = h_tub_m ' определим глубину спуска установки
    If ESP_on Then
       ESP.h_mes_top_m = h_sp_m_  ' установим глубину спуска оборудования
       ESPbottom_m = ESP.HmesBottom_m
    Else
       ESPbottom_m = h_sp_m_
    End If
    Call pipe_WHeadHsp_Casing_.init_pipe_constr_by_trajectory(trajectory_tub, 0, ESPbottom_m, trajectory_cas)
    Call pipe_WHeadHsp_Casing_Gas_.init_pipe_constr_by_trajectory(trajectory_tub, 0, ESPbottom_m, trajectory_cas)
    Call pipe_HspHvd_.init_pipe_constr_by_trajectory(trajectory_cas, ESPbottom_m, h_perf_m)
    choke.d_up_m = 0.06
    choke.d_down_m = 0.06
    Set pipe_HspHvd_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Casing_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Casing_Gas_.ambient_formation = ambient_formation_
    Set pipe_WHeadHsp_Tubing_.ambient_formation = ambient_formation_
End Sub
Private Function FindDegradation(ByVal plin_targ As Double, _
                                 ByVal pwf_atma As Double)
' функция для поиска значения деградации УЭЦН
' plin_targ  - целевое значение линейного давления
' pwf_atma   - забойное давление
'
' kESP = 1 - degr  поправочный коэффициент на насос
   Dim kESP1 As Double ', degr2 As Double
   Dim p_lin1 As Double ', p_lin2 As Double
   Dim kESP_Up As Double   ' верхняя граница значения деградации
   Dim kESP_Down As Double ' нижняя граница значения деградации
   Dim plin_Up As Double
   Dim plin_Down As Double
   Dim found_solution As Double
   Dim i As Integer
    Dim errmsg As String
On Error GoTo err1:
   i = 0
   ' first guess of cf cf=0
   curve(str_Pdisc_calibr_head_curve).ClearPoints
   isCalcCasing = False
   kESP1 = 1
   ' max cf
   kESP_Up = 10
   ESP.c_calibr_head = 1 - kESP_Up
   p_lin1 = calc_plin_pwf_atma(pwf_atma)
   curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP_Up
   ' check if high limit is ok
   If p_lin1 > plin_targ Then
       plin_Up = p_lin1
   Else
        errmsg = " CWellESP.FindDegradation: cf must be too high (more that 10 times) " & sDELIM & Err.Description
        GoTo err2:
        Exit Function
   End If
   kESP_Down = -10
   ESP.c_calibr_head = 1 - kESP_Down
   p_lin1 = calc_plin_pwf_atma(pwf_atma)
   curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP_Up
   ' check if low limit is ok
   If p_lin1 < plin_targ Then
       plin_Down = p_lin1
   Else
       errmsg = " CWellESP.FindDegradation: can't find correction. flow without pump" & sDELIM & Err.Description
       GoTo err2:
       Exit Function
   End If
   Do
       ESP.c_calibr_head = 1 - kESP1
       p_lin1 = calc_plin_pwf_atma(pwf_atma)
       curve(str_Pdisc_calibr_head_curve).AddPoint p_lin1, 1 - kESP1
       ' посмотрим если вдруг нашли решение то запомним его и завершим расчет
       If (Abs(p_lin1 - plin_targ) < const_well_P_tolerance) Then
            found_solution = True
            FindDegradation = ESP.c_calibr_head
            Exit Function
       End If
       If Not found_solution Then
          If p_lin1 > plin_targ Then
               ' если новое лин давление больше целевого - значит нашли нижнюю границу деградации - искомое значение должно быть больше
              kESP_Up = kESP1
              plin_Up = p_lin1
              If (plin_Down >= 0) And (plin_Down < plin_targ) Then
                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (plin_targ - plin_Down) / (plin_Up - plin_Down) '
              Else
                  kESP1 = kESP1 - 1
              End If
          Else
              kESP_Down = kESP1
              plin_Down = p_lin1
              If (plin_Up > 0) And (plin_Up > plin_targ) Then
                  kESP1 = (kESP_Up + kESP_Down) / 2 'kESP1 + (kESP_Up - kESP_Down) * (plin_targ - plin_Down) / (plin_Up - plin_Down) '
              Else
                  kESP1 = kESP1 + 1
              End If
          End If
        End If
       i = i + 1
   Loop While Not found_solution And i < 20
   Exit Function
err1:
    errmsg = " CWellESP.FindDegradation: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrDegradationError, Err.Source, errmsg
   Exit Function
err2:
    On Error GoTo 0
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrDegradationNotFound, Err.Source, errmsg
End Function
Private Sub calc_casing()
'  расчет параметров затрубного простраства скважины
'  должно быть задано давление на приеме - от которого проводится расчет снизу вверх
'                     и затрубное давление - от которого проводится расчет сверзу вниз
'  результат расчет - распределение давление и значение динамического уровня
    Dim PT_cas__temp As PTtype
    Dim p_PTintgas_temp As PTtype
    Dim p_PTcasgas_temp As PTtype
    Dim cas_crv As CInterpolation
    Dim num_Hd As Integer
    Dim H_dyn_m_ As Double
On Error GoTo err_casing:
        ' 1. Расчет расхода свободного газа двигающегося через затрубное пространство после сепарации
        ' для затруба считаем снизу вверх
        pipe_WHeadHsp_Casing_.param = set_calc_flow_param(calc_along_coord:=False, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
        PT_cas__temp = pipe_WHeadHsp_Casing_.calc_dPipe(PT_int_.p_atma, PT_int_.t_C, maincurves)
        ' 2. для затруба считаем распределение давления в газовом столбе сверху вниз
        pipe_WHeadHsp_Casing_Gas_.param = set_calc_flow_param(calc_along_coord:=True, _
                                             flow_along_coord:=True, _
                                             hcor:=gas, _
                                             temp_method:=temp_correlation)
        p_PTintgas_temp = pipe_WHeadHsp_Casing_Gas_.calc_dPipe(PT_cas_.p_atma, PT_cas_.t_C, maincurves)
        ' 3. найдем пересечение  распределений газа и жидкости в затрубе по давлению
        Set cas_crv = pipe_WHeadHsp_Casing_.p_curve.SubtractCurve(pipe_WHeadHsp_Casing_Gas_.p_curve)
        num_Hd = cas_crv.FindSolutions(0, TS_NO_EXTRPOLATION)  ' ищем количество пересечений
        ' 4. если пересечение одно, то все в порядке - это Ндин если значение хорошее
        If num_Hd = 1 Then
            H_dyn_m_ = cas_crv.SolutionPointX(1)
            Hdyn_Pcas_.correct = True
            Hdyn_Pcas_.pump_off_condition = False
            Hdyn_Pcas_.self_flow_condition = False
            ' проверяем, чтобы значение динамического уровня было разумным, иначе фиксируем крайние значения
            If H_dyn_m_ < 0 Then
                H_dyn_m_ = 0
                Hdyn_Pcas_.self_flow_condition = True
            ElseIf H_dyn_m_ >= h_sp_m_ Then
                H_dyn_m_ = h_sp_m_
                Hdyn_Pcas_.pump_off_condition = True
            End If
            ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
            Set curve("Pcas_Hd") = pipe_WHeadHsp_Casing_.p_curve.CutByCurve(pipe_WHeadHsp_Casing_Gas_.p_curve)
            Hdyn_Pcas_.hdyn_m = H_dyn_m_
            Hdyn_Pcas_.p_cas_atma = PT_cas_.p_atma
        ElseIf num_Hd = 0 Then
        ' 5. если пересечение найти не удалось - то фиксируем крайние значения
            
            Hdyn_Pcas_.correct = False
            Hdyn_Pcas_.pump_off_condition = False
            Hdyn_Pcas_.self_flow_condition = False
            pipe_WHeadHsp_Casing_Gas_.param = set_calc_flow_param(calc_along_coord:=False, _
                                                                  flow_along_coord:=False, _
                                                                  hcor:=gas, _
                                                                  temp_method:=temp_correlation)
            p_PTcasgas_temp = pipe_WHeadHsp_Casing_Gas_.calc_dPipe(PT_int_.p_atma, PT_int_.t_C, maincurves)
            If PT_cas_.p_atma >= p_PTcasgas_temp.p_atma Then
                H_dyn_m_ = h_sp_m_
                ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
                Set curve("Pcas_Hd") = pipe_WHeadHsp_Casing_Gas_.p_curve
                Hdyn_Pcas_.p_cas_atma = p_PTcasgas_temp.p_atma
                Hdyn_Pcas_.pump_off_condition = True
            Else
                H_dyn_m_ = 0
                ' готовим кривую распределения давления в затрубе из двух - для жидкости и для газа
                Set curve("Pcas_Hd") = pipe_WHeadHsp_Casing_.p_curve
                Hdyn_Pcas_.p_cas_atma = PT_cas_.p_atma
                Hdyn_Pcas_.self_flow_condition = True
            End If
            
            Hdyn_Pcas_.hdyn_m = H_dyn_m_
        Else
        '6. если пересечений не одно, то пытаемся применить устаревший алгоритм без учета плотности газа
            addLogMsg_debug "CWellESP.calc_plin_pwf_atma: abnormal casing behavior. Num of intersections =", num_Hd
            ' Если заданному затрубному давлению Pan соответствует отрицательный динамический уровень Hdyn,
            ' тогда ищется затрубное давление P(Hdyn=0)an соответствующее Hdyn=0 и данные значения сохраняются как результат
            Hdyn_Pcas_.correct = False
            Hdyn_Pcas_.pump_off_condition = False
            Hdyn_Pcas_.self_flow_condition = False
            If (PT_cas_.p_atma = 0 Or PT_cas_.p_atma >= PT_int_.p_atma) Then
                'p_p_an_atma = pipe_WHeadHsp_Casing_.p_curve.getPoint(0)
                H_dyn_m_ = h_sp_m_
                'PT_cas_.p_atma = PT_int_.p_atma
                Hdyn_Pcas_.p_cas_atma = PT_int_.p_atma
                Hdyn_Pcas_.pump_off_condition = True
            Else
                With pipe_WHeadHsp_Casing_.p_curve
                    H_dyn_m_ = .FindMinOneSolution(PT_cas_.p_atma)
                    Hdyn_Pcas_.p_cas_atma = PT_cas_.p_atma
                End With
            End If
            If (H_dyn_m_ < 0) Then
                H_dyn_m_ = 0
               ' PT_cas_.p_atma = pipe_WHeadHsp_Casing_.p_curve.getPoint(0)
                Hdyn_Pcas_.p_cas_atma = pipe_WHeadHsp_Casing_.p_curve.getPoint(0)
                Hdyn_Pcas_.pump_off_condition = True
            End If
            ' Если заданному затрубному давлению Pan соответствует динамический уровень Hdyn больше глубины спуска насоса Hpump, _
            ' тогда ищется затрубное давление P(Hdyn=Hpump)an соответствующее Hdyn=Hpump и данные значения сохраняются как результат
            If is_Hdyn_Larger_Hsp Then
                H_dyn_m_ = h_sp_m_
                PT_cas_.p_atma = pipe_WHeadHsp_Casing_.p_curve.getPoint(h_sp_m_)
            End If
            Set curve("Pcas_Hd") = pipe_WHeadHsp_Casing_.p_curve.CutByValue(H_dyn_m_)
            Hdyn_Pcas_.hdyn_m = H_dyn_m_
        End If
        '7. сохраним параметры для расчета распределения давления
        ambient_formation_.h_dyn_m = H_dyn_m_
        ambient_formation_.h_pump_m = h_sp_m_
        Call pipe_WHeadHsp_Tubing_.add_h_mes_save_m(H_dyn_m_)
    Exit Sub
err_casing:
    ' стандартная схема обработки ошибок
    Dim err_str As String
    err_str = "CWellESP.calc_casing: error in casing calculation. Pcas = " & S(PT_cas_.p_atma) & sDELIM & Err.Description
    addLogMsg err_str
    RaiseEvent ReportProgress(err_str)
    Err.Raise Err.Number, Err.Source, err_str
 End Sub
Private Sub add_crv(crv_name As String, _
                    crv_pipe_name As String, _
                    tub As Boolean, _
                    xnam As String, _
                    ynam As String, _
                    Optional crv_name2 As String)
    If crv_name2 = "" Then
        If tub Then
            Call curve(crv_name).AddPointsCurve(pipe_WHeadHsp_Tubing_.curve(crv_pipe_name), pipe_HspHvd_.curve(crv_pipe_name))
        Else
            Call curve(crv_name).AddPointsCurve(pipe_WHeadHsp_Casing_.curve(crv_pipe_name), pipe_HspHvd_.curve(crv_pipe_name))
        End If
    Else
        Call curve(crv_name).AddPointsCurve(pipe_WHeadHsp_Casing_.curve(crv_name2), pipe_HspHvd_.curve(crv_pipe_name))
    End If
    curve(crv_name).xName = xnam
    curve(crv_name).yName = ynam
    
End Sub
 Private Sub save_curves(saveCurve As CALC_RESULTS)
 On Error GoTo err1:
    If saveCurve > 0 Then
        add_crv "c_udl_m", "c_udl_m", tub:=True, xnam:="hmes_m", ynam:="h_vert_m"
        add_crv str_PtubHmes_curve, "c_P", tub:=True, xnam:="hmes_m", ynam:="p_tub_atma"
        add_crv str_TtubHmes_curve, "c_T", tub:=True, xnam:="hmes_m", ynam:="t_tub_C"
        add_crv str_TambHmes_curve, "c_Tamb", tub:=True, xnam:="hmes_m", ynam:="t_amb_C"
        add_crv str_PcasHmes_curve, "c_P", tub:=False, xnam:="hmes_m", ynam:="p_cas_atma"
        add_crv "Pcas_Hd", "c_P", tub:=False, xnam:="hmes_m", ynam:="p_cas_atma", crv_name2:="Pcas_Hd"
        
        add_crv "c_Diam", "c_Diam", tub:=False, xnam:="hmes_m", ynam:="c_Diam"
        add_crv "c_Roughness", "c_Roughness", tub:=False, xnam:="hmes_m", ynam:="c_Roughness"
        add_crv "c_Theta", "c_Theta", tub:=False, xnam:="hmes_m", ynam:="c_Theta"
        
        If saveCurve > 1 Then
            add_crv str_HlHmes_curve, "c_Hl", tub:=True, xnam:="hmes_m", ynam:="Hl_tub"
            add_crv str_HLcasHmes_curve, "c_Hl", tub:=False, xnam:="hmes_m", ynam:="Hl_cas"
            
            add_crv "c_fpat", "c_fpat", tub:=True, xnam:="hmes_m", ynam:="c_fpat"
            add_crv "c_Rs", "c_Rs", tub:=True, xnam:="hmes_m", ynam:="c_Rs"
            add_crv "c_gasfrac", "c_gasfrac", tub:=True, xnam:="hmes_m", ynam:="c_gasfrac"
            
            add_crv "c_dpdl_g", "c_dpdl_g", tub:=True, xnam:="hmes_m", ynam:="c_dpdl_g"
            add_crv "c_dpdl_f", "c_dpdl_f", tub:=True, xnam:="hmes_m", ynam:="c_dpdl_f"
            add_crv "c_dpdl_a", "c_dpdl_a", tub:=True, xnam:="hmes_m", ynam:="c_dpdl_a"
            add_crv "c_vsl", "c_vsl", tub:=True, xnam:="hmes_m", ynam:="c_vsl"
            add_crv "c_vsg", "c_vsg", tub:=True, xnam:="hmes_m", ynam:="c_vsg"
            add_crv "c_muo", "c_muo", tub:=True, xnam:="hmes_m", ynam:="c_muo"
            add_crv "c_muw", "c_muw", tub:=True, xnam:="hmes_m", ynam:="c_muw"
            add_crv "c_mug", "c_mug", tub:=True, xnam:="hmes_m", ynam:="c_mug"
            add_crv "c_mumix", "c_mumix", tub:=True, xnam:="hmes_m", ynam:="c_mumix"
            
        End If
    End If
     Exit Sub
err1:
    Dim errmsg As String
    errmsg = "CWellESP.save_curves: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
 End Sub
 Private Function fast_pwf_plin_atma( _
                         plin_atma As Double, _
                         ByVal t_bh_C As Double, _
                Optional saveCurve As CALC_RESULTS = nocurves _
                                    )
'@brief  быстрый метод расчета забойного давления через линейное (без итераций - прямой счет)
'         считает за один проход, за счет дополнительных упрощений и предположений
'@param plin_atma  линейное давление
'@param t_bh_C      температура на забое
'@param saveCurve  флаг показывает - что сохранять в качестве результатов
'       для уточнения оценки сепарации флюида желательно задать
'       оценочные значения давления и температуры на приеме УЭЦН p_int_atma t_int_C для объекта расчета
'       расчет температуры по заданной извне температурной корреляции, которая должны быть простой
On Error GoTo err1:
    If temp_correlation = AmbientTemp Then
        temp_correlation = GeoGradTemp
    End If
    ' 1. если есть ЭЦН пытаемся оценить сепарацию и модификацию флюида на основе предполагаемого давления на приеме насоса
    If ESP_on Then
        Call ESP.calc_separation(p_int_atma, t_int_C)
        Set pipe_WHeadHsp_Tubing_.fluid = ESP.fluid_tub
        If choke.d_choke_m > 0 Then Set choke.fluid = ESP.fluid_tub
    End If
    ' 2. фиксируем заданные линейные давления
    PT_lin_.p_atma = plin_atma
    PT_lin_.t_C = t_wh_C
    ' 3. Расчет буферного давления по штуцеру
    If choke.d_choke_m > 0 Then
        PT_buf_ = choke.calc_choke_p_buf(PT_lin_)
        If PT_buf_.p_atma < 0 Then PT_buf_.p_atma = 1
    Else
        PT_buf_ = PT_lin_
    End If
    ' 4. Расчет давления на выкиде по буферному
    pipe_WHeadHsp_Tubing_.param = set_calc_flow_param(calc_along_coord:=True, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    PT_dis_ = pipe_WHeadHsp_Tubing_.calc_dPipe(PT_buf_.p_atma, PT_buf_.t_C, saveCurve)
    ' 5. если есть ЭЦН то считаем давление на приеме по давлению на выкиде сверху вниз
    If ESP_on Then                                                 ' Если есть насос
        ' расчитываются параметры насоса включая сепарацию и модификацию флюидов
        Call ESP.calc_ESPsys(PT_dis_.p_atma, calc_along_flow:=False)
        PT_int_ = SetPT(ESP.ESP_pump.p_int_atma, ESP.ESP_pump.t_int_C)
    Else                                                            ' Если насоса нет, то совпадают
        PT_int_ = PT_dis_
    End If
    ' 6. По давлению на приеме считаем забойное давление
    pipe_HspHvd_.param = set_calc_flow_param(calc_along_coord:=True, _
                                             flow_along_coord:=False, _
                                             hcor:=hydraulic_correlation, _
                                             temp_method:=temp_correlation)
    PT_wf_ = pipe_HspHvd_.calc_dPipe(PT_int_.p_atma, PT_int_.t_C, saveCurve)
    fast_pwf_plin_atma = PT_wf_.p_atma
    ' 7. если надо считаем затруб
    Dim PT_cas__temp As PTtype
    If isCalcCasing And pcas_atma >= 1 Then
        Call calc_casing
    End If
    Call save_curves(saveCurve)
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.fast_pwf_plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Private Function slow_pwf_plin_atma(ByVal plin_atma As Double, _
                                        ByVal t_bh_C As Double, _
                                        Optional saveCurve As CALC_RESULTS = nocurves)
' @brief calc_pwf_plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
' @param plin_atma - давление в линии
' @param Hd - динамический уровень
' @param t_bh_C - температура на забое скважины
' @return Подсчитанное для заданного линейного давление
On Error GoTo err1:
    Dim p_wf1 As Double      ' первое приближение
    Dim p_wfUp As Double, p_wfDown As Double
    Dim p_linUp As Double, p_linDown As Double
    Dim p_lin0 As Double, p_lin1 As Double
    Dim found_solution As Boolean
    Dim i As Integer
    found_solution = False
    i = 0
    p_wf1 = 60
    p_wfUp = -1
    p_wfDown = -1
    Do
        ' ищем  приближения
        p_lin1 = calc_plin_pwf_atma(p_wf1, saveCurve:=nocurves)
        If (Abs(p_lin1 - plin_atma) < const_well_P_tolerance) Then
             found_solution = True
             PT_wf_.p_atma = p_wf1
             PT_wf_.t_C = t_bh_C
        End If
        If Not found_solution Then
          If p_lin1 > plin_atma Then
              p_wfUp = p_wf1
              p_linUp = p_lin1
              If p_wfDown < 0 Then
                  p_wf1 = p_wfUp / 2
              Else
                  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
              End If
          Else
              p_wfDown = p_wf1
              p_linDown = p_lin1
              If p_wfUp < 0 Then
                  p_wf1 = p_wf1 * 2
              Else
                  p_wf1 = (p_wfUp + p_wfDown) / 2
                '  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
              End If
          End If
        End If
        i = i + 1
    Loop While Not found_solution And i < 20
    ' calc more one time to restore all what needed
    PT_lin_.p_atma = calc_plin_pwf_atma(PT_wf_.p_atma, saveCurve:=saveCurve)
    If Abs(Me.p_line_atma - plin_atma) > const_well_P_tolerance Then
       addLogMsg "calc_pwf_plin_atma: ошибка расчета забойного давления больше " & const_well_P_tolerance & ". Равна = " & Abs(Me.p_line_atma - plin_atma)
    End If
    slow_pwf_plin_atma = PT_wf_.p_atma
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.slow_pwf_plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
 End Function
Public Function calc_pwf_pcas_hdyn_atma(ByVal p_an_atma As Double, ByVal Hd_m As Double, ByVal t_bh_C As Double) As PTtype
' @brief calc_pwf_pcas_hdyn_atma - расчет забойного давления через динамический уровень
' @param Pan - затрубное давление
' @param Hd - динамический уровень
' @param t_bh_C - температура на забое скважины
' @return Подсчитанное для заданного динамического уровня давление
On Error GoTo err1:
    Set curve(str_Hd_Depend_p_wf) = Build_Hdp_wfcurve(p_an_atma, t_bh_C)
    ' 3. По построенной кривой находим значение забойного давления соответствующее заданному динамическому уровню
    PT_wf_.p_atma = curve(str_Hd_Depend_p_wf).FindMinOneSolution(Hd_m)
    ' 4. Для обеспечение целостности данных по скважине проводим расчет распределения давления по скважине для найденного забойного давления
    ' расчет давления на устье через забойное давление
    Call calc_plin_pwf_atma(PT_wf_.p_atma)
    PT_cas_.p_atma = p_an_atma
   ' Me.h_dyn_m = Hd_m
    calc_pwf_pcas_hdyn_atma = PT_wf_
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.slow_pwf_plin_atma: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Private Function is_Hdyn_Larger_Hsp() As Boolean
' Динамический уровень Hdyn больше глубины спуска насоса Hpump,
    is_Hdyn_Larger_Hsp = ESP_on And Hdyn_Pcas_.hdyn_m > h_sp_m_
End Function
Public Function Build_Pwhp_wfcurve( _
                Optional ByVal p_linMax As Double = -1, _
                Optional ByVal p_wf1_atma As Double = -1, _
                Optional ByVal Pstep As Integer = DEFAULT_PAN_STEP, _
                Optional ByVal calcFast As Boolean = False _
                                 ) As CInterpolation
' @brief Build_Pwhp_wfcurve построение кривой зависимости буферного и линейного давлений на скважине от забойного давления
'               на кривой есть две особые точки, на которых теряется гладкость
'                   1 - там где буферное давление становится больше нуля (граница работы скважины по забойному)
'                   2 - там где линейное давление становится больше нуля
'               эти точки ищутся более точным алгоритмом для правильной отрисовки графика
' @param p_linMax - ограничение величины линейного давления определяющее границы построения кривой
' @param p_wf1_atma - значение забойного давления, которое останется после проведения расчета
' @param Pstep  - шаг поиска значений
' @param calcFast - флаг показывающий насколько точно надо строить кривую (влияет на поиск пересечений с нулем)
    Dim pwf_temp As Double
    Dim P_step As Double
    Dim processing As Boolean
    Dim pwf_temp1 As Double ' забойное давление минимальное с которого надо начинать поиск
    Dim pwf_temp_old As Double
    Dim pwf_temp_new As Double
    Dim iter  As Integer
    Dim p_wfmin_atma As Double   ' временная переменная для хранения минимального забойного давления с которого надо начинать поиск зайбоного давления
On Error GoTo err1:
    p_wfmin_atma = 1
    If (p_linMax < 0) And (p_line_atma > 0) Then
        p_linMax = p_line_atma
    End If
    If p_wf1_atma < 0 Then
        p_wf1_atma = pwf_atma
    End If
    ' 1. Начало расчета. Заданы линейное давление p_line,
    '    Температура на забое скважины Tbh определяется температурной моделью
    P_step = Pstep
    ' 2. Строим графическую зависимость линейного давления от забойного давления для заданных параметров скважины
    curve(str_plin_Depend_p_wf).ClearPoints
    curve(str_pbuf_pwf_curve).ClearPoints
    processing = True
    isCalcCasing = False
    pwf_temp = p_wfmin_atma     ' здесь надо получше выбирать начальное приближения для расчета для ускорения
    Do
        pwf_temp = pwf_temp + P_step
        PT_lin_.p_atma = calc_plin_pwf_atma(pwf_temp)
        If (pbuf_atma > const_minPpipe_atma) Then    ' вышли в область больших буферных давлений
            If curve(str_pbuf_pwf_curve).num_points = 0 Then  ' первый раз тут - ищем поточнее начало
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
                pwf_temp_old = pwf_temp - P_step
                pwf_temp_new = pwf_temp
                iter = 1
                ' надо точнее искать точку если нет противопоказаний
                While (pbuf_atma > const_minPpipe_atma * 1.1) And processing And Not calcFast
                    pwf_temp = (pwf_temp_old + pwf_temp_new) / 2
                    PT_lin_.p_atma = calc_plin_pwf_atma(pwf_temp)
                    If pbuf_atma > const_minPpipe_atma Then
                        pwf_temp_new = pwf_temp
                    Else
                        pwf_temp_old = pwf_temp
                    End If
                    iter = iter + 1
                    If iter > 10 Then processing = False
                Wend
                If processing = False Then
                     PT_lin_.p_atma = 0
                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
                     addLogMsg "Build_Pwhp_wfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости ,буферного давления от забойного. p_wf = " _
                                                    & pwf_temp & " итераций = " & iter & " дебит = " & qliq_sm3day & " Рбуф = " & pbuf_atma
                End If
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
            End If
            Pstep = DEFAULT_PAN_STEP / 3
        Else
            p_wfmin_atma = pwf_temp
        End If
        
        If (p_line_atma > -1) And (Not isEqual(p_line_atma, pbuf_atma)) Then      ' вышли в область больших линейных давлений
            If curve(str_plin_Depend_p_wf).num_points = 0 Then   ' первый раз тут - ищем поточнее начало
                pwf_temp_old = pwf_temp - P_step
                pwf_temp_new = pwf_temp
                iter = 1
                While (p_line_atma <> 0) And processing And Not calcFast  ' Then   ' надо точнее искать точку
                    pwf_temp = (pwf_temp_old + pwf_temp_new) / 2
                    isCalcCasing = False
                    PT_lin_.p_atma = calc_plin_pwf_atma(pwf_temp)
                    If p_line_atma > 0 Then
                        pwf_temp_new = pwf_temp
                    Else
                        pwf_temp_old = pwf_temp
                    End If
                    iter = iter + 1
                    If iter > 20 Then processing = False
                    If (p_line_atma >= 0) Then                          ' если ставить точки слишком часто - тогда проявляются неустойчивости - может надо будет сделать прореживание
                        curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
                        curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
                    End If
                Wend
                If p_line_atma <> 0 Then
                     PT_lin_.p_atma = 0
                     ' здесь нет  ошибки - определена достаточно корректна стартовая точка кривой тут
                     addLogMsg "Build_Pwhp_wfcurve: Предупреждение: не сошлась итерация по поиску начала графика зависимости линейного давления от забойного. p_wf = " _
                                                    & pwf_temp & " итераций = " & iter & " дебит = " & qliq_sm3day & " Рбуф = " & pbuf_atma
                End If
                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
            End If
        Else
            If isEqual(p_line_atma, pbuf_atma) And (p_line_atma > 1) Then
                curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
                curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
            End If
        End If
        If p_line_atma > 1 Then
           curve(str_plin_Depend_p_wf).AddPoint pwf_temp, p_line_atma
           curve(str_pbuf_pwf_curve).AddPoint pwf_temp, pbuf_atma
        End If
        ' ждем пока кривая перечеркнет уровень целевого линейного давления
    Loop While (p_line_atma < p_linMax + 10) Or (curve(str_plin_Depend_p_wf).num_points < MinCountPoints_calc_pwf_pcas_hdyn_atma)
    isCalcCasing = True
    PT_lin_.p_atma = calc_plin_pwf_atma(p_wf1_atma)
    Set Build_Pwhp_wfcurve = curve(str_plin_Depend_p_wf)
    Exit Function
err1:
    Dim errmsg As String
    errmsg = "CWellESP.Build_Pwhp_wfcurve: ошибка" & sDELIM & Err.Description
    addLogMsg errmsg
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Function
Public Function Build_Hdp_wfcurve(p_an_atma As Double, t_bh_C As Double, Optional p_wf1_atma As Double = -1) As CInterpolation
' расчет зависимости динамического уровня от забойного давления для заданных условий
' @brief Build_Hdp_wfcurve - расчет забойного давления через динамический уровень
' @param Pan - затрубное давление
' @param t_bh_C - температура на забое скважины
' @return Подсчитанное для заданного динамического уровня давление
  On Error GoTo er1:
    Dim pwf_temp As Double
    Dim plin_temp As Double
    Dim P_step As Double
    Dim processing As Boolean
    Dim HdAtIntake As Boolean, Panold As Double
    Dim p_wfold As Double, p_wfold1 As Double
    Dim Hdold As Double
    Dim itr As Integer, itr2 As Integer, itr3 As Integer
    Dim Hdpump As Double
    If p_an_atma <= 0 Then
        addLogMsg "CWellESP.Build_Hdp_wfcurve: попытка построить график динамического уровня от забойного давления при затрубном давлении =" & p_an_atma
        Exit Function
    End If
    ' 1. Начало расчета. Заданы затрубное давление Pan, динамический уровень Hdyn, температура на забое скважины Tbh
  '  p_an_atma = p_an_atma
  '  t_bh_C_ = t_bh_C
    P_step = DEFAULT_PAN_STEP '/ 3
    ' 2. Строим графическую зависимость динамического уровня от забойного давления для заданных параметров скважины
    curve(str_Hd_Depend_p_wf).ClearPoints
    processing = True
    If p_wf1_atma < 0 Then
        p_wf1_atma = pwf_atma
    End If
    HdAtIntake = False
    itr3 = 0
    Do
       pwf_temp = p_an_atma
       itr2 = 0
       Do
            PT_cas_.p_atma = p_an_atma
            isCalcCasing = True
            plin_temp = calc_plin_pwf_atma(pwf_temp)
            If Me.p_an_atma < p_an_atma Then
            ' уровень на приеме - надо найти точно точку начала слома
                HdAtIntake = True
                Panold = Me.p_an_atma
                p_wfold = pwf_temp
                Hdold = Hdyn_Pcas_.hdyn_m
                Hdpump = Hdyn_Pcas_.hdyn_m
            Else
            ' вышли в зону где уровень выше приема насоса
                If HdAtIntake And Abs(Hdold - Hdyn_Pcas_.hdyn_m) > 10 Then
                    ' погрешность около точки слома по дин уровню больше 10 метров - надо уточнить лучше
                    p_wfold1 = pwf_temp
                    itr = 0
                    Do
                        itr = itr + 1
                        pwf_temp = (p_wfold1 + p_wfold) / 2
                        PT_cas_.p_atma = p_an_atma
                        isCalcCasing = True
                        plin_temp = calc_plin_pwf_atma(pwf_temp)
                        If Hdyn_Pcas_.hdyn_m = Hdpump Then
                            HdAtIntake = True
                            Panold = Me.p_an_atma
                            p_wfold = pwf_temp
                            Hdold = Hdyn_Pcas_.hdyn_m
                        Else
                            p_wfold1 = pwf_temp
                        End If
                    Loop While ((Abs(Hdpump - Hdyn_Pcas_.hdyn_m) > 10) Or Abs(p_an_atma - Me.p_an_atma) > 2) And itr < 10 '
                End If
'                Debug.Assert itr < 10
                itr = 0
                HdAtIntake = False ' сбросим флаг, что нашли точку слома
            End If
            curve(str_Hd_Depend_p_wf).AddPoint pwf_temp, Hdyn_Pcas_.hdyn_m
            curve(str_Pan_Depend_p_wf).AddPoint pwf_temp, p_an_atma
            pwf_temp = pwf_temp + P_step
'            Debug.Assert pwf_temp < 300
            itr2 = itr2 + 1
        Loop While (Not is_Hdyn_Larger_Hsp And Hdyn_Pcas_.hdyn_m > 0) And (itr2 < 100)
        ' проверка условий продолжения цикла
        If (curve(str_Hd_Depend_p_wf).num_points >= MinCountPoints_calc_pwf_pcas_hdyn_atma) Then
            processing = False
        Else
            curve(str_Hd_Depend_p_wf).ClearPoints
            P_step = P_step / 2
            ' проверка корректности. Если шаг слишком мелкий при этом точек решения мало - то это не здоровая ситуация - надо показать ее
            If P_step < 0.01 Then
                addLogMsg "CWellESP.Build_Hdp_wfcurve: Не удалось построить кривую зависимости динамического уровня от забойного давления. шаг перебора точек менее 0.01 атм"
                Err.Raise kErrBuildCurve, , "CWellESP.Build_Hdp_wfcurve нет получается построить кривую - мелкий шаг получился"
            End If
        End If
        itr3 = itr3 + 1
    Loop While (processing) And (itr3 < 5)
    'восстановим после расчета необходимое распределение в скважине
    PT_cas_.p_atma = p_an_atma
    isCalcCasing = True
    plin_temp = calc_plin_pwf_atma(p_wf1_atma)
    Set Build_Hdp_wfcurve = curve(str_Hd_Depend_p_wf)
   ' переводим в состояние "целостность нарушена"
  '  p_Calculated = False
    Exit Function
er1:
  ' Debug.Assert False
   Resume Next
End Function
Public Function Build_VLPcurve(p_line As Double, ByVal t_bh_C As Double, Optional maxQ As Double = 200, Optional Qnow As Double = -1) As CInterpolation
' расчет кривой лифта
' на выходе с расчета кривая лифта заданная в определенном формате кривой
'
    PT_lin_.p_atma = p_line
    Const VLPNumPoints = 20
    Dim i As Integer
    Dim Qstep As Double
    Dim p_wf As Double
    Dim Qliq_reserv As Double
    Qliq_reserv = qliq_sm3day
    Qstep = maxQ / VLPNumPoints
    RaiseEvent ReportProgress("Build_VLPcurve. Начинаем строить кривую оттока. Точек =   " & VLPNumPoints)
    For i = 0 To VLPNumPoints
        qliq_sm3day = i * Qstep
        p_wf = calc_pwf_plin_atma(p_line, t_bh_C)
        curve(str_VLPcurve).AddPoint qliq_sm3day, p_wf
        ' поднимем наверх событие по поводу длительного расчета
        RaiseEvent ReportProgress("Build_VLPcurve   i= " & i & " из " & VLPNumPoints)
    Next i
    ' вернем состояние скважины в исходное значение
    If Qnow = -1 Then
        Qnow = maxQ * 1.1
    End If
    qliq_sm3day = Qnow
    p_wf = calc_pwf_plin_atma(p_line, t_bh_C)
    curve(str_VLPcurve).AddPoint qliq_sm3day, p_wf
    Set Build_VLPcurve = curve(str_VLPcurve)
End Function
Property Get VLPCurve() As CInterpolation
  Set VLPCurve = curve(str_VLPcurve)
End Property
Public Property Get ksep_total_d() As Double
   If ESP_on Then
       ksep_total_d = ESP.ksep_total_fr
   Else
       ksep_total_d = 0
   End If
End Property
Public Sub Setksep_total_d(calc_method As SEPAR_CALC_METHOD, ksep_nat_fr As Double, _
                          Optional KsepGS_fr As Double = 0, _
                          Optional p_ksep_atma As Double = -1, _
                          Optional t_ksep_C As Double = -1)
   ' установка значения коэффициента сепарации извне
   ' если значение равно = -1 то расчет по корреляции
   ' если задано какое то значение, то оно будет использовано в расчете
   ' если заданы значения давления и температуры, то они будут использоваться в расчете
    Call ESP.setksep_total(calc_method, ksep_nat_fr, KsepGS_fr, p_ksep_atma, t_ksep_C)
End Sub
' ======================================================================
' Iwell implementation
' ======================================================================
Private Function IWell_CalcDown(p_line_atma As Double, _
                                twf_C As Double, _
                       Optional saveCurve As CALC_RESULTS = 0&) As Double
    IWell_CalcDown = calc_pwf_plin_atma(p_line_atma, twf_C, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcUp(pwf_atma As Double, _
                              twf_C As Double, _
                    Optional saveCurve As CALC_RESULTS = 0&) As Double
    IWell_CalcUp = calc_plin_pwf_atma(pwf_atma, twf_C, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcWell(pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
End Function
Private Property Get IWell_cfBettaFric() As Double
    IWell_cfBettaFric = c_calibr_fric
End Property
Private Property Get IWell_cfBettaGrav() As Double
    IWell_cfBettaGrav = c_calibr_grav
End Property
Private Property Get IWell_cfESP() As Double
    IWell_cfESP = ESP.c_calibr_head
    ' пока учитывается только по напору
    ' наверное потом надо будет добавить по дебиту и по мощности как то
End Property
Private Property Get IWell_cfFw() As Double
    IWell_cfFw = 0
End Property
Private Property Get IWell_cfGLinj() As Double
    IWell_cfGLinj = 0
End Property
Private Property Get IWell_cfRp() As Double
    IWell_cfRp = 0
End Property
Private Property Get IWell_Choke() As Cchoke
    Set IWell_Choke = choke
End Property
Private Property Get IWell_curve() As CCurves
    Set IWell_curve = curve
End Property
Private Property Get IWell_ESP() As CESPsystemSimple
    Set IWell_ESP = ESP_
End Property
Private Property Get IWell_fluid() As CPVT
    Set IWell_fluid = fluid
End Property
Private Property Get IWell_fw() As Double
    IWell_fw = fluid.fw_perc
End Property
Private Property Get IWell_GLVset() As CGLValveSet
    Set IWell_GLVset = Nothing
End Property
Private Property Get IWell_HdynPcas() As PCAS_HDYN_type
    IWell_HdynPcas = Hdyn_Pcas_
End Property
Private Property Get IWell_isESP() As Boolean
    IWell_isESP = ESP_on
End Property
Private Property Get IWell_isGL() As Boolean
    IWell_isGL = False
End Property
Private Property Get IWell_PTbuf() As PTtype
    IWell_PTbuf = PT_buf_
End Property
Private Property Get IWell_PTcas() As PTtype
    IWell_PTcas = PT_cas_
End Property
Private Property Get IWell_PTdis() As PTtype
    IWell_PTdis = PT_dis_
End Property
Private Property Get IWell_PTintake() As PTtype
    IWell_PTintake = PT_int_
End Property
Private Property Get IWell_PTline() As PTtype
    IWell_PTline = PT_lin_
End Property
Private Property Get IWell_PTwf() As PTtype
    IWell_PTwf = PT_wf_
End Property
Private Property Get IWell_Qgas() As Double
    IWell_Qgas = fluid.q_gas_sm3day
End Property
'Private Property Get IWell_Pwh() As Double
'    IWell_Pwh = PT_buf_.p_atma
'End Property
Private Property Get IWell_Qgascas() As Double
    IWell_Qgascas = 0
End Property
Private Property Get IWell_Qgasinj() As Double
    IWell_Qgasinj = 0
End Property
Private Property Let IWell_Qliq(RHS As Double)
    fluid.qliq_sm3day = RHS
End Property
Private Property Get IWell_Qliq() As Double
    IWell_Qliq = fluid.qliq_sm3day
End Property

