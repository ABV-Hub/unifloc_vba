''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LU decomposition of a general real matrix with row pivoting
'
'A is represented as A = P*L*U, where:
'* L is lower unitriangular matrix
'* U is upper triangular matrix
'* P = P0*P1*...*PK, K=min(M,N)-1,
'  Pi - permutation matrix for I and Pivots[I]
'
'This is cache-oblivous implementation of LU decomposition.
'It is optimized for square matrices. As for rectangular matrices:
'* best case - M>>N
'* worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'INPUT PARAMETERS:
'    A       -   array[0..M-1, 0..N-1].
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'
'OUTPUT PARAMETERS:
'    A       -   matrices L and U in compact form:
'                * L is stored under main diagonal
'                * U is stored on and above main diagonal
'    Pivots  -   permutation matrix in compact form.
'                array[0..Min(M-1,N-1)].
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLU(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Call RMatrixPLU(A, M, N, Pivots)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LU decomposition of a general complex matrix with row pivoting
'
'A is represented as A = P*L*U, where:
'* L is lower unitriangular matrix
'* U is upper triangular matrix
'* P = P0*P1*...*PK, K=min(M,N)-1,
'  Pi - permutation matrix for I and Pivots[I]
'
'This is cache-oblivous implementation of LU decomposition. It is optimized
'for square matrices. As for rectangular matrices:
'* best case - M>>N
'* worst case - N>>M, small M, large N, matrix does not fit in CPU cache
'
'INPUT PARAMETERS:
'    A       -   array[0..M-1, 0..N-1].
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'
'OUTPUT PARAMETERS:
'    A       -   matrices L and U in compact form:
'                * L is stored under main diagonal
'                * U is stored on and above main diagonal
'    Pivots  -   permutation matrix in compact form.
'                array[0..Min(M-1,N-1)].
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLU(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Call CMatrixPLU(A, M, N, Pivots)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivious Cholesky decomposition
'
'The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
'definite matrix. The result of an algorithm is a representation  of  A  as
'A=U'*U  or A=L*L' (here X' detones conj(X^T)).
'
'INPUT PARAMETERS:
'    A       -   upper or lower triangle of a factorized matrix.
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                a symmetric matrix, otherwise A contains a lower one.
'
'OUTPUT PARAMETERS:
'    A       -   the result of factorization. If IsUpper=True, then
'                the upper triangle contains matrix U, so that A = U'*U,
'                and the elements below the main diagonal are not modified.
'                Similarly, if IsUpper = False.
'
'RESULT:
'    If  the  matrix  is  positive-definite,  the  function  returns  True.
'    Otherwise, the function returns False. Contents of A is not determined
'    in such case.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function HPDMatrixCholesky(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Tmp() As Complex
    If N < 1# Then
        Result = False
        HPDMatrixCholesky = Result
        Exit Function
    End If
    ReDim Tmp(0 To 2# * N - 1)
    Result = HPDMatrixCholeskyRec(A, 0#, N, IsUpper, Tmp)
    HPDMatrixCholesky = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cache-oblivious Cholesky decomposition
'
'The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
'definite matrix. The result of an algorithm is a representation  of  A  as
'A=U^T*U  or A=L*L^T
'
'INPUT PARAMETERS:
'    A       -   upper or lower triangle of a factorized matrix.
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   if IsUpper=True, then A contains an upper triangle of
'                a symmetric matrix, otherwise A contains a lower one.
'
'OUTPUT PARAMETERS:
'    A       -   the result of factorization. If IsUpper=True, then
'                the upper triangle contains matrix U, so that A = U^T*U,
'                and the elements below the main diagonal are not modified.
'                Similarly, if IsUpper = False.
'
'RESULT:
'    If  the  matrix  is  positive-definite,  the  function  returns  True.
'    Otherwise, the function returns False. Contents of A is not determined
'    in such case.
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function SPDMatrixCholesky(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean) As Boolean
    Dim Result As Boolean
    Dim Tmp() As Double
    If N < 1# Then
        Result = False
        SPDMatrixCholesky = Result
        Exit Function
    End If
    ReDim Tmp(0 To 2# * N - 1)
    Result = SPDMatrixCholeskyRec(A, 0#, N, IsUpper, Tmp)
    SPDMatrixCholesky = Result
End Function
Public Sub RMatrixLUP(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Double
    Dim i As Long
    Dim J As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For J = 0# To N - 1# Step 1
            MX = MaxReal(MX, Abs(A(i, J)))
        Next J
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
    ReDim Pivots(0 To MinInt(M, N) - 1)
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    Call RMatrixLUPRec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To MinInt(i, N - 1#) Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
End Sub
Public Sub CMatrixLUP(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Complex
    Dim i As Long
    Dim J As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For J = 0# To N - 1# Step 1
            MX = MaxReal(MX, AbsComplex(A(i, J)))
        Next J
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = C_MulR(A(i, i_), V)
            Next i_
        Next i
    End If
    ReDim Pivots(0 To MinInt(M, N) - 1)
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    Call CMatrixLUPRec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To MinInt(i, N - 1#) Step 1
                A(i, i_) = C_MulR(A(i, i_), V)
            Next i_
        Next i
    End If
End Sub
Public Sub RMatrixPLU(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Double
    Dim i As Long
    Dim J As Long
    Dim MX As Double
    Dim V As Double
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    ReDim Pivots(0 To MinInt(M, N) - 1)
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For J = 0# To N - 1# Step 1
            MX = MaxReal(MX, Abs(A(i, J)))
        Next J
    Next i
    If MX <> 0# Then
        V = 1# / MX
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
    Call RMatrixPLURec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = MX
        For i = 0# To MinInt(M, N) - 1# Step 1
            For i_ = i To N - 1# Step 1
                A(i, i_) = V * A(i, i_)
            Next i_
        Next i
    End If
End Sub
Public Sub CMatrixPLU(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long)
    Dim Tmp() As Complex
    Dim i As Long
    Dim J As Long
    Dim MX As Double
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' Internal LU decomposition subroutine.
    ' Never call it directly.
    '
    ReDim Tmp(0 To 2# * MaxInt(M, N) - 1)
    ReDim Pivots(0 To MinInt(M, N) - 1)
    
    '
    ' Scale matrix to avoid overflows,
    ' decompose it, then scale back.
    '
    MX = 0#
    For i = 0# To M - 1# Step 1
        For J = 0# To N - 1# Step 1
            MX = MaxReal(MX, AbsComplex(A(i, J)))
        Next J
    Next i
    If MX <> 0# Then
        V = C_Complex(1# / MX)
        For i = 0# To M - 1# Step 1
            For i_ = 0# To N - 1# Step 1
                A(i, i_) = C_Mul(V, A(i, i_))
            Next i_
        Next i
    End If
    Call CMatrixPLURec(A, 0#, M, N, Pivots, Tmp)
    If MX <> 0# Then
        V = C_Complex(MX)
        For i = 0# To MinInt(M, N) - 1# Step 1
            For i_ = i To N - 1# Step 1
                A(i, i_) = C_Mul(V, A(i, i_))
            Next i_
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent complex LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUPRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim M1 As Long
    Dim M2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASComplexBlockSize(A) Then
        Call CMatrixLUP2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make N>=M
    '
    '     ( A1 )
    ' A = (    ), where A1 is square
    '     ( A2 )
    '
    ' Factorize A1, update A2
    '
    If M > N Then
        Call CMatrixLUPRec(A, Offs, N, N, Pivots, Tmp)
        For i = 0# To N - 1# Step 1
            i1_ = (Offs + N) - (0#)
            For i_ = 0# To M - N - 1# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + i)
            Next i_
            For i_ = Offs + N To Offs + M - 1# Step 1
                A(i_, Offs + i) = A(i_, Pivots(Offs + i))
            Next i_
            i1_ = (0#) - (Offs + N)
            For i_ = Offs + N To Offs + M - 1# Step 1
                A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
            Next i_
        Next i
        Call CMatrixRightTRSM(M - N, N, A, Offs, Offs, True, True, 0#, A, Offs + N, Offs)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASComplexSplitLength(A, M, M1, M2)
    Call CMatrixLUPRec(A, Offs, M1, N, Pivots, Tmp)
    If M2 > 0# Then
        For i = 0# To M1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + M1) - (0#)
                For i_ = 0# To M2 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Offs + i) = A(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + M1)
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call CMatrixRightTRSM(M2, M1, A, Offs, Offs, True, True, 0#, A, Offs + M1, Offs)
        Call CMatrixGEMM(M - M1, N - M1, M1, C_Complex(-1#), A, Offs + M1, Offs, 0#, A, Offs, Offs + M1, 0#, C_Complex(1#), A, Offs + M1, Offs + M1)
        Call CMatrixLUPRec(A, Offs + M1, M - M1, N - M1, Pivots, Tmp)
        For i = 0# To M2 - 1# Step 1
            If Offs + M1 + i <> Pivots(Offs + M1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To M1 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + M1 + i)
                Next i_
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Offs + M1 + i) = A(i_, Pivots(Offs + M1 + i))
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Pivots(Offs + M1 + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent real LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUPRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim M1 As Long
    Dim M2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASBlockSize(A) Then
        Call RMatrixLUP2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make N>=M
    '
    '     ( A1 )
    ' A = (    ), where A1 is square
    '     ( A2 )
    '
    ' Factorize A1, update A2
    '
    If M > N Then
        Call RMatrixLUPRec(A, Offs, N, N, Pivots, Tmp)
        For i = 0# To N - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N) - (0#)
                For i_ = 0# To M - N - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + N To Offs + M - 1# Step 1
                    A(i_, Offs + i) = A(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + N)
                For i_ = Offs + N To Offs + M - 1# Step 1
                    A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixRightTRSM(M - N, N, A, Offs, Offs, True, True, 0#, A, Offs + N, Offs)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASSplitLength(A, M, M1, M2)
    Call RMatrixLUPRec(A, Offs, M1, N, Pivots, Tmp)
    If M2 > 0# Then
        For i = 0# To M1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + M1) - (0#)
                For i_ = 0# To M2 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + i)
                Next i_
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Offs + i) = A(i_, Pivots(Offs + i))
                Next i_
                i1_ = (0#) - (Offs + M1)
                For i_ = Offs + M1 To Offs + M - 1# Step 1
                    A(i_, Pivots(Offs + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixRightTRSM(M2, M1, A, Offs, Offs, True, True, 0#, A, Offs + M1, Offs)
        Call RMatrixGEMM(M - M1, N - M1, M1, -1#, A, Offs + M1, Offs, 0#, A, Offs, Offs + M1, 0#, 1#, A, Offs + M1, Offs + M1)
        Call RMatrixLUPRec(A, Offs + M1, M - M1, N - M1, Pivots, Tmp)
        For i = 0# To M2 - 1# Step 1
            If Offs + M1 + i <> Pivots(Offs + M1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To M1 - 1# Step 1
                    Tmp(i_) = A(i_ + i1_, Offs + M1 + i)
                Next i_
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Offs + M1 + i) = A(i_, Pivots(Offs + M1 + i))
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + M1 - 1# Step 1
                    A(i_, Pivots(Offs + M1 + i)) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent complex LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixPLURec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASComplexBlockSize(A) Then
        Call CMatrixPLU2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make M>=N.
    '
    ' A = (A1 A2), where A1 is square
    ' Factorize A1, update A2
    '
    If N > M Then
        Call CMatrixPLURec(A, Offs, M, M, Pivots, Tmp)
        For i = 0# To M - 1# Step 1
            i1_ = (Offs + M) - (0#)
            For i_ = 0# To N - M - 1# Step 1
                Tmp(i_) = A(Offs + i, i_ + i1_)
            Next i_
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Offs + i, i_) = A(Pivots(Offs + i), i_)
            Next i_
            i1_ = (0#) - (Offs + M)
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
            Next i_
        Next i
        Call CMatrixLeftTRSM(M, N - M, A, Offs, Offs, False, True, 0#, A, Offs, Offs + M)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    Call CMatrixPLURec(A, Offs, M, N1, Pivots, Tmp)
    If N2 > 0# Then
        For i = 0# To N1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N1) - (0#)
                For i_ = 0# To N2 - 1# Step 1
                    Tmp(i_) = A(Offs + i, i_ + i1_)
                Next i_
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = A(Pivots(Offs + i), i_)
                Next i_
                i1_ = (0#) - (Offs + N1)
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, False, True, 0#, A, Offs, Offs + N1)
        Call CMatrixGEMM(M - N1, N - N1, N1, C_Complex(-1#), A, Offs + N1, Offs, 0#, A, Offs, Offs + N1, 0#, C_Complex(1#), A, Offs + N1, Offs + N1)
        Call CMatrixPLURec(A, Offs + N1, M - N1, N - N1, Pivots, Tmp)
        For i = 0# To N2 - 1# Step 1
            If Offs + N1 + i <> Pivots(Offs + N1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To N1 - 1# Step 1
                    Tmp(i_) = A(Offs + N1 + i, i_ + i1_)
                Next i_
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = A(Pivots(Offs + N1 + i), i_)
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Pivots(Offs + N1 + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recurrent real LU subroutine.
'Never call it directly.
'
'  -- ALGLIB routine --
'     04.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixPLURec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Kernel case
    '
    If MinInt(M, N) <= ABLASBlockSize(A) Then
        Call RMatrixPLU2(A, Offs, M, N, Pivots, Tmp)
        Exit Sub
    End If
    
    '
    ' Preliminary step, make M>=N.
    '
    ' A = (A1 A2), where A1 is square
    ' Factorize A1, update A2
    '
    If N > M Then
        Call RMatrixPLURec(A, Offs, M, M, Pivots, Tmp)
        For i = 0# To M - 1# Step 1
            i1_ = (Offs + M) - (0#)
            For i_ = 0# To N - M - 1# Step 1
                Tmp(i_) = A(Offs + i, i_ + i1_)
            Next i_
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Offs + i, i_) = A(Pivots(Offs + i), i_)
            Next i_
            i1_ = (0#) - (Offs + M)
            For i_ = Offs + M To Offs + N - 1# Step 1
                A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
            Next i_
        Next i
        Call RMatrixLeftTRSM(M, N - M, A, Offs, Offs, False, True, 0#, A, Offs, Offs + M)
        Exit Sub
    End If
    
    '
    ' Non-kernel case
    '
    Call ABLASSplitLength(A, N, N1, N2)
    Call RMatrixPLURec(A, Offs, M, N1, Pivots, Tmp)
    If N2 > 0# Then
        For i = 0# To N1 - 1# Step 1
            If Offs + i <> Pivots(Offs + i) Then
                i1_ = (Offs + N1) - (0#)
                For i_ = 0# To N2 - 1# Step 1
                    Tmp(i_) = A(Offs + i, i_ + i1_)
                Next i_
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = A(Pivots(Offs + i), i_)
                Next i_
                i1_ = (0#) - (Offs + N1)
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Pivots(Offs + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
        Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, False, True, 0#, A, Offs, Offs + N1)
        Call RMatrixGEMM(M - N1, N - N1, N1, -1#, A, Offs + N1, Offs, 0#, A, Offs, Offs + N1, 0#, 1#, A, Offs + N1, Offs + N1)
        Call RMatrixPLURec(A, Offs + N1, M - N1, N - N1, Pivots, Tmp)
        For i = 0# To N2 - 1# Step 1
            If Offs + N1 + i <> Pivots(Offs + N1 + i) Then
                i1_ = (Offs) - (0#)
                For i_ = 0# To N1 - 1# Step 1
                    Tmp(i_) = A(Offs + N1 + i, i_ + i1_)
                Next i_
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = A(Pivots(Offs + N1 + i), i_)
                Next i_
                i1_ = (0#) - (Offs)
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Pivots(Offs + N1 + i), i_) = Tmp(i_ + i1_)
                Next i_
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex LUP kernel
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLUP2(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim J As Long
    Dim JP As Long
    Dim S As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    
    '
    ' main cycle
    '
    For J = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot, swap columns
        '
        JP = J
        For i = J + 1# To N - 1# Step 1
            If AbsComplex(A(Offs + J, Offs + i)) > AbsComplex(A(Offs + J, Offs + JP)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + J) = Offs + JP
        If JP <> J Then
            i1_ = (Offs) - (0#)
            For i_ = 0# To M - 1# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + J)
            Next i_
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + J) = A(i_, Offs + JP)
            Next i_
            i1_ = (0#) - (Offs)
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + JP) = Tmp(i_ + i1_)
            Next i_
        End If
        
        '
        ' LU decomposition of 1x(N-J) matrix
        '
        If C_NotEqualR(A(Offs + J, Offs + J), 0#) And J + 1# <= N - 1# Then
            S = C_RDiv(1#, A(Offs + J, Offs + J))
            For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                A(Offs + J, i_) = C_Mul(S, A(Offs + J, i_))
            Next i_
        End If
        
        '
        ' Update trailing (M-J-1)x(N-J-1) matrix
        '
        If J < MinInt(M - 1#, N - 1#) Then
            i1_ = (Offs + J + 1#) - (0#)
            For i_ = 0# To M - J - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + J)
            Next i_
            i1_ = (Offs + J + 1#) - (M)
            For i_ = M To M + N - J - 2# Step 1
                Tmp(i_) = C_Opposite(A(Offs + J, i_ + i1_))
            Next i_
            Call CMatrixRank1(M - J - 1#, N - J - 1#, A, Offs + J + 1#, Offs + J + 1#, Tmp, 0#, Tmp, M)
        End If
    Next J
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real LUP kernel
'
'  -- ALGLIB routine --
'     10.01.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLUP2(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim J As Long
    Dim JP As Long
    Dim S As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    
    '
    ' main cycle
    '
    For J = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot, swap columns
        '
        JP = J
        For i = J + 1# To N - 1# Step 1
            If Abs(A(Offs + J, Offs + i)) > Abs(A(Offs + J, Offs + JP)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + J) = Offs + JP
        If JP <> J Then
            i1_ = (Offs) - (0#)
            For i_ = 0# To M - 1# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + J)
            Next i_
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + J) = A(i_, Offs + JP)
            Next i_
            i1_ = (0#) - (Offs)
            For i_ = Offs To Offs + M - 1# Step 1
                A(i_, Offs + JP) = Tmp(i_ + i1_)
            Next i_
        End If
        
        '
        ' LU decomposition of 1x(N-J) matrix
        '
        If A(Offs + J, Offs + J) <> 0# And J + 1# <= N - 1# Then
            S = 1# / A(Offs + J, Offs + J)
            For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                A(Offs + J, i_) = S * A(Offs + J, i_)
            Next i_
        End If
        
        '
        ' Update trailing (M-J-1)x(N-J-1) matrix
        '
        If J < MinInt(M - 1#, N - 1#) Then
            i1_ = (Offs + J + 1#) - (0#)
            For i_ = 0# To M - J - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + J)
            Next i_
            i1_ = (Offs + J + 1#) - (M)
            For i_ = M To M + N - J - 2# Step 1
                Tmp(i_) = -A(Offs + J, i_ + i1_)
            Next i_
            Call RMatrixRank1(M - J - 1#, N - J - 1#, A, Offs + J + 1#, Offs + J + 1#, Tmp, 0#, Tmp, M)
        End If
    Next J
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Complex PLU kernel
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixPLU2(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim J As Long
    Dim JP As Long
    Dim S As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    For J = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot and test for singularity.
        '
        JP = J
        For i = J + 1# To M - 1# Step 1
            If AbsComplex(A(Offs + i, Offs + J)) > AbsComplex(A(Offs + JP, Offs + J)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + J) = Offs + JP
        If C_NotEqualR(A(Offs + JP, Offs + J), 0#) Then
            
            '
            'Apply the interchange to rows
            '
            If JP <> J Then
                For i = 0# To N - 1# Step 1
                    S = A(Offs + J, Offs + i)
                    A(Offs + J, Offs + i) = A(Offs + JP, Offs + i)
                    A(Offs + JP, Offs + i) = S
                Next i
            End If
            
            '
            'Compute elements J+1:M of J-th column.
            '
            If J + 1# <= M - 1# Then
                S = C_RDiv(1#, A(Offs + J, Offs + J))
                For i_ = Offs + J + 1# To Offs + M - 1# Step 1
                    A(i_, Offs + J) = C_Mul(S, A(i_, Offs + J))
                Next i_
            End If
        End If
        If J < MinInt(M, N) - 1# Then
            
            '
            'Update trailing submatrix.
            '
            i1_ = (Offs + J + 1#) - (0#)
            For i_ = 0# To M - J - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + J)
            Next i_
            i1_ = (Offs + J + 1#) - (M)
            For i_ = M To M + N - J - 2# Step 1
                Tmp(i_) = C_Opposite(A(Offs + J, i_ + i1_))
            Next i_
            Call CMatrixRank1(M - J - 1#, N - J - 1#, A, Offs + J + 1#, Offs + J + 1#, Tmp, 0#, Tmp, M)
        End If
    Next J
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Real PLU kernel
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     June 30, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixPLU2(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Pivots() As Long, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim J As Long
    Dim JP As Long
    Dim S As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If M = 0# Or N = 0# Then
        Exit Sub
    End If
    For J = 0# To MinInt(M - 1#, N - 1#) Step 1
        
        '
        ' Find pivot and test for singularity.
        '
        JP = J
        For i = J + 1# To M - 1# Step 1
            If Abs(A(Offs + i, Offs + J)) > Abs(A(Offs + JP, Offs + J)) Then
                JP = i
            End If
        Next i
        Pivots(Offs + J) = Offs + JP
        If A(Offs + JP, Offs + J) <> 0# Then
            
            '
            'Apply the interchange to rows
            '
            If JP <> J Then
                For i = 0# To N - 1# Step 1
                    S = A(Offs + J, Offs + i)
                    A(Offs + J, Offs + i) = A(Offs + JP, Offs + i)
                    A(Offs + JP, Offs + i) = S
                Next i
            End If
            
            '
            'Compute elements J+1:M of J-th column.
            '
            If J + 1# <= M - 1# Then
                S = 1# / A(Offs + J, Offs + J)
                For i_ = Offs + J + 1# To Offs + M - 1# Step 1
                    A(i_, Offs + J) = S * A(i_, Offs + J)
                Next i_
            End If
        End If
        If J < MinInt(M, N) - 1# Then
            
            '
            'Update trailing submatrix.
            '
            i1_ = (Offs + J + 1#) - (0#)
            For i_ = 0# To M - J - 2# Step 1
                Tmp(i_) = A(i_ + i1_, Offs + J)
            Next i_
            i1_ = (Offs + J + 1#) - (M)
            For i_ = M To M + N - J - 2# Step 1
                Tmp(i_) = -A(Offs + J, i_ + i1_)
            Next i_
            Call RMatrixRank1(M - J - 1#, N - J - 1#, A, Offs + J + 1#, Offs + J + 1#, Tmp, 0#, Tmp, M)
        End If
    Next J
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive computational subroutine for HPDMatrixCholesky
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function HPDMatrixCholeskyRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Complex) As Boolean
    Dim Result As Boolean
    Dim N1 As Long
    Dim N2 As Long
    
    '
    ' check N
    '
    If N < 1# Then
        Result = False
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' special cases
    '
    If N = 1# Then
        If A(Offs, Offs).X > 0# Then
            A(Offs, Offs) = C_Complex(Sqr(A(Offs, Offs).X))
            Result = True
        Else
            Result = False
        End If
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N <= ABLASComplexBlockSize(A) Then
        Result = HPDMatrixCholesky2(A, Offs, N, IsUpper, Tmp)
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' general case: split task in cache-oblivious manner
    '
    Result = True
    Call ABLASComplexSplitLength(A, N, N1, N2)
    Result = HPDMatrixCholeskyRec(A, Offs, N1, IsUpper, Tmp)
    If Not Result Then
        HPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N2 > 0# Then
        If IsUpper Then
            Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 2#, A, Offs, Offs + N1)
            Call CMatrixSYRK(N2, N1, -1#, A, Offs, Offs + N1, 2#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        Else
            Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 2#, A, Offs + N1, Offs)
            Call CMatrixSYRK(N2, N1, -1#, A, Offs + N1, Offs, 0#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        End If
        Result = HPDMatrixCholeskyRec(A, Offs + N1, N2, IsUpper, Tmp)
        If Not Result Then
            HPDMatrixCholeskyRec = Result
            Exit Function
        End If
    End If
    HPDMatrixCholeskyRec = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive computational subroutine for SPDMatrixCholesky
'
'  -- ALGLIB routine --
'     15.12.2009
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function SPDMatrixCholeskyRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Double) As Boolean
    Dim Result As Boolean
    Dim N1 As Long
    Dim N2 As Long
    
    '
    ' check N
    '
    If N < 1# Then
        Result = False
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' special cases
    '
    If N = 1# Then
        If A(Offs, Offs) > 0# Then
            A(Offs, Offs) = Sqr(A(Offs, Offs))
            Result = True
        Else
            Result = False
        End If
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N <= ABLASBlockSize(A) Then
        Result = SPDMatrixCholesky2(A, Offs, N, IsUpper, Tmp)
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    
    '
    ' general case: split task in cache-oblivious manner
    '
    Result = True
    Call ABLASSplitLength(A, N, N1, N2)
    Result = SPDMatrixCholeskyRec(A, Offs, N1, IsUpper, Tmp)
    If Not Result Then
        SPDMatrixCholeskyRec = Result
        Exit Function
    End If
    If N2 > 0# Then
        If IsUpper Then
            Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 1#, A, Offs, Offs + N1)
            Call RMatrixSYRK(N2, N1, -1#, A, Offs, Offs + N1, 1#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        Else
            Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 1#, A, Offs + N1, Offs)
            Call RMatrixSYRK(N2, N1, -1#, A, Offs + N1, Offs, 0#, 1#, A, Offs + N1, Offs + N1, IsUpper)
        End If
        Result = SPDMatrixCholeskyRec(A, Offs + N1, N2, IsUpper, Tmp)
        If Not Result Then
            SPDMatrixCholeskyRec = Result
            Exit Function
        End If
    End If
    SPDMatrixCholeskyRec = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 Hermitian Cholesky subroutine.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function HPDMatrixCholesky2(ByRef AAA() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Complex) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AJJ As Double
    Dim V As Complex
    Dim R As Double
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    If N < 0# Then
        Result = False
        HPDMatrixCholesky2 = Result
        Exit Function
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        HPDMatrixCholesky2 = Result
        Exit Function
    End If
    If IsUpper Then
        
        '
        ' Compute the Cholesky factorization A = U'*U.
        '
        For J = 0# To N - 1# Step 1
            
            '
            ' Compute U(J,J) and test for non-positive-definiteness.
            '
            V = C_Complex(0#)
            For i_ = Offs To Offs + J - 1# Step 1
                V = C_Add(V, C_Mul(Conj(AAA(i_, Offs + J)), AAA(i_, Offs + J)))
            Next i_
            AJJ = C_Sub(AAA(Offs + J, Offs + J), V).X
            If AJJ <= 0# Then
                AAA(Offs + J, Offs + J) = C_Complex(AJJ)
                Result = False
                HPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + J, Offs + J) = C_Complex(AJJ)
            
            '
            ' Compute elements J+1:N-1 of row J.
            '
            If J < N - 1# Then
                If J > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To J - 1# Step 1
                        Tmp(i_) = C_Opposite(Conj(AAA(i_ + i1_, Offs + J)))
                    Next i_
                    Call CMatrixMV(N - J - 1#, J, AAA, Offs, Offs + J + 1#, 1#, Tmp, 0#, Tmp, N)
                    i1_ = (N) - (Offs + J + 1#)
                    For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                        AAA(Offs + J, i_) = C_Add(AAA(Offs + J, i_), Tmp(i_ + i1_))
                    Next i_
                End If
                R = 1# / AJJ
                For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                    AAA(Offs + J, i_) = C_MulR(AAA(Offs + J, i_), R)
                Next i_
            End If
        Next J
    Else
        
        '
        ' Compute the Cholesky factorization A = L*L'.
        '
        For J = 0# To N - 1# Step 1
            
            '
            ' Compute L(J+1,J+1) and test for non-positive-definiteness.
            '
            V = C_Complex(0#)
            For i_ = Offs To Offs + J - 1# Step 1
                V = C_Add(V, C_Mul(Conj(AAA(Offs + J, i_)), AAA(Offs + J, i_)))
            Next i_
            AJJ = C_Sub(AAA(Offs + J, Offs + J), V).X
            If AJJ <= 0# Then
                AAA(Offs + J, Offs + J) = C_Complex(AJJ)
                Result = False
                HPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + J, Offs + J) = C_Complex(AJJ)
            
            '
            ' Compute elements J+1:N of column J.
            '
            If J < N - 1# Then
                If J > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To J - 1# Step 1
                        Tmp(i_) = Conj(AAA(Offs + J, i_ + i1_))
                    Next i_
                    Call CMatrixMV(N - J - 1#, J, AAA, Offs + J + 1#, Offs, 0#, Tmp, 0#, Tmp, N)
                    For i = 0# To N - J - 2# Step 1
                        AAA(Offs + J + 1# + i, Offs + J) = C_DivR(C_Sub(AAA(Offs + J + 1# + i, Offs + J), Tmp(N + i)), AJJ)
                    Next i
                Else
                    For i = 0# To N - J - 2# Step 1
                        AAA(Offs + J + 1# + i, Offs + J) = C_DivR(AAA(Offs + J + 1# + i, Offs + J), AJJ)
                    Next i
                End If
            End If
        Next J
    End If
    HPDMatrixCholesky2 = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Level-2 Cholesky subroutine
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Function SPDMatrixCholesky2(ByRef AAA() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Double) As Boolean
    Dim Result As Boolean
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AJJ As Double
    Dim V As Double
    Dim R As Double
    Dim i_ As Long
    Dim i1_ As Long
    Result = True
    If N < 0# Then
        Result = False
        SPDMatrixCholesky2 = Result
        Exit Function
    End If
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        SPDMatrixCholesky2 = Result
        Exit Function
    End If
    If IsUpper Then
        
        '
        ' Compute the Cholesky factorization A = U'*U.
        '
        For J = 0# To N - 1# Step 1
            
            '
            ' Compute U(J,J) and test for non-positive-definiteness.
            '
            V = 0#
            For i_ = Offs To Offs + J - 1# Step 1
                V = V + AAA(i_, Offs + J) * AAA(i_, Offs + J)
            Next i_
            AJJ = AAA(Offs + J, Offs + J) - V
            If AJJ <= 0# Then
                AAA(Offs + J, Offs + J) = AJJ
                Result = False
                SPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + J, Offs + J) = AJJ
            
            '
            ' Compute elements J+1:N-1 of row J.
            '
            If J < N - 1# Then
                If J > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To J - 1# Step 1
                        Tmp(i_) = -AAA(i_ + i1_, Offs + J)
                    Next i_
                    Call RMatrixMV(N - J - 1#, J, AAA, Offs, Offs + J + 1#, 1#, Tmp, 0#, Tmp, N)
                    i1_ = (N) - (Offs + J + 1#)
                    For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                        AAA(Offs + J, i_) = AAA(Offs + J, i_) + Tmp(i_ + i1_)
                    Next i_
                End If
                R = 1# / AJJ
                For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                    AAA(Offs + J, i_) = R * AAA(Offs + J, i_)
                Next i_
            End If
        Next J
    Else
        
        '
        ' Compute the Cholesky factorization A = L*L'.
        '
        For J = 0# To N - 1# Step 1
            
            '
            ' Compute L(J+1,J+1) and test for non-positive-definiteness.
            '
            V = 0#
            For i_ = Offs To Offs + J - 1# Step 1
                V = V + AAA(Offs + J, i_) * AAA(Offs + J, i_)
            Next i_
            AJJ = AAA(Offs + J, Offs + J) - V
            If AJJ <= 0# Then
                AAA(Offs + J, Offs + J) = AJJ
                Result = False
                SPDMatrixCholesky2 = Result
                Exit Function
            End If
            AJJ = Sqr(AJJ)
            AAA(Offs + J, Offs + J) = AJJ
            
            '
            ' Compute elements J+1:N of column J.
            '
            If J < N - 1# Then
                If J > 0# Then
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To J - 1# Step 1
                        Tmp(i_) = AAA(Offs + J, i_ + i1_)
                    Next i_
                    Call RMatrixMV(N - J - 1#, J, AAA, Offs + J + 1#, Offs, 0#, Tmp, 0#, Tmp, N)
                    For i = 0# To N - J - 2# Step 1
                        AAA(Offs + J + 1# + i, Offs + J) = (AAA(Offs + J + 1# + i, Offs + J) - Tmp(N + i)) / AJJ
                    Next i
                Else
                    For i = 0# To N - J - 2# Step 1
                        AAA(Offs + J + 1# + i, Offs + J) = AAA(Offs + J + 1# + i, Offs + J) / AJJ
                    Next i
                End If
            End If
        Next J
    End If
    SPDMatrixCholesky2 = Result
End Function
