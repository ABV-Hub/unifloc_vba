'=======================================================================================
'Unifloc 7.25  coronav                                          khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' вспомогательные функции для проведения расчетов из рабочих книг Excel
Option Explicit
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция возвращает номер версии Унифлок VBA
Public Function unf_version() As String
'description_end
' возвращает актуальный номер версии унифлок в рабочие книги которые это поддерживают
    unf_version = const_unifloc_version
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' Функция кодирования параметров PVT в строку,
' для передачи PVT свойств в прикладные функции Унифлок.
Public Function PVT_encode_string( _
                    Optional ByVal gamma_gas As Double = const_gg_, _
                    Optional ByVal gamma_oil As Double = const_go_, _
                    Optional ByVal gamma_wat As Double = const_gw_, _
                    Optional ByVal rsb_m3m3 = const_rsb_default, _
                    Optional ByVal rp_m3m3, _
                    Optional ByVal pb_atma, _
                    Optional ByVal t_res_C, _
                    Optional ByVal bob_m3m3, _
                    Optional ByVal muob_cP, _
                    Optional ByVal PVTcorr, _
                    Optional ByVal ksep_fr, _
                    Optional ByVal p_ksep_atma, _
                    Optional ByVal t_ksep_C, _
                    Optional ByVal gas_only As Boolean _
                    )
' gamma_gas - удельная плотность газа, по воздуху.
'             По умолчанию const_gg_ = 0.6
' gamma_oil - удельная плотность нефти, по воде.
'             По умолчанию const_go_ = 0.86
' gamma_wat - удельная плотность воды, по воде.
'             По умолчанию const_gw_ = 1
' rsb_m3m3  - газосодержание при давлении насыщения, м3/м3.
'             По умолчанию const_rsb_default = 100
' rp_m3m3 - замерной газовый фактор, м3/м3.
'           Имеет приоритет перед rsb если rp < rsb
' pb_atma - давление насыщения при  температуре t_res_C, атма.
'           Опциональный калибровочный параметр,
'           если не задан или = 0, то рассчитается по корреляции.
' t_res_C  - пластовая температура, С.
'           Учитывается при расчете давления насыщения.
'           По умолчанию  const_tres_default = 90
' bob_m3m3 - объемный коэффициент нефти при давлении насыщения
'            и пластовой температуре, м3/м3.
'            По умолчанию рассчитывается по корреляции.
' muob_cP  - вязкость нефти при давлении насыщения.
'            и пластовой температуре, сП.
'            По умолчанию рассчитывается по корреляции.
' PVTcorr - номер набора PVT корреляций для расчета:
'           0 - на основе корреляции Стендинга;
'           1 - на основе кор-ии Маккейна;
'           2 - на основе упрощенных зависимостей.
' ksep_fr - коэффициент сепарации - определяет изменение свойств
'           нефти после сепарации части свободного газа.
'           Зависит от давления и температуры
'           сепарации газа, которые должны быть явно заданы.
' p_ksep_atma - давление при которой была сепарация
' t_ksep_C    - температура при которой была сепарация
' gas_only   - флаг - в потоке только газ
'              по умолчанию False (нефть вода и газ)
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim pvt_dict As New Dictionary
    
    pvt_dict.Add "gamma_gas", gamma_gas
    pvt_dict.Add "gamma_oil", gamma_oil
    pvt_dict.Add "gamma_wat", gamma_wat
    pvt_dict.Add "rsb_m3m3", rsb_m3m3
    
    If Not IsMissing(rp_m3m3) Then pvt_dict.Add "rp_m3m3", rp_m3m3
    If Not IsMissing(pb_atma) Then pvt_dict.Add "pb_atma", pb_atma
    If Not IsMissing(t_res_C) Then pvt_dict.Add "t_res_C", t_res_C
    If Not IsMissing(bob_m3m3) Then pvt_dict.Add "bob_m3m3", bob_m3m3
    If Not IsMissing(muob_cP) Then pvt_dict.Add "muob_cP", muob_cP
    If Not IsMissing(PVTcorr) Then pvt_dict.Add "PVTcorr", PVTcorr
    If Not IsMissing(ksep_fr) Then pvt_dict.Add "ksep_fr", ksep_fr
    If Not IsMissing(p_ksep_atma) Then pvt_dict.Add "p_ksep_atma", p_ksep_atma
    If Not IsMissing(t_ksep_C) Then pvt_dict.Add "t_ksep_C", t_ksep_C
    If gas_only Then pvt_dict.Add "gas_only", gas_only
    
    
    PVT_encode_string = ConvertToJson(pvt_dict)
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров PVT закодированных в строке
Public Function PVT_decode_string( _
                    Optional ByVal str_PVT As String = PVT_DEFAULT, _
                    Optional ByVal getStr As Boolean = False)
' str_PVT  - строка с параметрами PVT
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CPVT
'    если задать True - функция раскодирует строку и снова закодирует
'                и выдаст строку (можно использовать из рабочей книги)
' результат - объект CPVT
'description_end
' при разбиении строки на части ошибки недопустимы
    Dim PVT As New CPVT
On Error GoTo er1:
    If Len(str_PVT) < 3 Then
        Set PVT_decode_string = Nothing
        Exit Function
    End If
    Call PVT.init_json(str_PVT)
    
    If getStr Then
        With PVT
            PVT_decode_string = PVT_encode_string(.gamma_g, .gamma_o, _
              .gamma_w, .rsb_m3m3, .rsb_m3m3, _
              .pb_atma, .t_res_C, .bob_m3m3, .muob_cP, .PVT_correlation, .ksep_fr, .p_ksep_atma, _
              .t_ksep_C, PVT.gas_only)
        End With
    Else
        Set PVT_decode_string = PVT
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "PVT_decode_string. error:" & Err.Description & " :" & str_PVT
    addLogMsg errmsg
    Err.Raise kErrPVTinput, Err.source, errmsg
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы УЭЦН в строку,
' которую можно потом использовать для задания ЭЦН в прикладных функциях
Public Function ESP_encode_string( _
            Optional ByVal ESP_ID As Double = 1005, _
            Optional ByVal HeadNom_m As Double = 2000, _
            Optional ByVal ESP_freq_Hz As Double = 50, _
            Optional ByVal ESP_U_V, _
            Optional ByVal ESP_cos_phi, _
            Optional ByVal MotorPowerNom_kW, _
            Optional ByVal t_intake_C, _
            Optional ByVal t_dis_C, _
            Optional ByVal Ksep_GS_fr, _
            Optional ByVal ksep_manual_fr, _
            Optional ByVal ESP_energy_fact_kWhday, _
            Optional ByVal ESP_cable_type, _
            Optional ByVal ESP_h_mes_m, _
            Optional ByVal ESP_gas_correct, _
            Optional ByVal c_calibr, _
            Optional ByVal PKV_work_min, _
            Optional ByVal PKV_stop_min, _
            Optional ByVal dnum_stages_integrate = 1)
' esp_ID         - идентификатор насоса
' HeadNom_m      - номинальный напор системы УЭЦН
'                - соответствует напора в записи ЭЦН 50-2000
' ESP_freq_Hz     - частота, Гц
' ESP_U_V        - напряжение на ПЭД
' MotorPowerNom_kW  - номинальная мощность двигателя
' t_intake_C     - температура на приеме насоа
' t_dis_C        - температура на выкиде насоса.
'                  если = 0 и calc_along_flow = 1 то рассчитывается
' Ksep_GS_fr      - коэффициент сепарации газосепаратора УЭЦН
' ESP_energy_fact_Whday  - фактическое потребление мощности ЭЦН
' ESP_cable_type - тип кабельной линии
'                  тип 1: cable_R_Omkm = 1.18
'                         cable_name = КПпАпБП-120 3x16
'                         cable_Tmax_C = 120
' ESP_h_mes_m    - длина кабельной линии
' ESP_gas_correct  - деградация по газу:
'      0 - 2 задает значение вручную;
'      10 стандартный ЭЦН (предел 25%);
'      20 ЭЦН с газостабилизирующим модулем (предел 50%);
'      30 ЭЦН с осевым модулем (предел 75%);
'      40 ЭЦН с модифицированным ступенями (предел 40%).
'      110+, тогда модель n-100 применяется ко всем ступеням отдельно
'         Предел по доле газа на входе в насос после сепарации
'         на основе статьи SPE 117414 (с корректировкой)
'         поправка дополнительная к деградации (суммируется).
' c_calibr    - коэффициент поправки на напор.
'     если массив то второе значение - поправыка на подачу (множитель)
'     третье на мощность (множитель)
' PKV_work_min      - время работы скважины для режима ПКВ в минутах
' PKV_stop_min      - время ожидания запуска скважины для ПКВ , мин
'                     ПКВ - периодическое кратковременное включение
'                     если не заданы, то скважина в ПДФ
'                     ПДФ - постоянно действующий фонд
' dnum_stages_integrate - шаг интегрирования для расчета
' результат         - строка с параметрами УЭЦН
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    Dim c_calibr_head As Double
    Dim c_calibr_rate As Double
    Dim c_calibr_power As Double
    
    
    Dim dict As New Dictionary
        
    c_calibr_head = 1
    c_calibr_rate = 1
    c_calibr_power = 1
    
    
    dict.Add "ESP_ID", ESP_ID
    dict.Add "HeadNom_m", HeadNom_m
    dict.Add "ESP_freq_Hz", ESP_freq_Hz
    If Not IsMissing(ESP_U_V) Then dict.Add "ESP_U_V", ESP_U_V
    If Not IsMissing(ESP_cos_phi) Then dict.Add "ESP_cos_phi", ESP_cos_phi
    If Not IsMissing(MotorPowerNom_kW) Then dict.Add "MotorPowerNom_kW", MotorPowerNom_kW
    If Not IsMissing(t_intake_C) Then dict.Add "t_intake_C", t_intake_C
    If Not IsMissing(t_dis_C) Then dict.Add "t_dis_C", t_dis_C
    If Not IsMissing(Ksep_GS_fr) Then dict.Add "Ksep_GS_fr", Ksep_GS_fr
    
    If Not IsMissing(ksep_manual_fr) Then dict.Add "Ksep_manual_fr", ksep_manual_fr
    If Not IsMissing(ESP_energy_fact_kWhday) Then dict.Add "ESP_energy_fact_kWhday", ESP_energy_fact_kWhday
    If Not IsMissing(ESP_cable_type) Then dict.Add "ESP_cable_type", ESP_cable_type
    If Not IsMissing(ESP_h_mes_m) Then dict.Add "ESP_h_mes_m", ESP_h_mes_m
    If Not IsMissing(ESP_gas_correct) Then dict.Add "ESP_gas_correct", ESP_gas_correct
    
    
    Dim clbr
    
    If Not IsMissing(c_calibr) Then
        ' set calibration properties
        clbr = array1d_from_range(c_calibr, num_only:=True, no_zero:=False)
        c_calibr_head = clbr(1)
        dict.Add "c_calibr_head", c_calibr_head
        If UBound(clbr) >= 2 Then
            c_calibr_rate = clbr(2)
            dict.Add "c_calibr_rate", c_calibr_rate
        Else
            c_calibr_rate = 1
        End If
        
        If UBound(clbr) >= 3 Then
            c_calibr_power = clbr(3)
            dict.Add "c_calibr_power", c_calibr_power
        Else
            c_calibr_power = 1
        End If
    End If
    
    If Not IsMissing(PKV_work_min) Then dict.Add "PKV_work_min", PKV_work_min
    If Not IsMissing(PKV_stop_min) Then dict.Add "PKV_stop_min", PKV_stop_min
    If Not IsMissing(dnum_stages_integrate) Then dict.Add "dnum_stages_integrate", dnum_stages_integrate
    ESP_encode_string = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров работы ЭЦН закодированных в строке
Public Function ESP_decode_string(ByVal str_ESP As String, _
                         Optional ByVal getStr As Boolean = False)
' str_ESP  - строка с параметрами ЭЦН
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CESPsystemSimple
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CESPsystemSimple
'description_end
    Dim ESPsys As New CESPsystemSimple
    Dim dict As Dictionary
    
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    
    
    If Len(str_ESP) < 3 Then
        Set ESP_decode_string = Nothing
        Exit Function
    End If
    
    Set dict = ParseJson(str_ESP)
    
    Call ESPsys.init_dictionary(dict)
    
    If getStr Then
        With ESPsys
            ESP_decode_string = ESP_encode_string(.ESP_pump.db.ID, _
                                                  .head_nom_m, _
                                                  .freq_Hz, _
                                               .U_V, .power_motor_nom_W, .t_int_C, .t_dis_C, _
                                               .ksep_gassep_fr, .ksep_manual_fr, .energy_fact_Whday, _
                                               .cable_type_num, _
                                               .h_mes_top_m, .ESP_pump.gas_correct, _
                                               Array(.ESP_pump.c_calibr_head, .ESP_pump.c_calibr_rate, .ESP_pump.c_calibr_power), _
                                               .PKV_work_min, .PKV_stop_min, .ESP_pump.dnum_stages_integrate)
        End With
    Else
        
        Set ESP_decode_string = ESPsys
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "ESP_decode_string. error:" & Err.Description
    addLogMsg errmsg
    Err.Raise kErrPVTinput, Err.source, errmsg
    Exit Function
    
End Function
'=============================
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров газлифтной компоновки скважины
Public Function GL_decode_string(well_GL_str As String, _
                  Optional ByVal getStr As Boolean = False)
' well_GL_str  - строка с параметрами газлифтной скважины
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CESPsystemSimple
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CESPsystemSimple
'description_end
    Dim S As String
    Dim A, b
    Dim I As Long
    Dim GLV As Integer
    Dim dict As New Dictionary
    Dim key As String
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    A = Split(well_GL_str, ";")
    ' перебираем и сохраняем все параметры
    For I = LBound(A) To UBound(A)
        ' только для непустых разбиений
        If A(I) <> "" Then
           b = Split(A(I), ":")
           'только там где есть значение
           If UBound(b) = 1 Then
               dict.Item(b(0)) = b(1)
           End If
        End If
    Next I
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "GLV": GLV = Cdbl_(dict.Item(key)) ' количество клапанов
    
    Dim q_gas_inj_sm3day As Double
    Dim p_gas_inj_atma As Double
    Dim d_gas_inj_mm As Double
    Dim h_glv_m() As Double
    Dim d_glv_mm() As Double
    Dim p_glv_atma() As Double
    ReDim h_glv_m(1 To GLV)
    ReDim d_glv_mm(1 To GLV)
    ReDim p_glv_atma(1 To GLV)
    
    key = "q_gas_inj_sm3day": q_gas_inj_sm3day = Cdbl_(dict.Item(key))
    key = "p_gas_inj_atma": p_gas_inj_atma = Cdbl_(dict.Item(key))
    key = "d_gas_inj_mm": d_gas_inj_mm = Cdbl_(dict.Item(key))
    
    For I = 1 To GLV
            key = "H_glv_m" & FormatInteger(I, 0): h_glv_m(I) = Cdbl_(dict.Item(key))
            key = "d_glv_mm" & FormatInteger(I, 0): d_glv_mm(I) = Cdbl_(dict.Item(key))
            key = "p_glv_atma" & FormatInteger(I, 0): p_glv_atma(I) = Cdbl_(dict.Item(key))
    Next I
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально при дешифровке
    If getStr Then
        GL_decode_string = GL_encode_string(q_gas_inj_sm3day, p_gas_inj_atma, d_gas_inj_mm, h_glv_m, d_glv_mm, p_glv_atma)
    Else
        Dim glv_set As New CGLValveSet
        Call glv_set.loadFromArray(h_glv_m, d_glv_mm, p_glv_atma)
        glv_set.q_gas_inj_sm3day = q_gas_inj_sm3day
        glv_set.p_gas_inj_atma = p_gas_inj_atma
        glv_set.d_gas_inj_mm = d_gas_inj_mm
        
        Set GL_decode_string = glv_set
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "GL_decode_string. error:" & Err.Description
    addLogMsg errmsg
    Err.Raise kErrPVTinput, Err.source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "GL_decode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы скважины с газлифтом
Public Function GL_encode_string( _
                    Optional q_gas_inj_sm3day As Double = 0, _
                    Optional p_gas_inj_atma As Double = 0, _
                    Optional d_gas_inj_mm As Double = 0, _
                    Optional HmesGLV_m = 0, _
                    Optional dGLV_mm = 0, _
                    Optional PsurfGLV_atma = 0)
' q_gas_inj_sm3day - расход газа закачки
' p_gas_inj_atma - давление газа закачки на поверхности
' d_gas_inj_mm - диаметр штуцера регулировки закачки газа на поверхности
' HmesGLV_m     - измеренные глубины установки газлифтных клапанов
' dGLV_mm       - диаметры порта установленных газлифтных клапанов
' PsurfGLV_atma - давления зарядки газлифтных клапанов
' результат     - строка с закодированными параметрами
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim h_glv_m() As Variant
    Dim d_glv_mm() As Variant
    Dim p_glv_atma() As Variant
    
    Dim I As Long
    
    frmt = "#0.####0"
    frmt_int = "0"
    str = "GLV:1;"
    str = str & "q_gas_inj_sm3day:" & Format(q_gas_inj_sm3day, frmt) & ";"
    str = str & "p_gas_inj_atma:" & Format(p_gas_inj_atma, frmt) & ";"
    str = str & "d_gas_inj_mm:" & Format(d_gas_inj_mm, frmt) & ";"
    h_glv_m = readRange(HmesGLV_m)
    d_glv_mm = readRange(dGLV_mm)
    p_glv_atma = readRange(PsurfGLV_atma)
    
    If (UBound(h_glv_m) = UBound(d_glv_mm)) And (UBound(h_glv_m) = UBound(p_glv_atma)) Then
        str = str & "GLV:" & FormatInteger(UBound(h_glv_m), 0) & ";"
        For I = LBound(h_glv_m) To UBound(h_glv_m)
            str = str & "H_glv_m" & FormatInteger(I, 0) & ":" & FormatFReal(Cdbl_(h_glv_m(I)), 0, 3) & ";"
            str = str & "d_glv_mm" & FormatInteger(I, 0) & ":" & FormatFReal(Cdbl_(d_glv_mm(I)), 0, 3) & ";"
            str = str & "p_glv_atma" & FormatInteger(I, 0) & ":" & FormatFReal(Cdbl_(p_glv_atma(I)), 0, 3) & ";"
        Next I
    Else
        str = str & "GVL:0;error" & ";"
    End If
    
    GL_encode_string = str
    
End Function
'=============================

