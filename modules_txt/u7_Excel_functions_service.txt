'=======================================================================================
'Unifloc 7.7  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' вспомогательные функции для проведения расчетов из рабочих книг Excel
Option Explicit
Public Function UFversion() As String
' возвращает актуальный номер версии унифлок в рабочие книги которые это поддерживают
    UFversion = "Unifloc 7.7  Vulpes zerda"
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров PVT в строку,
' которую можно потом использовать в прикладных функциях
Public Function PVT_encode_string( _
                    Optional ByVal gamma_gas As Double = const_gg_, _
                    Optional ByVal gamma_oil As Double = const_go_, _
                    Optional ByVal gamma_wat As Double = const_gw_, _
                    Optional ByVal rsb_m3m3 = const_Rsb_default, _
                    Optional ByVal rp_m3m3 = -1, _
                    Optional ByVal pb_atma = -1, _
                    Optional ByVal tres_C = const_Tres_default, _
                    Optional ByVal bob_m3m3 = -1, _
                    Optional ByVal muob_cP = -1, _
                    Optional ByVal PVTcorr = StandingBased, _
                    Optional ByVal ksep_fr = 0, _
                    Optional ByVal pksep_atma = -1, _
                    Optional ByVal tksep_C = -1 _
                    )
' опциональные аргументы функции
' gamma_gas удельная плотность газа, по воздуху.
'           const_gg_ = 0.6
' gamma_oil удельная плотность нефти, по воде.
'           const_go_ = 0.86
' gamma_wat удельная плотность воды, по воде.
'           const_gw_ = 1
' rsb_m3m3  газосодержание при давлении насыщения, м3/м3.
'           const_Rsb_default = 100
' rp_m3m3   замерной газовый фактор, м3/м3.
'           имеет приоритет перед Rsb если Rp < Rsb
' pb_atma   Давление насыщения при  температуре tres_C, атма.
'           Опциональный калибровочный параметр,
'           если не задан или = 0 то рассчитается по корреляции
' tres_C    пластовая температура, С.
'           Учитывается при расчете давления насыщения.
'           const_Tres_default = 90
' bob_m3m3  объемный коэффициент нефти, м3/м3.
' muob_cP   вязкость нефти при давлении насыщения
'           По умолчанию рассчитывается по корреляции
' PVTcorr   номер набора PVT корреляций для расчета
'           StandingBased = 0 - на основе кор-ии Стендинга
'           McCainBased = 1 - на основе кор-ии Маккейна
'           StraigthLine = 2 - на основе упрощенных зависимостей
' ksep_fr   коэффициент сепарации - определяет изменение свойств
'           нефти после сепарации доли свободного газа.
'           изменение свойств нефти зависит от условий
'           сепарации газа, которые должны быть явно заданы
' pksep_atma    давление при которой была сепарация
' tksep_C       температура при которой была сепарация
'
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.##0"
    frmt_int = "0"
    str = ""
    ' безхитростно кодируем все параметры один за другим
    str = str & "gamma_gas:" & Format(gamma_gas, frmt) & ";"
    str = str & "gamma_oil:" & Format(gamma_oil, frmt) & ";"
    str = str & "gamma_wat:" & Format(gamma_wat, frmt) & ";"
    str = str & "rsb_m3m3:" & Format(rsb_m3m3, frmt) & ";"
    str = str & "rp_m3m3:" & Format(rp_m3m3, frmt) & ";"
    str = str & "pb_atma:" & Format(pb_atma, frmt) & ";"
    str = str & "tres_C:" & Format(tres_C, frmt) & ";"
    str = str & "bob_m3m3:" & Format(bob_m3m3, frmt) & ";"
    str = str & "muob_cP:" & Format(muob_cP, frmt) & ";"
    str = str & "PVTcorr:" & Format(PVTcorr, frmt_int) & ";"
    str = str & "ksep_fr:" & Format(ksep_fr, frmt) & ";"
    str = str & "pksep_atma:" & Format(pksep_atma, frmt) & ";"
    str = str & "tksep_C:" & Format(tksep_C, frmt) & ";"
    PVT_encode_string = str
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров PVT закодированных в строке
Public Function PVT_decode_string( _
                    Optional ByVal PVTstr As String = PVT_DEFAULT, _
                    Optional ByVal getStr As Boolean = False)
' PVTstr  - строка с параметрами PVT
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CPVT
'    если задать True - функция раскодирует строку и снова закодирует
'                и выдаст строку (можно использовать из рабочей книги)
' результат - объект CPVT
'description_end
    Dim a
    Dim i As Integer
    Dim b
    Dim P_atma As Double
    Dim t_C
    Dim gamma_gas As Double
    Dim gamma_oil As Double
    Dim gamma_wat As Double
    Dim rsb_m3m3 As Double
    Dim rp_m3m3 As Double
    Dim pb_atma As Double
    Dim tres_C As Double
    Dim bob_m3m3 As Double
    Dim muob_cP As Double
    Dim PVTcorr As Integer
    Dim ksep_fr As Double
    Dim pksep_atma As Double
    Dim tksep_C As Double
    Dim key As String
    Dim item As String
    Dim PVT As New CPVT
    Dim dict As New Dictionary
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    a = Split(PVTstr, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(a) To UBound(a)
        ' только для непустых разбиений
        If a(i) <> "" Then
           b = Split(a(i), ":")
           'только там где есть значение
           If UBound(b) = 1 Then
               dict.item(b(0)) = b(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "gamma_oil": gamma_oil = Cdbl_(dict.item(key))
    key = "gamma_wat": gamma_wat = Cdbl_(dict.item(key))
    key = "gamma_gas": gamma_gas = Cdbl_(dict.item(key))
    key = "rsb_m3m3": rsb_m3m3 = Cdbl_(dict.item(key))
    key = "rp_m3m3": rp_m3m3 = Cdbl_(dict.item(key))
    ' для опциональных параметров делаем доп проверку
    key = "pb_atma": item = dict.item(key): If item = "" Then item = "-1": pb_atma = Cdbl_(item)
    key = "bob_m3m3": item = dict.item(key): If item = "" Then item = "-1": bob_m3m3 = Cdbl_(item)
    key = "muob_cP": item = dict.item(key): If item = "" Then item = "-1": muob_cP = Cdbl_(item)
    
    key = "PVTcorr": item = dict.item(key): If item = "" Then item = "0": PVTcorr = Cdbl_(item)
    key = "ksep_fr": item = dict.item(key): If item = "" Then item = "-1": ksep_fr = Cdbl_(item)
    key = "pksep_atma": item = dict.item(key): If item = "" Then item = "-1": pksep_atma = Cdbl_(item)
    key = "tksep_C": item = dict.item(key): If item = "" Then item = "-1": tksep_C = Cdbl_(item)
' ловим все ошибки, все должно пройти идеально при дешифровке
On Error GoTo er1:
    ' калибровочный параметр проверяем специально и не даем сохраниться значению по умолчанию
    ' если он неправильно указан (дублируется инициализацией в конструкторе, но все же)
    PVT.Init gamma_gas, gamma_oil, gamma_wat, rsb_m3m3, pb_atma, bob_m3m3, PVTcorr, tres_C, rp_m3m3, muob_cP
    If ksep_fr > 0 And ksep_fr <= 1 And pksep_atma > 0 And tksep_C > 0 Then
        Call PVT.ModAfterSeparation(pksep_atma, tksep_C, ksep_fr, GasGoesIntoSolution)
    End If
    If getStr Then
        PVT_decode_string = PVT_encode_string(gamma_gas, gamma_oil, _
              gamma_wat, rsb_m3m3, rp_m3m3, _
              pb_atma, tres_C, bob_m3m3, muob_cP, PVTcorr, ksep_fr, pksep_atma, _
              tksep_C)
    Else
        Set PVT_decode_string = PVT
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "PVT_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "PVT_decode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров конструкции скважины
' в строку, которую можно потом использовать
Public Function well_encode_string( _
                Optional ByVal hperf_m As Double = 2000, _
                Optional ByVal hpump_m As Double = 1800, _
                Optional ByVal udl_m As Double = 0, _
                Optional ByVal dcas_mm As Double = 150, _
                Optional ByVal dtub_mm As Double = 72, _
                Optional ByVal dchoke_mm As Double = 15, _
                Optional ByVal roughness_m As Double = 0.0001, _
                Optional ByVal tbh_C As Double = 85, _
                Optional ByVal twh_C As Double = 25)
' hperf_m       - измеренная глубина верхних дыр перфорации
'                 глубина пласта на которой рассчитывается
'                 забойное давление
' hpump_m       - измеренная глубина спуска насоса
' udl_m         - удлинение
'                 разница между измеренной и вертикальной
'                 глубиной пласта
' dcas_mm       - внутренний диаметр эксплуатационной колонны
' dtub_mm       - внешний диаметр НКТ
' dchoke_mm     - диаметр штуцера
' roughness_m   - шероховатость стенок НКТ и ЭК
' tbh_C         - температура флюида на забое скважины
' twh_C         - температура флюида на устье скважины
'                 по умолчанию температурный расчет идет
'                 такие образом, что температура флюида меняется
'                 линейно относительно вертикальной глубины
' результат     - строка с закодированными параметрами
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "hperf_m:" & Format(hperf_m, frmt) & ";"
    str = str & "hpump_m:" & Format(hpump_m, frmt) & ";"
    str = str & "udl_m:" & Format(udl_m, frmt) & ";"
    str = str & "dcas_mm:" & Format(dcas_mm, frmt) & ";"
    str = str & "dtub_mm:" & Format(dtub_mm, frmt) & ";"
    str = str & "dchoke_mm:" & Format(dchoke_mm, frmt) & ";"
    str = str & "roughness_m:" & Format(roughness_m, frmt) & ";"
    str = str & "tbh_C:" & Format(tbh_C, frmt) & ";"
    str = str & "twh_C:" & Format(twh_C, frmt) & ";"
    well_encode_string = str
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров конструкции скважины
' закодированных в строке
Public Function well_decode_string(ByVal wellStr As String, _
                          Optional ByVal getStr As Boolean = False)
' wellStr  - строка с параметрами конструкции скважины
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CWellESP
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CWellESP
'description_end
    Dim a
    Dim s As String
    Dim i As Integer
    Dim b
    Dim P_atma As Double
    Dim hperf_m As Double
    Dim hpump_m As Double
    Dim udl_m As Double
    Dim dcas_mm As Double
    Dim dtub_mm As Double
    Dim dchoke_mm As Double
    Dim roughness_m As Double
    Dim tbh_C As Double
    Dim twh_C As Double
    Dim well As CWellESP
    
    Dim key As String
    Dim dict As Dictionary
    
    
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    a = Split(wellStr, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(a) To UBound(a)
        ' только для непустых разбиений
        If a(i) <> "" Then
           b = Split(a(i), ":")
           'только там где есть значение
           If UBound(b) = 1 Then
               dict.item(b(0)) = b(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "hperf_m": hperf_m = Cdbl_(dict.item(key))
    key = "hpump_m": hpump_m = Cdbl_(dict.item(key))
    key = "udl_m": udl_m = Cdbl_(dict.item(key))
    key = "dcas_mm": dcas_mm = Cdbl_(dict.item(key))
    key = "dtub_mm": dtub_mm = Cdbl_(dict.item(key))
    key = "dchoke_mm": dchoke_mm = Cdbl_(dict.item(key))
    key = "roughness_m": roughness_m = Cdbl_(dict.item(key))
    key = "tbh_C": tbh_C = Cdbl_(dict.item(key))
    key = "twh_C": twh_C = Cdbl_(dict.item(key))
    
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально
        
    If getStr Then
         well_decode_string = well_encode_string(hperf_m, hpump_m, udl_m, _
                                                    dcas_mm, dtub_mm, dchoke_mm, roughness_m, _
                                                    tbh_C, twh_C)
    Else
        ' if ready to init well then do it
        Set well = New CWellESP
        well.InitWellConstruction hperf_m, hpump_m, dcas_mm, dtub_mm, udl_m
        well.InitWellTemperature tbh_C, twh_C
        ' initwell with use linear temp distribution mode by default
        ' so no  need to adjust temperature here anymore
        well.SetChoke dchoke_mm, dtub_mm
        Set well_decode_string = well
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "well_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "well_decode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы УЭЦН в строку,
' которую можно потом использовать для задания ЭЦН в прикладных функциях
Public Function ESP_encode_string( _
                    Optional ByVal esp_ID As Double = 1005, _
                    Optional ByVal HeadNom_m As Double = 2000, _
                    Optional ByVal ESPfreq_Hz As Double = 50, _
                    Optional ByVal ESP_U_V As Double = 1000, _
                    Optional ByVal MotorPowerNom_kW As Double = 30, _
                    Optional ByVal Tintake_C As Double = 85, _
                    Optional ByVal Tdis_C As Double = 85, _
                    Optional ByVal KsepGS_fr As Double = 0, _
                    Optional ByVal ESP_energy_fact_Whday As Double = 0, _
                    Optional ByVal ESP_cable_type As Double = 0, _
                    Optional ByVal ESP_Hmes_m As Double = 0, _
                    Optional ByVal GasDegtType As Integer = 0, _
                    Optional ByVal Kdegr As Double = 0, _
                    Optional ByVal PKV_work_min = -1, _
                    Optional ByVal PKV_stop_min = -1 _
                    )
' PumpID            - идентификатор насоса
' HeadNom_m         - номинальный напор системы УЭЦН
'                   - соответствует напора в записи ЭЦН 50-2000
' ESPfreq_Hz           - частота, Гц
' ESP_U_V           - напряжение на ПЭД
' ESP_Motor_power_nom_kW - номинальная мощность двигателя
' Tin_C             - температура на приеме насоа
' Tdis_C            - температура на выкиде насоса.
'                     если = 0 и CalcFromIntake = 1 то рассчитывается
' KsepGS_fr         - коэффициент сепарации газосепаратора УЭЦН
' ESP_energy_fact_Whday  - фактическое потребление мощности ЭЦН
' ESP_cable_type    - тип кабельной линии
'                   тип 1: cable_R_Omkm = 1.18
'                          cable_name = "КПпАпБП-120 3x16"
'                          cable_Tmax_C = 120
' ESP_Hmes_m        - длина кабельной линии
' GasDegtType       - тип насоса по работе с газом
'      GasDegtType = 0 нет коррекции
'      GasDegtType = 1 стандартный ЭЦН (предел 25%)
'      GasDegtType = 2 ЭЦН с газостабилизирующим модулем (предел 50%)
'      GasDegtType = 3 ЭЦН с осевым модулем (предел 75%)
'      GasDegtType = 4 ЭЦН с модифицированным ступенями (предел 40%)
'                 предел по доле газа на входе в насос после сепарации
'                 на основе статьи SPE 117414 (с корректировкой)
'                 поправка дополнительная к деградации (суммируется)
' Kdegr             - коэффициент деградации напора
' PKV_work_min      - время работы скважины для режима ПКВ в минутах
' PKV_stop_min      - время ожидания запуска скважины для ПКВ , мин
'                     ПКВ - периодическое кратковременное включение
'                     если не заданы, то скважина в ПДФ
'                     ПДФ - постоянно действующий фонд
' результат         - строка с параметрами УЭЦН
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "ESP_ID:" & Format(esp_ID, frmt) & ";"
    str = str & "HeadNom_m:" & Format(HeadNom_m, frmt) & ";"
    str = str & "ESPfreq_Hz:" & Format(ESPfreq_Hz, frmt) & ";"
    str = str & "ESP_U_V:" & Format(ESP_U_V, frmt) & ";"
    str = str & "MotorPowerNom_kW:" & Format(MotorPowerNom_kW, frmt) & ";"
    str = str & "Tintake_C:" & Format(Tintake_C, frmt) & ";"
    str = str & "Tdis_C:" & Format(Tdis_C, frmt) & ";"
    str = str & "KsepGS_fr:" & Format(KsepGS_fr, frmt) & ";"
    str = str & "ESP_energy_fact_Whday:" & Format(ESP_energy_fact_Whday, frmt) & ";"
    str = str & "ESP_cable_type:" & Format(ESP_cable_type, frmt_int) & ";"
    str = str & "ESP_Hmes_m:" & Format(ESP_Hmes_m, frmt) & ";"
    str = str & "GasDegtType:" & Format(GasDegtType, frmt_int) & ";"
    str = str & "Kdegr:" & Format(Kdegr, frmt) & ";"
    str = str & "PKV_work_min:" & Format(PKV_work_min, frmt) & ";"
    str = str & "PKV_stop_min:" & Format(PKV_stop_min, frmt) & ";"
    ESP_encode_string = str
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров работы ЭЦН закодированных в строке
Public Function ESP_decode_string(ByVal ESPstr As String, _
                         Optional ByVal getStr As Boolean = False)
' ESPstr  - строка с параметрами ЭЦН
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CESPsystemSimple
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CESPsystemSimple
'description_end
    Dim a
   ' Dim s As String
    Dim i As Integer
    Dim b
    Dim P_atma As Double
    Dim esp_ID As Double
    Dim HeadNom_m As Double
    Dim ESPfreq_Hz As Double
    Dim ESP_U_V As Double
    Dim MotorPowerNom_kW As Double
    Dim Tintake_C As Double
    Dim Tdis_C As Double
    Dim KsepGS_fr As Double
    Dim ESPsys As CESPsystemSimple
    Dim pmp As CESPpump
    Dim dict As Dictionary
    
    Dim ESP_energy_fact_Whday As Double
    Dim ESP_cable_type As Double
    Dim ESP_Hmes_m As Double
    Dim GasDegtType As Integer
    Dim Kdegr As Double
    
    Dim PKV_work_min As Double
    Dim PKV_stop_min As Double
    Dim key As String
    
    
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    a = Split(ESPstr, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(a) To UBound(a)
        ' только для непустых разбиений
        If a(i) <> "" Then
           b = Split(a(i), ":")
           'только там где есть значение
           If UBound(b) = 1 Then
               dict.item(b(0)) = b(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "esp_ID": esp_ID = Cdbl_(dict.item(key))
    key = "HeadNom_m": HeadNom_m = Cdbl_(dict.item(key))
    key = "ESPfreq_Hz": ESPfreq_Hz = Cdbl_(dict.item(key))
    key = "ESP_U_V": ESP_U_V = Cdbl_(dict.item(key))
    key = "MotorPowerNom_kW": MotorPowerNom_kW = Cdbl_(dict.item(key))
    key = "Tintake_C": Tintake_C = Cdbl_(dict.item(key))
    key = "Tdis_C": Tdis_C = Cdbl_(dict.item(key))
    key = "KsepGS_fr": KsepGS_fr = Cdbl_(dict.item(key))
    key = "ESP_energy_fact_Whday": ESP_energy_fact_Whday = Cdbl_(dict.item(key))
    key = "ESP_cable_type": ESP_cable_type = Cdbl_(dict.item(key))
    key = "ESP_Hmes_m": ESP_Hmes_m = Cdbl_(dict.item(key))
    key = "GasDegtType": GasDegtType = Cdbl_(dict.item(key))
    key = "Kdegr": Kdegr = Cdbl_(dict.item(key))
    key = "PKV_work_min": PKV_work_min = Cdbl_(dict.item(key))
    key = "PKV_stop_min": PKV_stop_min = Cdbl_(dict.item(key))
' при создании объекта все должно пройти идеально
' переключаем режим реакции на ошибку
On Error GoTo er1:
    If getStr Then
         ESP_decode_string = ESP_encode_string(esp_ID, HeadNom_m, ESPfreq_Hz, _
                                               ESP_U_V, MotorPowerNom_kW, Tintake_C, Tdis_C, _
                                               ESP_energy_fact_Whday, ESP_cable_type, _
                                               ESP_Hmes_m, GasDegtType, Kdegr)
    Else
        If esp_ID > 0 Then
            If checkID_ESP(esp_ID) Then
                Set pmp = getESP(esp_ID)
                pmp.StageNum = pmp.Calc_ESP_NumStages(pmp.nom_rate_m3day, HeadNom_m) ' ESP_numStages
                pmp.freq_Hz = ESPfreq_Hz
                Set ESPsys = New CESPsystemSimple
                Set ESPsys.ESPpump = pmp
                ESPsys.U_V = ESP_U_V
                ESPsys.Power_motor_nom_W = MotorPowerNom_kW * 1000
                ESPsys.KSepGasSep_fr = KsepGS_fr
                ESPsys.Tintake_C = Tintake_C
                ESPsys.Tdis_C = Tdis_C
                
                ESPsys.Energy_fact_Whday = ESP_energy_fact_Whday
                ESPsys.setCable ESP_cable_type
                ESPsys.HmesTop_m = ESP_Hmes_m
                ESPsys.ESPpump.cfHead_fr = Kdegr
                ESPsys.ESPpump.GasDegrType = GasDegtType
                Call ESPsys.setPKV(PKV_work_min, PKV_stop_min)
                
            End If
        End If
        Set ESP_decode_string = ESPsys
    End If
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "ESP_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "well_decESP_decode_stringode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция расшифровки параметров работы
' газлифтной скважины закодированных в строке
Public Function wellGL_decode_string(well_GL_str As String, Optional ByVal getStr As Boolean = False)
' well_GL_str  - строка с параметрами газлифтной скважины
' getStr  - флаг проверки работы функции
'    по умолчанию False (0) - функция выдает объект CESPsystemSimple
'    если задать True - функция раскодирует строку и снова закодирует
'                       и выдаст строку (можно использовать из листа)
' результат - объект CESPsystemSimple
'description_end
    Dim hperf_m As Double
    Dim s As String
    Dim a, b
    Dim i As Integer
    
    Dim htub_m As Double
    Dim udl_m As Double
    Dim dcas_mm As Double
    Dim dtub_mm As Double
    Dim dchoke_mm As Double
    Dim roughness_m As Double
    Dim tbh_C As Double
    Dim twh_C As Double
    Dim GLV As Integer
    
    Dim dict As Dictionary
    Dim key As String
' при разбиении строки на части ошибки недопустимы
On Error GoTo er1:
    ' пытаемся разбить строку разделителями
    a = Split(well_GL_str, ";")
    ' перебираем и сохраняем все параметры
    For i = LBound(a) To UBound(a)
        ' только для непустых разбиений
        If a(i) <> "" Then
           b = Split(a(i), ":")
           'только там где есть значение
           If UBound(b) = 1 Then
               dict.item(b(0)) = b(1)
           End If
        End If
    Next i
' при считывании параметров со строки пытаемся выполнить чтение всех параметров
' с использование словаря - включаем режим после ошибки двигаться далее
On Error GoTo er2:
    ' при чтении параметров используем промежуточную переменную key
    ' чтобы иметь возможность более информативно отреагировать на ошибку
    key = "hperf_m": hperf_m = Cdbl_(dict.item(key))
    key = "htub_m": htub_m = Cdbl_(dict.item(key))
    key = "udl_m": udl_m = Cdbl_(dict.item(key))
    key = "dcas_mm": dcas_mm = Cdbl_(dict.item(key))
    key = "dtub_mm": dtub_mm = Cdbl_(dict.item(key))
    key = "dchoke_mm": dchoke_mm = Cdbl_(dict.item(key))
    key = "roughness_m": roughness_m = Cdbl_(dict.item(key))
    key = "tbh_C": tbh_C = Cdbl_(dict.item(key))
    key = "twh_C": twh_C = Cdbl_(dict.item(key))
    key = "GLV": GLV = Cdbl_(dict.item(key)) ' количество клапанов
    
    Dim H_glv_m() As Double
    Dim d_glv_mm() As Double
    Dim p_glv_atma() As Double
    ReDim H_glv_m(1 To GLV)
    ReDim d_glv_mm(1 To GLV)
    ReDim p_glv_atma(1 To GLV)
    
    For i = 1 To GLV
            key = "H_glv_m" & FormatInteger(i): H_glv_m(i) = Cdbl_(dict.item(key))
            key = "d_glv_mm" & FormatInteger(i): d_glv_mm(i) = Cdbl_(dict.item(key))
            key = "p_glv_atma" & FormatInteger(i): p_glv_atma(i) = Cdbl_(dict.item(key))
    Next i
    
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально при дешифровке
    
    
    If getStr Then
        wellGL_decode_string = wellGL_encode_string( _
                    hperf_m, _
                    htub_m, _
                    udl_m, _
                    dcas_mm, _
                    dtub_mm, _
                    dchoke_mm, _
                    roughness_m, _
                    tbh_C, _
                    twh_C, _
                    H_glv_m, _
                    d_glv_mm, _
                    p_glv_atma)
    Else
        Dim well As CWellGL
        Set well = NewWellGL()
      '  Call well.InitWell(hperf_m, htub_m, udl_m, dcas_mm, dtub_mm, tbh_C, twh_C)
        well.Choke.Dchoke_m = dchoke_mm
        well.HFlowCorrelation = BeggsBriilCor
        Set wellGL_decode_string = well
    End If
    
    Exit Function
er1:
    Dim errmsg As String
    errmsg = "wellGL_decode_string. error:" & Err.Description
    addLogMsg_debug errmsg
    Err.Raise kErrPVTinput, Err.Source, errmsg
    Exit Function
er2:
 '   On Error Resume Next
    addLogMsg "wellGL_decode_string: error reading PVT key: " & key & ":" & Err.Description
    Resume Next
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы скважины с газлифтом
Public Function wellGL_encode_string( _
                    Optional ByVal hperf_m As Double = 2000, _
                    Optional ByVal htub_m As Double = 1800, _
                    Optional ByVal udl_m As Double = 0, _
                    Optional ByVal dcas_mm As Double = 150, _
                    Optional ByVal dtub_mm As Double = 72, _
                    Optional ByVal dchoke_mm As Double = 15, _
                    Optional ByVal roughness_m As Double = 0.0001, _
                    Optional ByVal tbh_C As Double = 85, _
                    Optional ByVal twh_C As Double = 25, _
                    Optional HmesGLV_m = 0, _
                    Optional dGLV_mm = 0, _
                    Optional PsurfGLV_atma = 0)
' hperf_m       - измеренная глубина верхних дыр перфорации
'                 глубина пласта на которой рассчитывается
'                 забойное давление
' hpump_m       - измеренная глубина спуска насоса
' udl_m         - удлинение
'                 разница между измеренной и вертикальной
'                 глубиной пласта
' dcas_mm       - внутренний диаметр эксплуатационной колонны
' dtub_mm       - внешний диаметр НКТ
' dchoke_mm     - диаметр штуцера
' roughness_m   - шероховатость стенок НКТ и ЭК
' tbh_C         - температура флюида на забое скважины
' twh_C         - температура флюида на устье скважины
'                 по умолчанию температурный расчет идет
'                 такие образом, что температура флюида меняется
'                 линейно относительно вертикальной глубины
' результат     - строка с закодированными параметрами
'description_end
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim H_glv_m() As Variant
    Dim d_glv_mm() As Variant
    Dim p_glv_atma() As Variant
    
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "hperf_m:" & Format(hperf_m, frmt) & ";"
    str = str & "htub_m:" & Format(htub_m, frmt) & ";"
    str = str & "udl_m:" & Format(udl_m, frmt) & ";"
    str = str & "dcas_mm:" & Format(dcas_mm, frmt) & ";"
    str = str & "dtub_mm:" & Format(dtub_mm, frmt) & ";"
    str = str & "dchoke_mm:" & Format(dchoke_mm, frmt) & ";"
    str = str & "roughness_m:" & Format(roughness_m, frmt) & ";"
    str = str & "tbh_C:" & Format(tbh_C, frmt) & ";"
    str = str & "twh_C:" & Format(twh_C, frmt) & ";"
    
    H_glv_m = readRange(HmesGLV_m)
    d_glv_mm = readRange(dGLV_mm)
    p_glv_atma = readRange(PsurfGLV_atma)
    
    Dim i As Integer
    If (UBound(H_glv_m) = UBound(d_glv_mm)) And (UBound(H_glv_m) = UBound(p_glv_atma)) Then
        str = str & "GLV:" & FormatInteger(UBound(H_glv_m)) & ";"
        For i = LBound(H_glv_m) To UBound(H_glv_m)
            str = str & "H_glv_m" & FormatInteger(i) & ":" & FormatFReal(Cdbl_(H_glv_m(i))) & ";"
            str = str & "d_glv_mm" & FormatInteger(i) & ":" & FormatFReal(Cdbl_(d_glv_mm(i))) & ";"
            str = str & "p_glv_atma" & FormatInteger(i) & ":" & FormatFReal(Cdbl_(p_glv_atma(i))) & ";"
        Next i
    Else
        str = str & "GVL:0;error" & ";"
    End If
    
    wellGL_encode_string = str
    
End Function
Private Function readRange(rr)
    Dim ar() As Variant
    Dim arout() As Variant
        Dim i As Integer
        Dim j As Integer
On Error GoTo err1:
    If (TypeOf rr Is Range) Or IsArray(rr) Then
        If (TypeOf rr Is Range) Then
            If rr.Cells.Count = 1 Then
                ReDim ar(1 To 1, 1 To 1)
                ar(1, 1) = rr.Value
            Else
                ar = rr.Value
            End If
            j = 0
            For i = LBound(ar) To UBound(ar)
                If Not IsEmpty(ar(i, 1)) Then
                    j = j + 1
                    ReDim Preserve arout(1 To j)
                    arout(j) = ar(i, 1)
                End If
            Next i
        Else
            ReDim arout(LBound(rr) To UBound(rr))
            For i = LBound(rr) To UBound(rr)
                arout(i) = rr(i)
            Next i
        End If
    Else
        ReDim arout(1 To 1)
        arout(1) = rr
    End If
    readRange = arout
    Exit Function
err1:
    readRange = "error"
End Function
