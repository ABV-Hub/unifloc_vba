'=======================================================================================
'Unifloc7.5  Boinae                                           khabibullin.ra@gubkin.ru
'Библиотека расчетных модулей по нефтяному инжинирингу
'2000 - 2019 гг
'
'=======================================================================================
' вспомогательные функции для проведения расчетов из интерфейса Excel
Option Explicit
Public Function PVT_Encode_string( _
                    Optional ByVal gamma_gas As Double = const_gamma_gas_default, _
                    Optional ByVal gamma_oil As Double = const_gamma_oil_default, _
                    Optional ByVal gamma_wat As Double = const_gamma_wat_default, _
                    Optional ByVal rsb_m3m3 = const_Rsb_default, _
                    Optional ByVal Rp_m3m3 = -1, _
                    Optional ByVal Pb_atma = -1, _
                    Optional ByVal Tres_C = const_Tres_default, _
                    Optional ByVal Bob_m3m3 = -1, _
                    Optional ByVal Muob_cP = -1, _
                    Optional ByVal PVTcorr = StandingBased, _
                    Optional ByVal Ksep_fr = 0, _
                    Optional ByVal PKsep_atma = -1, _
                    Optional ByVal TKsep_C = -1 _
                    )
' функция кодирования значений PVT в строку, которую можно потом использовать
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.##0"
    frmt_int = "0"
    str = ""
    str = str & "gamma_gas:" & Format(gamma_gas, frmt) & ";"
    str = str & "gamma_oil:" & Format(gamma_oil, frmt) & ";"
    str = str & "gamma_wat:" & Format(gamma_wat, frmt) & ";"
    str = str & "rsb_m3m3:" & Format(rsb_m3m3, frmt) & ";"
    str = str & "Rp_m3m3:" & Format(Rp_m3m3, frmt) & ";"
    str = str & "Pb_atma:" & Format(Pb_atma, frmt) & ";"
    str = str & "Tres_C:" & Format(Tres_C, frmt) & ";"
    str = str & "Bob_m3m3:" & Format(Bob_m3m3, frmt) & ";"
    str = str & "Muob_cP:" & Format(Muob_cP, frmt) & ";"
    str = str & "PVTcorr:" & Format(PVTcorr, frmt_int) & ";"
    str = str & "Ksep_fr:" & Format(Ksep_fr, frmt) & ";"
    str = str & "PKsep_atma:" & Format(PKsep_atma, frmt) & ";"
    str = str & "TKsep_C:" & Format(TKsep_C, frmt) & ";"
    PVT_Encode_string = str
    
End Function
Public Function PVT_Decode_string(PVTStr As String, Optional ByVal getStr As Boolean = False)
' функция расшифровки значений PVT свойств
    Dim a
    Dim s As String
    Dim i As Integer
    Dim B
    Dim P_atma As Double
    Dim T_C, gamma_gas As Double, gamma_oil As Double, _
               gamma_wat As Double, rsb_m3m3 As Double, Rp_m3m3 As Double, _
              Pb_atma As Double, Tres_C As Double, Bob_m3m3 As Double, Muob_cP As Double _
              , PVTcorr, Ksep_fr As Double, PKsep_atma As Double, TKsep_C As Double
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально при дешифровке
'
    
    s = PVTStr '.Cells(1, 1).Value2
    
    a = Split(s, ";")
    i = 0
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "gamma_gas" And B(1) <> "" Then
        gamma_gas = CDbl(B(1))
    End If
    B = Split(a(i), ":")
    i = i + 1
        
    If B(0) = "gamma_oil" And B(1) <> "" Then gamma_oil = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "gamma_wat" And B(1) <> "" Then gamma_wat = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "rsb_m3m3" And B(1) <> "" Then rsb_m3m3 = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Rp_m3m3" And B(1) <> "" Then Rp_m3m3 = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Pb_atma" And B(1) <> "" Then
        Pb_atma = CDbl(B(1))
    ElseIf B(1) = "" Then
        ' калибровочный параметр проверяем специально и не даем сохраниться значению по умолчанию
        ' если он неправильно указан (дублируется инициализацией в конструкторе, но все же)
        Pb_atma = -1
    End If
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Tres_C" And B(1) <> "" Then Tres_C = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Bob_m3m3" And B(1) <> "" Then
        ' калибровочный параметр проверяем специально и не даем сохраниться значению по умолчанию
        ' если он неправильно указан (дублируется инициализацией в конструкторе, но все же)
        Bob_m3m3 = CDbl(B(1))
    ElseIf B(1) = "" Then
        Bob_m3m3 = -1
    End If
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Muob_cP" And B(1) <> "" Then
        ' калибровочный параметр проверяем специально и не даем сохраниться значению по умолчанию
        ' если он неправильно указан (дублируется инициализацией в конструкторе, но все же)
        Muob_cP = CDbl(B(1))
    ElseIf B(1) = "" Then
        Muob_cP = -1
    End If
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "PVTcorr" And B(1) <> "" Then PVTcorr = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Ksep_fr" And B(1) <> "" Then Ksep_fr = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "PKsep_atma" And B(1) <> "" Then PKsep_atma = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "TKsep_C" And B(1) <> "" Then TKsep_C = CDbl(B(1))
    
    Dim PVT As New CPVT
    PVT.Init gamma_gas, gamma_oil, gamma_wat, rsb_m3m3, Pb_atma, Bob_m3m3, PVTcorr, Tres_C, Rp_m3m3, Muob_cP
    If Ksep_fr > 0 And Ksep_fr <= 1 And PKsep_atma > 0 And TKsep_C > 0 Then
        Call PVT.ModAfterSeparation(PKsep_atma, TKsep_C, Ksep_fr, GasGoesIntoSolution)
    End If
    If getStr Then
        PVT_Decode_string = PVT_Encode_string(gamma_gas, gamma_oil, _
               gamma_wat, rsb_m3m3, Rp_m3m3, _
              Pb_atma, Tres_C, Bob_m3m3, Muob_cP, PVTcorr, Ksep_fr, PKsep_atma, _
              TKsep_C)
    Else
        Set PVT_Decode_string = PVT
    End If
    Exit Function
er1:
    addLogMsg_debug "PVT_Decode_string. error reading PVT str:", PVTStr
    Err.Raise vbObjectError + 1, , "PVT_Decode_string. error reading PVT str"
    
End Function
Public Function Well_Encode_string( _
                    Optional ByVal Hperf_m As Double = 2000, _
                    Optional ByVal Hpump_m As Double = 1800, _
                    Optional ByVal Udl_m As Double = 0, _
                    Optional ByVal dCas_mm As Double = 150, _
                    Optional ByVal dTub_mm As Double = 72, _
                    Optional ByVal dchoke_mm As Double = 15, _
                    Optional ByVal roughness_m As Double = 0.0001, _
                    Optional ByVal Tbh_C As Double = 85, _
                    Optional ByVal Twh_C As Double = 25)
' функция кодирования значений PVT в строку, которую можно потом использовать
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "Hperf_m:" & Format(Hperf_m, frmt) & ";"
    str = str & "Hpump_m:" & Format(Hpump_m, frmt) & ";"
    str = str & "Udl_m:" & Format(Udl_m, frmt) & ";"
    str = str & "dCas_mm:" & Format(dCas_mm, frmt) & ";"
    str = str & "dTub_mm:" & Format(dTub_mm, frmt) & ";"
    str = str & "dchoke_mm:" & Format(dchoke_mm, frmt) & ";"
    str = str & "roughness_m:" & Format(roughness_m, frmt) & ";"
    str = str & "Tbh_C:" & Format(Tbh_C, frmt) & ";"
    str = str & "Twh_C:" & Format(Twh_C, frmt) & ";"
    Well_Encode_string = str
    
End Function
Public Function Well_Decode_string(wellStr As String, Optional ByVal getStr As Boolean = False)
' функция расшифровки значений PVT свойств
    Dim a
    Dim s As String
    Dim i As Integer
    Dim B
    Dim P_atma As Double
    Dim Hperf_m As Double
    Dim Hpump_m As Double
    Dim Udl_m As Double
    Dim dCas_mm As Double
    Dim dTub_mm As Double
    Dim dchoke_mm As Double
    Dim roughness_m As Double
    Dim Tbh_C As Double
    Dim Twh_C As Double
    Dim well As CWell
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально при дешифровке
'
    
    s = wellStr '.Cells(1, 1).Value2
    
    a = Split(s, ";")
    i = 0
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Hperf_m" And B(1) <> "" Then Hperf_m = CDbl(B(1))
    B = Split(a(i), ":"):    i = i + 1
    If B(0) = "Hpump_m" And B(1) <> "" Then Hpump_m = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Udl_m" And B(1) <> "" Then Udl_m = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "dCas_mm" And B(1) <> "" Then dCas_mm = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "dTub_mm" And B(1) <> "" Then dTub_mm = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "dchoke_mm" And B(1) <> "" Then dchoke_mm = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "roughness_m" And B(1) <> "" Then roughness_m = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Tbh_C" And B(1) <> "" Then Tbh_C = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Twh_C" And B(1) <> "" Then Twh_C = CDbl(B(1))
    
    If getStr Then
         Well_Decode_string = Well_Encode_string(Hperf_m, Hpump_m, Udl_m, _
                                                    dCas_mm, dTub_mm, dchoke_mm, roughness_m, _
                                                    Tbh_C, Twh_C)
    Else
        Set well = New CWell
        well.InitWell Hperf_m, Hpump_m, Udl_m, dCas_mm, dTub_mm, Tbh_C, Twh_C
        well.SetChoke dchoke_mm, dTub_mm
            
        well.TempCorrelation = StartEndTemp ' AmbientTemp
        
        If well.TempCorrelation = StartEndTemp Then
            Call well.InitTempLinear(Tbh_C, Twh_C)
        End If
        Set Well_Decode_string = well
    End If
    Exit Function
er1:
    addLogMsg_debug "Well_Decode_string. error reading well str:", wellStr
    Err.Raise vbObjectError + 1, , "well_Decode_string. error reading well str"
    
End Function
Public Function ESP_Encode_string( _
                    Optional ByVal ESP_ID As Double = 0, _
                    Optional ByVal HeadNom_m As Double = 2000, _
                    Optional ByVal ESPfreq_Hz As Double = 50, _
                    Optional ByVal ESP_U_V As Double = 1000, _
                    Optional ByVal MotorPowerNom_kW As Double = 30, _
                    Optional ByVal Tint_C As Double = 85, _
                    Optional ByVal Tdis_C As Double = 25, _
                    Optional ByVal KsepGS_fr As Double = 0)
' функция кодирования значений PVT в строку, которую можно потом использовать
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    frmt = "#0.####0"
    frmt_int = "0"
    str = ""
    str = str & "ESP_ID:" & Format(ESP_ID, frmt) & ";"
    str = str & "HeadNom_m:" & Format(HeadNom_m, frmt) & ";"
    str = str & "ESPfreq_Hz:" & Format(ESPfreq_Hz, frmt) & ";"
    str = str & "ESP_U_V:" & Format(ESP_U_V, frmt) & ";"
    str = str & "MotorPowerNom_kW:" & Format(MotorPowerNom_kW, frmt) & ";"
    str = str & "Tint_C:" & Format(Tint_C, frmt) & ";"
    str = str & "Tdis_C:" & Format(Tdis_C, frmt) & ";"
    str = str & "KsepGS_fr:" & Format(KsepGS_fr, frmt) & ";"
    ESP_Encode_string = str
    
End Function
Public Function ESP_Decode_string(ESPStr As String, Optional ByVal getStr As Boolean = False)
' функция расшифровки значений PVT свойств
    Dim a
    Dim s As String
    Dim i As Integer
    Dim B
    Dim P_atma As Double
    Dim ESP_ID As Double
    Dim HeadNom_m As Double
    Dim ESPfreq_Hz As Double
    Dim ESP_U_V As Double
    Dim MotorPowerNom_kW As Double
    Dim Tint_C As Double
    Dim Tdis_C As Double
    Dim KsepGS_fr As Double
    Dim ESPsys As CESPsystemSimple
    Dim pmp As CESPpump
On Error GoTo er1:
' ловим все ошибки, все должно пройти идеально при дешифровке
'
    
    s = ESPStr '.Cells(1, 1).Value2
    
    a = Split(s, ";")
    i = 0
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "ESP_ID" And B(1) <> "" Then ESP_ID = CDbl(B(1))
    B = Split(a(i), ":"):    i = i + 1
    If B(0) = "HeadNom_m" And B(1) <> "" Then HeadNom_m = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "ESPfreq_Hz" And B(1) <> "" Then ESPfreq_Hz = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "ESP_U_V" And B(1) <> "" Then ESP_U_V = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "MotorPowerNom_kW" And B(1) <> "" Then MotorPowerNom_kW = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Tint_C" And B(1) <> "" Then Tint_C = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "Tdis_C" And B(1) <> "" Then Tdis_C = CDbl(B(1))
    B = Split(a(i), ":"): i = i + 1
    If B(0) = "KsepGS_fr" And B(1) <> "" Then KsepGS_fr = CDbl(B(1))
    
    If getStr Then
         ESP_Decode_string = ESP_Encode_string(ESP_ID, HeadNom_m, ESPfreq_Hz, _
                                                    ESP_U_V, MotorPowerNom_kW, Tint_C, Tdis_C)
    Else
        If ESP_ID > 0 Then
            If checkID_ESP(ESP_ID) Then
                Set pmp = getESP(ESP_ID)
                pmp.StageNum = pmp.Calc_ESP_NumStages(pmp.NominalRate_m3day, HeadNom_m) ' ESP_numStages
                pmp.freq_Hz = ESPfreq_Hz
                Set ESPsys = New CESPsystemSimple
                Set ESPsys.ESPpump = pmp
                ESPsys.U_V = ESP_U_V
                ESPsys.Power_nom_W = MotorPowerNom_kW * 1000
                ESPsys.KSepGasSep_fr = KsepGS_fr
                ESPsys.Tint_C = Tint_C
                ESPsys.Tdis_C = Tdis_C
            End If
        End If
        Set ESP_Decode_string = ESPsys
    End If
    Exit Function
er1:
    addLogMsg_debug "ESP_Decode_string. error reading well str:", ESPStr
    Err.Raise vbObjectError + 1, , "esp_Decode_string. error reading esp str"
    
End Function
