''=======================================================================================
''Unifloc 7.9  Vulpes zerda                                           khabibullin.ra@gubkin.ru
''Petroleum engineering calculations modules (macroses)
''2000 - 2019
''
''=======================================================================================
'' математические расчеты
''
''
''
''
'
'
Option Explicit
'
'Public Const MachineEpsilon = 5E-16
'Public Const MaxRealNumber = 1E+300
'Public Const MinRealNumber = 1E-300
'
'Private Const BigNumber As Double = 1E+70
'Private Const SmallNumber As Double = 1E-70
'
'
'Public Type Complex
'    X As Double
'    Y As Double
'End Type
'
''Data types
'
'
'Public Type RCommState
'    Stage As Long
'    BA() As Boolean
'    IA() As Long
'    RA() As Double
'    CA() As Complex
'End Type
'
'Public Type ALGLIBDataset
'    NIn As Long
'    NOut As Long
'    NClasses As Long
'
'    Trn() As Double
'    Tst() As Double
'    Val() As Double
'    AllDataset() As Double
'
'    TrnSize As Long
'    TstSize As Long
'    ValSize As Long
'    TotalSize As Long
'End Type
'
'
'
'
'
'
'
'Function tand(ang) As Double
' tand = Tan(ang / 180 * const_Pi)
'End Function
'
'
Function cosd(ang) As Double
 cosd = Cos(ang / 180 * const_Pi)
End Function
Function sind(ang) As Double
 sind = Sin(ang / 180 * const_Pi)
End Function
'Public Function min(A As Double, B As Double) As Double
'  If A < B Then min = A Else min = B
'End Function
'
'Public Function max(A As Double, B As Double) As Double
'  If A > B Then max = A Else max = B
'End Function
'Public Function Log10(X As Double) As Double
' Log10 = Log(X) / Log(10#)
'End Function
'
Public Function isEqual(A As Double, B As Double) As Double
    Const Eps = const_P_difference
    isEqual = False
    If Abs(A - B) < Eps Then isEqual = True
End Function
Public Function isGreater(A As Double, B As Double) As Double
    Const Eps = const_P_difference
    isGreater = False
    If (A - B) > Eps Then isGreater = True
End Function
Public Function isBetween(A As Double, a0 As Double, A1 As Double)
    isBetween = False
    If ((A <= a0) And (A >= A1)) Or ((A >= a0) And (A <= A1)) Then isBetween = True
End Function
'Public Function ArcCos(ByVal X As Double) As Double
'    Dim T As Double
'    T = Sqr(1 - X * X)
'    If T < SmallNumber Then
'        ArcCos = Atn(BigNumber * Sgn(-X)) + 2 * Atn(1)
'    Else
'        ArcCos = Atn(-X / T) + 2 * Atn(1)
'    End If
'End Function
'
'
'Public Function ArcSin(ByVal X As Double) As Double
'    Dim T As Double
'    T = Sqr(1 - X * X)
'    If T < SmallNumber Then
'        ArcSin = Atn(BigNumber * Sgn(X))
'    Else
'        ArcSin = Atn(X / T)
'    End If
'End Function
'
'
'Public Function ArcTan(X As Double) As Double
'  'Inverse Tangent
'    On Error Resume Next
'        ArcTan = Atn(X) '* (180 / pi)
'    On Error GoTo 0
'End Function
'
'
'Public Function MaxReal(ByVal M1 As Double, ByVal M2 As Double) As Double
'    If M1 > M2 Then
'        MaxReal = M1
'    Else
'        MaxReal = M2
'    End If
'End Function
'
'Public Function MinReal(ByVal M1 As Double, ByVal M2 As Double) As Double
'    If M1 < M2 Then
'        MinReal = M1
'    Else
'        MinReal = M2
'    End If
'End Function
'
'Public Function MaxInt(ByVal M1 As Long, ByVal M2 As Long) As Long
'    If M1 > M2 Then
'        MaxInt = M1
'    Else
'        MaxInt = M2
'    End If
'End Function
'
'Public Function MinInt(ByVal M1 As Long, ByVal M2 As Long) As Long
'    If M1 < M2 Then
'        MinInt = M1
'    Else
'        MinInt = M2
'    End If
'End Function
'
'
'
'
'Public Function SinH(ByVal X As Double) As Double
'    SinH = (Exp(X) - Exp(-X)) / 2
'End Function
'
'Public Function CosH(ByVal X As Double) As Double
'    CosH = (Exp(X) + Exp(-X)) / 2
'End Function
'
'Public Function TanH(ByVal X As Double) As Double
'    Dim T As Double
'    If X > 0 Then
'        T = Exp(-X)
'        T = T * T
'        TanH = (1 - T) / (1 + T)
'    Else
'        T = Exp(X)
'        T = T * T
'        TanH = (T - 1) / (T + 1)
'    End If
'End Function
'
'
'Public Function Power(ByVal Base As Double, ByVal Exponent As Double) As Double
'    Power = Base ^ Exponent
'End Function
'
'Public Function Square(ByVal X As Double) As Double
'    Square = X * X
'End Function
'
'
'Public Function Ceil(ByVal X As Double) As Double
'    Ceil = -Int(-X)
'End Function
'
'Public Function RandomInteger(ByVal X As Long) As Long
'    RandomInteger = Int(Rnd() * X)
'End Function
'
'Public Function Atn2(ByVal Y As Double, ByVal X As Double) As Double
'    If SmallNumber * Abs(Y) < Abs(X) Then
'        If X < 0 Then
'            If Y = 0 Then
'                Atn2 = const_Pi
'            Else
'                Atn2 = Atn(Y / X) + const_Pi * Sgn(Y)
'            End If
'        Else
'            Atn2 = Atn(Y / X)
'        End If
'    Else
'        Atn2 = Sgn(Y) * const_Pi / 2
'    End If
'End Function
'
'
'' ===========================================================================================
''  math_complex
'' ===========================================================================================
'
''=======================================================================================
''Unifloc 7.9  Vulpes zerda                                           khabibullin.ra@gubkin.ru
''Petroleum engineering calculations modules (macroses)
''2000 - 2019
''
''=======================================================================================
'
'
'
'
'
'Public Function C_Complex(ByVal X As Double) As Complex
'    Dim Result As Complex
'
'    Result.X = X
'    Result.Y = 0
'
'    C_Complex = Result
'End Function
'
'
'Public Function AbsComplex(ByRef Z As Complex) As Double
'    Dim Result As Double
'    Dim W As Double
'    Dim XABS As Double
'    Dim YABS As Double
'    Dim V As Double
'
'    XABS = Abs(Z.X)
'    YABS = Abs(Z.Y)
'    W = MaxReal(XABS, YABS)
'    V = MinReal(XABS, YABS)
'    If V = 0 Then
'        Result = W
'    Else
'        Result = W * Sqr(1 + Square(V / W))
'    End If
'
'    AbsComplex = Result
'End Function
'
'
'Public Function C_Opposite(ByRef Z As Complex) As Complex
'    Dim Result As Complex
'
'    Result.X = -Z.X
'    Result.Y = -Z.Y
'
'    C_Opposite = Result
'End Function
'
'
'Public Function Conj(ByRef Z As Complex) As Complex
'    Dim Result As Complex
'
'    Result.X = Z.X
'    Result.Y = -Z.Y
'
'    Conj = Result
'End Function
'
'
'Public Function CSqr(ByRef Z As Complex) As Complex
'    Dim Result As Complex
'
'    Result.X = Square(Z.X) - Square(Z.Y)
'    Result.Y = 2 * Z.X * Z.Y
'
'    CSqr = Result
'End Function
'
'
'Public Function C_Add(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
'    Dim Result As Complex
'
'    Result.X = Z1.X + Z2.X
'    Result.Y = Z1.Y + Z2.Y
'
'    C_Add = Result
'End Function
'
'
'Public Function C_Mul(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
'    Dim Result As Complex
'
'    Result.X = Z1.X * Z2.X - Z1.Y * Z2.Y
'    Result.Y = Z1.X * Z2.Y + Z1.Y * Z2.X
'
'    C_Mul = Result
'End Function
'
'
'Public Function C_AddR(ByRef Z1 As Complex, ByVal R As Double) As Complex
'    Dim Result As Complex
'
'    Result.X = Z1.X + R
'    Result.Y = Z1.Y
'
'    C_AddR = Result
'End Function
'
'
'Public Function C_MulR(ByRef Z1 As Complex, ByVal R As Double) As Complex
'    Dim Result As Complex
'
'    Result.X = Z1.X * R
'    Result.Y = Z1.Y * R
'
'    C_MulR = Result
'End Function
'
'
'Public Function C_Sub(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
'    Dim Result As Complex
'
'    Result.X = Z1.X - Z2.X
'    Result.Y = Z1.Y - Z2.Y
'
'    C_Sub = Result
'End Function
'
'
'Public Function C_SubR(ByRef Z1 As Complex, ByVal R As Double) As Complex
'    Dim Result As Complex
'
'    Result.X = Z1.X - R
'    Result.Y = Z1.Y
'
'    C_SubR = Result
'End Function
'
'
'Public Function C_RSub(ByVal R As Double, ByRef Z1 As Complex) As Complex
'    Dim Result As Complex
'
'    Result.X = R - Z1.X
'    Result.Y = -Z1.Y
'
'    C_RSub = Result
'End Function
'
'
'Public Function C_Div(ByRef Z1 As Complex, ByRef Z2 As Complex) As Complex
'    Dim Result As Complex
'    Dim A As Double
'    Dim B As Double
'    Dim C As Double
'    Dim D As Double
'    Dim E As Double
'    Dim F As Double
'
'    A = Z1.X
'    B = Z1.Y
'    C = Z2.X
'    D = Z2.Y
'    If Abs(D) < Abs(C) Then
'        E = D / C
'        F = C + D * E
'        Result.X = (A + B * E) / F
'        Result.Y = (B - A * E) / F
'    Else
'        E = C / D
'        F = D + C * E
'        Result.X = (B + A * E) / F
'        Result.Y = (-A + B * E) / F
'    End If
'
'    C_Div = Result
'End Function
'
'
'Public Function C_DivR(ByRef Z1 As Complex, ByVal R As Double) As Complex
'    Dim Result As Complex
'
'    Result.X = Z1.X / R
'    Result.Y = Z1.Y / R
'
'    C_DivR = Result
'End Function
'
'
'Public Function C_RDiv(ByVal R As Double, ByRef Z2 As Complex) As Complex
'    Dim Result As Complex
'    Dim A As Double
'    Dim C As Double
'    Dim D As Double
'    Dim E As Double
'    Dim F As Double
'
'    A = R
'    C = Z2.X
'    D = Z2.Y
'    If Abs(D) < Abs(C) Then
'        E = D / C
'        F = C + D * E
'        Result.X = A / F
'        Result.Y = -(A * E / F)
'    Else
'        E = C / D
'        F = D + C * E
'        Result.X = A * E / F
'        Result.Y = -(A / F)
'    End If
'
'    C_RDiv = Result
'End Function
'
'
'Public Function C_Equal(ByRef Z1 As Complex, ByRef Z2 As Complex) As Boolean
'    Dim Result As Boolean
'
'    Result = Z1.X = Z2.X And Z1.Y = Z2.Y
'
'    C_Equal = Result
'End Function
'
'
'Public Function C_NotEqual(ByRef Z1 As Complex, _
'         ByRef Z2 As Complex) As Boolean
'    Dim Result As Boolean
'
'    Result = Z1.X <> Z2.X Or Z1.Y <> Z2.Y
'
'    C_NotEqual = Result
'End Function
'
'Public Function C_EqualR(ByRef Z1 As Complex, ByVal R As Double) As Boolean
'    Dim Result As Boolean
'
'    Result = Z1.X = R And Z1.Y = 0
'
'    C_EqualR = Result
'End Function
'
'
'Public Function C_NotEqualR(ByRef Z1 As Complex, _
'         ByVal R As Double) As Boolean
'    Dim Result As Boolean
'
'    Result = Z1.X <> R Or Z1.Y <> 0
'
'    C_NotEqualR = Result
'End Function
'
'
'
'
'
Private Function get_array(a_name As Variant) As Variant
    Dim one_cell(1 To 1, 1 To 1) As Variant
    
    If TypeName(a_name) = "Range" Then a_name = a_name.Value2
    
    If IsArray(a_name) = True Then
        get_array = a_name
    Else
        one_cell(1, 1) = a_name
        get_array = one_cell
    End If
End Function
' Convert variant arrays (which will always be base
' 1, 2 dimension arrays) into the form required by the AlgLib
' routines, which will always be base 0, and may be 1 or 2 dimensional.
Function variant_arr_to_double_1D_0(XL_A As Variant, _
                              ByRef AL_A() As Double, _
                              ByRef Nrows As Long, _
                              ByRef Ncols As Long) As Long
Dim i As Long, j As Long, LB As Long
On Error GoTo iErr
    If TypeName(XL_A) = "Range" Then XL_A = XL_A.Value2
    LB = LBound(XL_A)
    Nrows = UBound(XL_A)
    Ncols = UBound(XL_A, 2)
    ' Copy 2D base 1 variant array to 1D base 0 double array
    ReDim AL_A(0 To Nrows * Ncols - 1)
    For i = 1 To Nrows
        For j = 1 To Ncols
            AL_A((i - 1) * Ncols + j - 1) = XL_A(i, j)
        Next j
    Next i
    variant_arr_to_double_1D_0 = 0
Exit Function
iErr:
    variant_arr_to_double_1D_0 = 1
End Function
' функция решения ОДУ методом Кэш Карпа (Cash-Karp adaptive ODE solver)
' Решается ОДУ вида  Y'=f(Y,x)  с начальными устьвиями Y(xs)=Ys
' Y или одна переменная или вектор размерности N.
Public Function ode_solve(ByVal func_name As String, _
                          Y0() As Double, _
                          XA() As Double, _
                          coeffA As Variant, _
                 Optional Eps As Double = 0.000001, _
                 Optional Step As Double = 10, _
                 Optional MaxIts As Long = 1000)
' func_name         - имя функции  f(x)
' Y0                - начальное значение для расчета
' XA                - значения аргумента для которых ищем решение
' CoeffA            - дополнительные параметры функции градиента
' Eps
' Step
' MaxIts
    Dim M As Long, N As Long, State As ODESolverState, _
    YA() As Double, i As Long, _
    rtn As Boolean, rep As ODESolverReport
  
    N = UBound(Y0) + 1
    M = UBound(XA) + 1
    'Set up any required output arrays
    ReDim YA(0 To M - 1, 0 To N - 1)
    
    'Call the appropriate AlgLib routine to initialise the State object
    Call ODESolverRKCK(Y0(), N, XA, M, Eps, Step, State)
    
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "FuncName" is called using
    ' the Application.Run method.
    rtn = True
    i = 0
    Do While rtn = True And i < MaxIts
        rtn = ODESolverIteration(State)
        State.DY(0) = Application.Run(func_name, State.x, State.Y(0), coeffA(0))(0)
        i = i + 1
    Loop
    
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
     Call ODESolverResults(State, M, XA, YA, rep)
    
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    
    ' Assign the output array to the function return value
     ode_solve = YA
End Function
' функция расчета градиента давления для одномерной задачи
Public Function calc_grad_1d(ByVal l_m As Double, _
                             ByVal p_atma As Double, _
                             pipe As CPipe) As Double()
    Dim out(1) As Double
    Dim res As PIPE_FLOW_PARAMS
    With pipe
        res = pipe.calc_grad(l_m, p_atma, pipe.Tinit_C(l_m), calc_dtdl:=False)
    End With
    out(0) = res.dp_dl
    calc_grad_1d = out
End Function
