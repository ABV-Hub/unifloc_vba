''=======================================================================================
''Unifloc 7.9  Vulpes zerda                                           khabibullin.ra@gubkin.ru
''Petroleum engineering calculations modules (macroses)
''2000 - 2019
''
''=======================================================================================
'' математические расчеты
''
''
''
''
'
'
Option Explicit
Function cosd(ang) As Double
 cosd = Cos(ang / 180 * const_Pi)
End Function
Function sind(ang) As Double
 sind = Sin(ang / 180 * const_Pi)
End Function
Public Function isEqual(a As Double, B As Double) As Double
    Const EPS = const_P_difference
    isEqual = False
    If Abs(a - B) < EPS Then isEqual = True
End Function
Public Function isGreater(a As Double, B As Double) As Double
    Const EPS = const_P_difference
    isGreater = False
    If (a - B) > EPS Then isGreater = True
End Function
Public Function isBetween(a As Double, a0 As Double, A1 As Double)
    isBetween = False
    If ((a <= a0) And (a >= A1)) Or ((a >= a0) And (a <= A1)) Then isBetween = True
End Function
' функция решения ОДУ методом Кэш Карпа (Cash-Karp adaptive ODE solver)
' Решается ОДУ вида  Y'=f(Y,x)  с начальными устьвиями Y(xs)=Ys
' Y или одна переменная или вектор размерности N.
Public Function solve_ode(ByVal func_name As String, _
                          Y0() As Double, _
                          XA() As Double, _
                          coeffA As Variant, _
                 Optional EPS As Double = 0.000001, _
                 Optional Step As Double = 10, _
                 Optional MaxIts As Long = 1000)
' func_name         - имя функции  f(x)
' Y0                - начальное значение для расчета
' XA                - значения аргумента для которых ищем решение
' CoeffA            - дополнительные параметры функции градиента
' Eps
' Step
' MaxIts
    Dim M As Long, N As Long, State As ODESolverState, _
    YA() As Double, i As Long, _
    Rtn As Boolean, Rep As ODESolverReport
    Dim r() As Double
  
    N = UBound(Y0) + 1
    M = UBound(XA) + 1
    'Set up any required output arrays
    ReDim YA(0 To M - 1, 0 To N - 1)
    
    'Call the appropriate AlgLib routine to initialise the State object
    Call ODESolverRKCK(Y0(), N, XA, M, EPS, Step, State)
    
    ' Loop through the AlgLib solver routine and the external ODE
    ' evaluation routine until the solver routine returns "False",
    ' which indicates that it has finished.
    ' The VBA function named in "func_name" is called using
    ' the Application.Run method.
    Rtn = True
    i = 0
    Do While Rtn = True And i < MaxIts
        Rtn = ODESolverIteration(State)
        r = Application.Run(func_name, State.x, State.Y, coeffA(0))
        State.DY(0) = r(0)
        i = i + 1
    Loop
    
     ' Extract the desired results from the State
     ' object using the appropriate AlgLib routine
     Call ODESolverResults(State, M, XA, YA, Rep)
    
    ' If necessary convert the AlgLib output array(s) to
    ' a form suitable for Excel.  In this case YA2 is
    ' a 2D base 0 array, which may be assigned to the
    ' function return value without further processing.
    
    ' Assign the output array to the function return value
     solve_ode = YA
End Function
' функция ищет корни уравнения вида
' f(x) = 0 на отрезке [x1..x2]
Public Function solve_equation_bisection(func_name As String, _
                                         x1 As Double, _
                                         x2 As Double, _
                                         coeffA, _
                                         prm As CSolveParam) As Boolean
' func_name             - название функции для которой ищем решение
' x1                    - левая граница аргумента для поиска решения
' x2                    - правая граница аргумента для поиска решения
' coeffA                - параметры функции для которой ищем решение
' prm                   - объект с настройками поиска решения
'                         через этот же объект возвращаются решение и его параметры
    Dim y1 As Double
    Dim y2 As Double
    Dim y_temp As Double
    Dim x_temp As Double
    Dim i As Long
    i = 0
    
    ' определим значения параметров на границе
    y1 = Application.Run(func_name, x1, coeffA)
    y2 = Application.Run(func_name, x2, coeffA)
    With prm
        If y1 * y2 > 0 Then
            ' если значения на границе одного знака - то метод поиска решения не работает
            ' возможно решения нет и найти его не получится
            .iterations = 0
            .found_solution = False
            .msg = "solve_equation_bisection: Значения на концах отрезка должны иметь разный знак"
            solve_equation_bisection = False
            Exit Function
        End If
        ' начинаем цикл поиска решений (итерации)
        Do
            i = i + 1
            ' делим отрезок пополам
            x_temp = (x1 + x2) / 2
            y_temp = Application.Run(func_name, x_temp, coeffA)
            If Abs(y_temp) < .y_tolerance + 0.1 Then
                solve_equation_bisection = True
                .x_solution = x_temp
                .y_solution = y_temp
                .iterations = i
                .found_solution = True
                Exit Function
            Else
                If y_temp * y1 > 0 Then
                    x1 = x_temp
                    y1 = y_temp
                Else
                    x2 = x_temp
                    y2 = y_temp
                End If
            End If
        Loop Until i >= 100
    End With
    
End Function
