''=======================================================================================
''Unifloc 7.7  Vulpes zerda                                           khabibullin.ra@gubkin.ru
''Petroleum engineering calculations modules (macroses)
''2000 - 2019
''
''=======================================================================================
'' класс для расчета системы - пласт - скважина - оборудование - совместный расчет пласта и скважины
'' один из ключевых классов для решения практических задач
'' обеспечивает решение задачи узлового анализа - расчет совместной работы скважины и пласта
' Option Explicit
'
' Private p_fluid As CPVT
' Private ESPdesign As New CESPpump              ' специальный насос с постоянным напором для расчета дизайна
' ' параметры пласта
' Private P_Reservoir As New CReservoirVogel
' ' параметры скважины
' Private WithEvents p_well As CWellESP
' Private WithEvents WellAnalyse As CWellESP                ' скважина для проведения построения графиков при проведении анализа
' Private WithEvents WellAnalyseTopDown As CWellESP         ' скважина для расчета кривой оттока с учетом УЭЦН
' Private WithEvents WellDesign As CWellESP                 ' скважина для расчета дизайна
' Private WithEvents WellSelfFlow As CWellESP               ' скважина без ЭЦН для расчета режимов фонтанирования
' ' параметры дизайна УЭЦН
' Private p_Pwfdesign_atma As Double              ' целевое забойное давления для дизайна УЭЦН
' Private p_Qldesign_m3day As Double             ' целевой дебит на поверхности для дизайна УЭЦН
' Private p_ESPdesignHead_m As Double            ' целевой напор установки для дизайна УЭЦН
' Private p_ESPdesigndP_atma As Double            ' целевой перепад давления который должна обеспечивать установка
' Private p_ESPdesignRate_m3day As Double        ' целевой дебит смеси через установки (номинальный дебит УЭЦН)
' Private p_ESPdesignPower_W As Double           ' целевая мощность потребляемая ЭЦН (мощность которую должен выдавать двигатель)
'  ' параметры скважины
' Private p_twh_C As Double
' Private p_tbh_C As Double
' Private p_Qgfree_scm3day As Double
' Private p_Error_msg As String
' ' параметры решения системы
' Private p_PwfSol_atma As Double
' Private p_PISol_m3dayatm As Double
'' набор кривых для описания системы добычи нефти
' Private c_Curves As New Collection     ' коллекция кривых с результатами расчетов
'
' Private c_PS_curve As New TInterpolation           ' системная кривая - разность кривой оттока и кривой притока
' Private c_VLP_curve As New TInterpolation          ' кривая оттока для скважины - зависимость забойного давления от дебита (с учетом работы оборудования)
' Private c_VLPselfFlowing_curve As New TInterpolation   ' кривая оттока для фонтанирующей скважины (при отсутствии сепарации)
' Private c_VLP_ESP_curve As New TInterpolation      ' кривая оттока с учетом УЭЦН
' Private c_IPR_curve As New TInterpolation          ' кривая притока к скважине - зависимость забойного давления от дебита со стороны пласта
' Private c_PintakeQl_curve As New TInterpolation    ' кривая зависимости давления на приеме от дебита, учет пласта и участка трубы ниже насоса
' Private c_PdischargeDesignQl_curve As New TInterpolation ' кривая зависимости давления на выкиде насоса от дебита, учет потока по НКТ выше насоса с учетом Ксепарации(давления на приеме)
' Private c_PdischargeESPQl_curve As New TInterpolation ' кривая давления на выкиде от дебита расчитанная через УЭЦН
' Private c_PwhQl_curve As New TInterpolation          ' кривая зависимости давления на устье (буфере) от забойного давления (дебита), учет пласта и скважины и скважинного оборудования
' Private c_HdynQl_curve As New TInterpolation
' Private c_PanQl_curve As New TInterpolation
' Private c_PlinQl_curve As New TInterpolation
' Private c_HeadRequiredQl_curve As New TInterpolation     ' кривая необходимого напора для скважины - дизайн УЭЦН, зависит от требуемого перепада давления
' Private c_GasFarctionQl_curve As New TInterpolation      ' кривая доли газа для дизайна
' Private c_KsepQl_curve As New TInterpolation             ' кривая коэффициента сепарации общего от дебита
' Private c_KsepNatQl_curve As New TInterpolation          ' кривая коэффициента сепарации натурального  от дебита
' Private c_KsepGasSepQl_curve As New TInterpolation       ' кривая коэффициента сепарации газосепаратора от дебита
' Private c_PdischargeSelfFlowQl_curve As New TInterpolation
' Private c_PdischargeFromTopQl_curve As New TInterpolation
' Private c_PintakeFromTopQl_curve As New TInterpolation
' Private c_QmixQl_curve As New TInterpolation             ' кривая зависимости дебита смеси через насос от дебита на поверхности
' Private p_PScalculated As Boolean ' флаг показывает что все данные в системе соответствуют друг другу
' Public Event ReportProgress(msg As String)
' Public Event ReportDebug(msg As String)
'
'  ' блок оценки качества данных
' 'Private p_LogMsg As New CLogger                ' логгер
'
'
'  ' конструктор класса
'  ' вызывается при создании класса - гарантирует что все объекты будут созданы
' Private Sub Class_Initialize()
'    p_PScalculated = False
'
'
'    ' создадим объекты скважин чтобы они были готовы
'    Set p_fluid = New CPVT
'    Set p_well = New CWellESP
'
'    Set fluid = p_fluid
'    p_Error_msg = ""
'
' End Sub
'
'' Public Property get' LogMsg() As CLogger
''    'Set' LogMsg = p_LogMsg
'' End Property
''
'' Public Property 'Set' LogMsg(val As CLogger)
'' ' распространяем систему логирования на все вложенные объекты
''    Set p_LogMsg = val
''    Set fluid.LogMsg = val
''    Set Reservoir.LogMsg = val
''    Set ESPdesign.LogMsg = val
''    Set well.LogMsg = val
''
''    ' все вспомогательные скважины получаются из основной клонированием - поэтому не надо их в явном виде подключать
''
''
'' End Property
'
' Public Property get Qldesign_m3day() As Double
'    Qldesign_m3day = p_Qldesign_m3day
' End Property
' Public Property get fluid() As CPVT
'    Set fluid = p_fluid
' End Property
'
' Public Property Set fluid(val As CPVT)
'    Set p_fluid = val
'    Set p_well.fluid = val
'    Set ESPdesign.fluid = val
'    Set Reservoir.fluid = val
' End Property
'
' Public Property get Reservoir() As CReservoirVogel
'   Set Reservoir = P_Reservoir
' End Property
'
' Public Property get ESPdesignHead() As Double
'   ESPdesignHead = p_ESPdesignHead_m
' End Property
'
' Public Property get ESPdesignRate() As Double
'   ESPdesignRate = p_ESPdesignRate_m3day
' End Property
'
' Public Property get PScalculated() As Double
'    PScalculated = p_PScalculated
' End Property
'
' Public Property get well() As CWellESP
'    Set well = p_well
' End Property
'
' Public Property Set well(val As CWellESP)
'    Set p_well = val
' End Property
'
' Public Property Let qliq_sm3day(val As Double)
'    fluid.qliq_sm3day = val
' End Property
'
' Public Property get qliq_sm3day() As Double
'    qliq_sm3day = fluid.qliq_sm3day
' End Property
'
'' Public Property Let pwf_atma(val As Double)
''    p_PwfSol_atma = val
''    p_well.pwf_atma = val
'' End Property
'
' Public Property get pwf_atma() As Double
'    pwf_atma = p_PwfSol_atma
' End Property
'
'Private Sub p_well_ReportProgress(msg As String)
'     RaiseEvent ReportProgress(msg)
'End Sub
'
'Private Sub WellAnalyse_ReportProgress(msg As String)
'     RaiseEvent ReportProgress(msg)
'End Sub
'
'Private Sub WellAnalyseTopDown_ReportProgress(msg As String)
'     RaiseEvent ReportProgress(msg)
'End Sub
'
'Private Sub WellDesign_ReportProgress(msg As String)
'     RaiseEvent ReportProgress(msg)
'End Sub
'
'Private Sub WellSelfFlow_ReportProgress(msg As String)
'     RaiseEvent ReportProgress(msg)
'End Sub
'
'Public Sub RegCurve(name As String)
'    Dim crv As New TInterpolation
'    Set curve(name) = crv
'End Sub
'
'Public Property get curve(Key As String) As TInterpolation
'On Error Resume Next
'    Dim exists As Boolean
'    exists = Not IsEmpty(c_Curves.item(Key))
'    If exists Then
'       Set curve = c_Curves.item(Key)
'    Else
'       Set curve = New TInterpolation
'       c_Curves.Add curve, Key
'    End If
'End Property
'
'Public Property Set curve(Key As String, valNew As TInterpolation)
' On Error Resume Next
'    Dim exists As Boolean
'    exists = Not IsEmpty(c_Curves.item(Key))
'    If exists Then
'       c_Curves(Key) = valNew
'    Else
'       c_Curves.Add valNew, Key
'    End If
'End Property
'
'
' Public Function calc_pi_testPoint(ByVal qliq_m3day As Double, ByVal fw_perc As Double, ByVal rp_m3m3 As Double, _
'                                Optional Pint_atma As Double = -1, Optional ByVal Tintake_C As Double = -1, Optional ByVal tbh_C As Double = -1, _
'                                Optional Hd_m As Double = -1, Optional Pan_atma As Double = -1, _
'                                Optional plin_atma As Double = -1, Optional pwf_atma As Double = -1)
'' @brief Расчет продуктивности скважины по данным нормальной работы скважины
'' @param qliq_m3day - Дебит жидкости
'' @param fw_perc - Обводненность
'' @param rp_m3m3 - Газовый фактор
'' Optional
'' @param Pint_atma - Давление на приеме
'' @param Tintake_C - Температура на приеме
'' @param tbh_C - Температура на забое
'' @param Hd_m - Динамический уровень
'' @param Pan_atma - затрубное давление
'' @param plin_atma - Линейное давление
'
'  '  1. Начало расчета. Анализируем входные данные, записываем их в свойства класса
'
'  RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_Qtest: Определяем продуктивность скважины. Q = " & qliq_m3day)
'
'  p_well.qliq_sm3day = qliq_m3day
'  p_well.fw_perc = fw_perc
'  p_well.rp_m3m3 = rp_m3m3
'  If pwf_atma <= 0 Then
'        ' 2. Расчет забойного давления
'        If (Pint_atma >= 0 And Tintake_C >= 0) Then
'          ' 2.1 Если задано давление на приеме насоса Pin то оно используется для расчета забойного давления скважины
'          p_PwfSol_atma = p_well.calc_pwf_Pintake_atma(Pint_atma)
'
'          RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_Qtest: Нашли забойное по давлению на приеме. Pint_atma =" & Pint_atma & " pwf = " & p_PwfSol_atma)
'
'        ElseIf (Hd_m >= 0 And Pan_atma >= 0 And tbh_C >= 0) Then
'          ' 2.2 Если давление на приеме не задано или равно нулю, но заданы динамический уровень Hdyn и затрубное давление Pcas - то они используются для расчета забойного давления
'          p_PwfSol_atma = p_well.calc_pwf_PanHd_atma(Pan_atma, Hd_m, tbh_C).p_atma
'
'          RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_Qtest: Нашли забойное по динамическому уровню. Hd_m =" & Hd_m & " pwf = " & p_PwfSol_atma)
'
'        ElseIf (plin_atma >= 0 And tbh_C >= 0) Then
'          ' 2.3 Если задано только линейное давление - то оно используется для расчета забойного давления
'          p_PwfSol_atma = p_well.calc_pwf_plin_atma(plin_atma, tbh_C)
'
'          RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_Qtest: Нашли забойное по линейному давлению. plin_atma =" & plin_atma & " pwf = " & p_PwfSol_atma)
'
'        Else
'          ' exception
'        End If
'  Else
'        p_PwfSol_atma = pwf_atma
'
'        RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_Qtest: Забойное давление задано. pwf = " & p_PwfSol_atma)
'
'  End If
'  ' 3. PI=PI(Qliq,pwf) по найденным значениям забойного давления и дебита ищется коэффициент продуктивности скважины
'
'
'  p_PISol_m3dayatm = P_Reservoir.calc_pi_sm3dayatm(qliq_m3day, p_PwfSol_atma)
'  calc_pi_testPoint = p_PISol_m3dayatm
'
'  RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_Qtest: Определили продуктивность p_PISol_m3dayatm = " & p_PISol_m3dayatm)
'
' End Function
'
'
'
' Public Sub calc_Solution_pi(ByVal Pline_atma As Double, ByVal tbh_C As Double, Optional calcFast As Boolean = False)
' ' расчет решения при известной продуктивности скважины
'  Dim numsol As Integer
'  Dim qs
'  On Error GoTo err1:
'   RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_pi: Запуск поиска решения задачи узлового анализа pi " & Format(P_Reservoir.pi_sm3dayatm, "##0.00"))
'
'   ' 1. Начало расчета. Анализируем входные данные, записываем их в свойства класса
'  '''' p_well.Pline_atma = Pline_atma
'
'   ' 2. Рассчитываем кривую оттока для скважины
'   ' 2.1 Пределы расчета кривой оттока от 0 м3/сут до максимально дебита скважины Qmax
'   Set c_IPR_curve = P_Reservoir.Build_IPRcurve()
'   RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_pi: Построили индикаторную кривую ")
'
'   ' 3. Рассчитываем кривую притока для пласта
'   Set c_VLP_curve = p_well.Build_VLPcurve(Pline_atma, tbh_C, P_Reservoir.calc_qliq_sm3day(0))
'
'   ' 4. Находим решение задачи узлового анализа
'   ' 4.1 для нахождения решения строим системную кривую - вычитая из индикаторной кривой кривую оттока
'   Set c_PS_curve = SubtractCurve(c_VLP_curve, c_IPR_curve)
'
'   ' 4.2 по системной кривой находим пересечение ее с нулем
'   numsol = c_PS_curve.FindSolutions(0)
'   Dim i As Integer
'
'   If numsol = 0 Then Debug.Assert False
'
'        For i = 0 To numsol - 1
'            qliq_sm3day = c_PS_curve.SolutionPointX(i + 1)
'          ''''  pwf_atma = P_Reservoir.calc_pwf_atma(qliq_sm3day)
'        Next i
'
'   RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_pi: Решение построение. Кол-во решений = " & numsol & " pwf = " & Format(p_PwfSol_atma, "##0.00"))
'   Exit Sub
'err1:
'
'   RaiseEvent ReportProgress("CProdSystem_old.calc_Solution_pi: Решение не найдено")
'   Err.Raise kErrNodalCalc, Err.Source, "CProdSystem_old.calc_Solution_pi: Ошибка при расчете решения узлового анализа " & Err.Description
'
' End Sub
'
' Public Sub calc_Nodal_pi(ByVal plin_atma As Double)
' ' поиск решения задачи узлового анализа по заданной продуктивности скважины
' '
' Dim errMsg As String
' On Error GoTo err1:
'    Dim numPoints As Integer
'    Call BuildNodalWHCurve_pi(plin_atma)         'после построения кривой можно найти параметры
'    numPoints = curve("c_PlinQl_curve").FindSolutions(plin_atma)
'    If numPoints >= 1 Then
'        qliq_sm3day = curve("c_PlinQl_curve").FindMaxOneSolution(plin_atma)
'     ''''   pwf_atma = Reservoir.calc_pwf_atma(qliq_sm3day)
'    Else
'        qliq_sm3day = 0
'     ''''   pwf_atma = Reservoir.calc_pwf_atma(qliq_sm3day)
'    End If
'
'    Exit Sub
'err1:
'    errMsg = "CProdSystem_old.calc_Nodal_pi: Ошибка при расчете решения узлового анализа " & sDELIM & Err.Description
'
'    RaiseEvent ReportProgress("CProdSystem_old.calc_Nodal_pi: Решение не найдено:" & errMsg)
''    Err.Raise Err.Number, Err.Source, Err.Description
'    Err.Raise kErrNodalCalc, Err.Source, errMsg
' End Sub
'
'
' Public Sub calc_ESPdesign(ByVal pbuf_atma As Double, ByVal PwfTarg_atma As Double, ByVal tbh_C As Double, _
'                            Optional calcFast As Boolean = False)
'
' ' расчет дизайна оборудования для скважины
'
'    Dim i As Integer
'    Dim MinPwf As Double, MaxPwf As Double
'    Dim Q As Double, pwf As Double
'    Dim minQ As Double, maxQ As Double, maxQres As Double    ' вспомогательные переменные для построения системных графиков
'    Dim stepQ As Double, stepQ2 As Double
'    Dim numPoints As Integer    ' количество точек для построения графика
'    Dim WellAnalyseESPdP As Double
'    Dim WellAnalyseESPdP_old As Double
'
'
'    RaiseEvent ReportProgress("CProdSystem_old: Запуск процедуры дизайна оборудования для скважины")
'
'    Call ClearCurves
'
'    ' для построения графиков подготовим данные необходимые и для дизайна тоже
'    Call ESPdesign.loadESPdesign
'    ESPdesign.StageNum = 100
'    Set WellDesign = p_well.Clone()
'    Set WellDesign.ESP = ESPdesign
'    WellDesign.clearChoke  ' отключим штуцер пока чтобы не мешал при дизайне
'
'    Set WellSelfFlow = p_well.Clone()   ' клонируем еще одну скважину чтобы построить кривую VLP без учета насоса
'    Set WellSelfFlow.ESP = Nothing
'    WellSelfFlow.clearChoke    ' отключим штуцер пока чтобы не мешал для расчета фонтана
'
'    numPoints = 20
'    MinPwf = 10 ' well.PLine_atma
'    MaxPwf = P_Reservoir.Pres_atma * 0.99  ' для максимальной границы расчета берем 0.99 от пластового чтобы не натыкаться на нулевой дебит
'    minQ = P_Reservoir.calc_qliq_sm3day(MaxPwf)  ' начнем строить графики с минимального дебита
'    maxQres = P_Reservoir.calc_qliq_sm3day(MinPwf)
'    maxQ = maxQres * 1.2   ' строить будем немного дальше конца пласта (некоторые графики)
'    stepQ = (maxQ - minQ) / numPoints
'    stepQ2 = stepQ
'    Q = minQ - stepQ
'
'    RaiseEvent ReportProgress("CProdSystem_old: Подготовка системного анализа завершена, созданы клоны для сравнения дизайна, фонтана и анализа")
'    RaiseEvent ReportProgress("CProdSystem_old: Старт системного анализа. Всего точек = " & numPoints)
'
'    WellAnalyseESPdP_old = 100
'    i = 0
'If Not calcFast Then
'    Do
'        i = i + 1
'        Q = Q + stepQ
'setQ:
'        RaiseEvent ReportProgress("итерация " & i & "  Q =" & Format(Q, "##0.0") & "   шаг по Q =" & Format(stepQ, "##0.00"))
'        pwf = P_Reservoir.calc_pwf_atma(Q)
'
'        WellSelfFlow.qliq_sm3day = Q
'        WellDesign.qliq_sm3day = Q
'
'        Call WellSelfFlow.calc_pwf_plin_atma(pbuf_atma, tbh_C)   ' тут надо бы разобраться с линейным и буферным давлением
'
'        If Q < maxQres Then
'
'          ''''  Call WellDesign.calc_well(pbuf_atma, pbuf_atma, pwf, tbh_C)
'            p_ESPdesignHead_m = 100 * (1 - WellDesign.ESP.cfHead_fr)
'            ' набор кривых полученных при расчете дизайна установки под скважину
'            c_HeadRequiredQl_curve.AddPoint Q, p_ESPdesignHead_m                   ' напор необходимый для данной скважины для данного дебита
'            p_ESPdesignRate_m3day = WellDesign.ESP.QmixPumpIntake_m3day
'            c_PdischargeDesignQl_curve.AddPoint Q, WellDesign.Pdis_atma       ' давление на выкиде расчетное по дизайну для установки
'            c_PS_curve.AddPoint Q, WellDesign.Pdis_atma - WellDesign.Pint_atma
'            'набор кривых полученных при расчете анализа установки - расчете снизу вверх по заданному забойному давлению
'            c_GasFarctionQl_curve.AddPoint Q, WellDesign.ESP.GasFraction_PumpIntake_d ' доля газа при заданном забойном
'            c_PintakeQl_curve.AddPoint Q, WellDesign.Pint_atma                  ' давление на приеме
'         '   c_PdischargeESPQl_curve.AddPoint Q, WellAnalyse.Pdis_atma         ' давление на выкиде которое сможет развить текушая установка
'            c_HdynQl_curve.AddPoint Q, WellDesign.Hdyn_m                          ' динамический уровень
'            c_PanQl_curve.AddPoint Q, WellDesign.Pan_atma                          ' затрубное давление
'            c_PwhQl_curve.AddPoint Q, WellDesign.pbuf_atma                         ' буферное давление
'            c_PlinQl_curve.AddPoint Q, WellDesign.Pline_atma                       ' линейное давление
'
'            c_KsepQl_curve.AddPoint Q, WellDesign.Kseptotal_d                          '
'           ' c_KsepNatQl_curve.AddPoint Q, WellDesign.KsepNat_d
'           ' c_KsepGasSepQl_curve.AddPoint Q, WellDesign.KsepGasSep_d
'            ' дополнительные "странные" графики
'            c_QmixQl_curve.AddPoint Q, WellDesign.ESP.QmixPumpIntake_m3day
'        End If
'        c_IPR_curve.AddPoint Q, pwf
'
'        ' начинаем строит кривые для отчета
'        ' набор кривых для фонтанирующей скважины
'        c_VLPselfFlowing_curve.AddPoint Q, WellSelfFlow.pwf_atma
'        c_PdischargeSelfFlowQl_curve.AddPoint Q, WellSelfFlow.Pdis_atma
'
'        ' набор кривых для скважины с граничным условием на поверхности
'       ' c_VLP_curve.AddPoint Q, WellAnalyseTopDown.pwf_atma
''        c_VLP_ESP_curve.AddPoint Q, WellAnalyseTopDown.Pdis_atma
'       ' c_PdischargeFromTopQl_curve.AddPoint Q, WellAnalyseTopDown.Pdis_atma
'
'    Loop Until Q >= maxQ
'
'    RaiseEvent ReportProgress("системный анализ завершен, графики построены!!! ")
'End If
'
'    RaiseEvent ReportProgress("начинаем расчет параметров дизайна на текущее давление")
'
'    p_Pwfdesign_atma = PwfTarg_atma
'
'    pwf = p_Pwfdesign_atma
'
'    Q = P_Reservoir.calc_qliq_sm3day(pwf)
'    WellDesign.qliq_sm3day = Q
'    p_Qldesign_m3day = Q
'
'  ''''  Call WellDesign.calc_well(pbuf_atma, pbuf_atma, pwf, tbh_C)
'
'    p_ESPdesigndP_atma = WellDesign.Pdis_atma - WellDesign.Pint_atma
'    p_ESPdesignHead_m = 100 * (1 - WellDesign.ESP.cfHead_fr)
'    p_ESPdesignRate_m3day = WellDesign.ESP.QmixPumpIntake_m3day     ' надо будет поправить чтобы тут использовался средний дебит а не максимальный
'  '  p_ESPdesignPower_W = WellDesign.ESP.PowerMotor_Wt
'    ' теперь тут надо вытащить забойное давление - определить продуктивность и построить кривые VLP и IPR
'    RaiseEvent ReportProgress("расчет параметров дизайна завершен")
'
'If Not calcFast Then
'    Set p_well.ESP = WellDesign.ESP
'        ' построим кривые для скважины
'    With p_well
'        Call .Build_HdPwfcurve(p_well.Pan_atma, tbh_C, p_Pwfdesign_atma)
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Зависимость динамического уровня от забойного давления построена")
'
'        Call .Build_PwhPwfcurve(tbh_C)
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Зависимость устьевого давления от забойного давления построена")
'
'     '   Call .Build_SeparCurve
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Зависимость сепарации от дебита построена")
'
'     '   Call .ESP.BuildCurves
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Кривые по работе УЭЦН построены")
'
'        Call .choke.BuildCurves
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Кривые по характеристике штуцера построены")
'
'        Call .fluid.BuildCurves(p_twh_C)
'
'        Call .fluidTub.BuildCurves(p_twh_C)
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Кривые PVT построены")
'    End With
'End If
'
'
' End Sub
'
' Public Sub calc_Forecast(ByVal plin_atma As Double, Optional ByVal tbh_C As Double = -1, Optional calcFast As Boolean = False)
'
'    Call calc_Analysis(0, 0, plin_atma, 0, tbh_C:=Tbh_C, CalcForecast:=True, calcFast:=calcFast)
'
' End Sub
'
' Public Sub calc_Analysis(ByVal QliQtest_sm3day As Double, ByVal fw_perc As Double, ByVal plin_atma As Double, ByVal pbuf_atma As Double, _
'                         Optional ByVal pwf_atma As Double = -1, Optional ByVal tbh_C As Double = -1, _
'                         Optional Pint_atma As Double = -1, Optional Tintake_C As Double = -1, Optional Hdyn_m As Double = -1, Optional Pan_atma As Double = -1, _
'                         Optional CalcForecast As Boolean = False, Optional calcFast As Boolean = False)
'
' ' расчет анализ скважины
' ' берет исходные данные по тесту скважины - дебит и замеры давлений
' ' считает продуктивность и все параметры работы скважины
' ' CalcForecast - флаг расчета прогноза по скважине, решение задачи узлового анализа
'
'    ' расчет параметров для дизайна УЭЦН
' ' тут надо устроить цикл по всем дебитам по индикаторной диаграмме  и для каждого дебита определить характеристики дизайна установки
'
'    Dim Q As Double, pwf As Double
'    Dim degr_good As Boolean
'
'    p_tbh_C = tbh_C
'
'    RaiseEvent ReportProgress("CProdSystem_old: Запуск процедуры анализа скважины")
'
'    Call ClearCurves
'
'    If Not CalcForecast Then
'
'        Q = QliQtest_sm3day
'
'        Call calc_pi_testPoint(QliQtest_sm3day, fw_perc, fluid.rp_m3m3, Pint_atma, Tintake_C, tbh_C, Hdyn_m, Pan_atma, plin_atma, pwf_atma)
'        pwf_atma = p_PwfSol_atma   ' если при поиске продуктивности пришлось вычислить забойное - то далее учитываем найденное решение
'
'        RaiseEvent ReportProgress("CProdSystem_old: Запуск расчета скважины с заданными параметрами | plin_atma = " & Format(plin_atma, "#0.0") _
'                                                                                           & "| pbuf_atma  = " & Format(pbuf_atma, "#0.0") _
'                                                                                           & "| pwf_atma  = " & Format(pwf_atma, "#0.0") _
'                                                                                           & "| tbh_C  = " & Format(tbh_C, "#0.0") _
'                                                                                           & "| Pint_atma  = " & Format(Pint_atma, "#0.0") _
'                                                                                           & "| Hdyn_m  = " & Format(Hdyn_m, "#0.0") _
'                                                                                           & "| Pan_atma  = " & Format(Pan_atma, "#0.0") & ".")
'
'        ' проведем расчет скважины для заданных параметров
'        ' для скважины должен быть задан дебит, конструкция и прочие параметры
'      '  degr_good = p_well.calc_well(plin_atma, pbuf_atma, pwf_atma, tbh_C, Pint_atma, Hdyn_m, Pan_atma)
'        If Not degr_good Then
'             p_Error_msg = "Деградацию УЭЦН определить не удалось"
'             RaiseEvent ReportProgress("CProdSystem_old: Деградацию УЭЦН определить не удалось ")
'             addLogMsg "Ошибка при анализе скважины"
'             Exit Sub
'        End If
'        ' по результатам расчета будут определены подстроечные параметры для штуцера и насоса
'    Else
'        Call calc_Solution_pi(plin_atma, tbh_C)
'        ' должны отсюда получить забойное давление - решение
'        pwf_atma = p_PwfSol_atma   ' если при поиске продуктивности пришлось вычислить забойное - то далее учитываем найденное решение
'
'    End If
'
'
'    p_twh_C = p_well.twh_C
'
'    RaiseEvent ReportProgress("CProdSystem_old: Расчет скважины завершен.   | cfHead_fr = " & Format(p_well.ESP.cfHead_fr, "#0.00") _
'                                                                                       & "| well.choke.KCalibr  = " & Format(p_well.choke.KCalibr, "#0.00") & ".")
''    Call BuildCurves(Pan_atma, tbh_C, pwf_atma)
''
''
''
''    Call BuildSysCurves(plin_atma, tbh_C, calcFast, CalcForecast)
'
'
'    RaiseEvent ReportProgress("Расчет анализ скважины завершен")
' End Sub
'
'
'
'' Public Function SaveState()
'' ' сохраняет состояние объекта в двухмерный массив для обеспечения вывода (для отладки)
''
''    RaiseEvent ReportProgress("Готовимся сохранять результаты")
''
''    Dim stor()
''    Dim i As Integer
''    i = 0
''
''    ReDim stor(const_OutputCurveNumPoints, STOR_SIZE)
''    stor(0, 0) = "ProdSystem SaveState"   ' тут будет общея строка с датой сохранения дампа
''
''    AddS stor, 1, 0, "construction    "
''    AddS stor, 2, 0, "pwf atma               ", Me.well.pwf_atma
''    AddS stor, 3, 0, "Qliq                  ", well.qliq_sm3day
''    AddS stor, 4, 0, "Pres                  ", Reservoir.Pres_atma
''    AddS stor, 5, 0, "pi                    ", Reservoir.pi_sm3dayatm
''    AddS stor, 6, 0, "--                    ", ""
''    AddS stor, 7, 0, "p_Pwfdesign_atma       ", p_Pwfdesign_atma
''    AddS stor, 8, 0, "p_Qldesign_m3day      ", p_Qldesign_m3day
''    AddS stor, 9, 0, "p_ESPdesigndP_atma     ", p_ESPdesigndP_atma
''    AddS stor, 10, 0, "p_ESPdesignHead_m     ", p_ESPdesignHead_m
''    AddS stor, 11, 0, "p_ESPdesignRate_m3day ", p_ESPdesignRate_m3day
''    AddS stor, 12, 0, "p_ESPdesignPower_W    ", p_ESPdesignPower_W
''
''    AddS stor, 13, 0, "p_Error_msg  ", p_Error_msg
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "IPR pwf atma"
''    AddSCurve stor, 1, 2, c_IPR_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "VLP pwf atma"
''    AddSCurve stor, 1, i, c_VLP_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "PS pwf atma"
''    AddSCurve stor, 1, i, c_PS_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "VLPsf pwf atma"
''    AddSCurve stor, 1, i, c_VLPselfFlowing_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Pintake atma"
''    AddSCurve stor, 1, i, c_PintakeQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Pdis design atma"
''    AddSCurve stor, 1, i, c_PdischargeDesignQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Pwh atma"
''    AddSCurve stor, 1, i, c_PwhQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "head m"
''    AddSCurve stor, 1, i, c_HeadRequiredQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Gas frac"
''    AddSCurve stor, 1, i, c_GasFarctionQl_curve
''
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Ksep total"
''    AddSCurve stor, 1, i, c_KsepQl_curve
''
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Ksep nat"
''    AddSCurve stor, 1, i, c_KsepNatQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Ksep Gas Sep"
''    AddSCurve stor, 1, i, c_KsepGasSepQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Q mix"
''    AddSCurve stor, 1, i, c_QmixQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "PdisESP mix"
''    AddSCurve stor, 1, i, c_PdischargeESPQl_curve
''
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Pdis from top atma"
''    AddSCurve stor, 1, i, c_PdischargeFromTopQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "Pdis self flow atma"
''    AddSCurve stor, 1, i, c_PdischargeSelfFlowQl_curve
''
''    i = i + 2
''    AddS stor, 0, i, "Qliq m3/day", "PintakeFromTopQl atma"
''    AddSCurve stor, 1, i, c_PintakeFromTopQl_curve
''
''    SaveState = stor
''
''   ' If p_well.calculated Then
''    SaveState = CombineS(stor, p_well.SaveState)
''
''  '  End If
''
'''     Private c_PS_curve As New TInterpolation           ' системная кривая - разность кривой оттока и кривой притока
'''
''' Private c_VLP_curve As New TInterpolation          ' кривая оттока для скважины - зависимость забойного давления от дебита (с учетом работы оборудования)
''' Private c_VLPselfFlowing_curve As TInterpolation   ' кривая оттока для фонтанирующей скважины (при отсутствии сепарации)
''' Private c_IPR_curve As New TInterpolation          ' кривая притока к скважине - зависимость забойного давления от дебита со стороны пласта
'''
''' Private c_PintakeQl_curve As New TInterpolation    ' кривая зависимости давления на приеме от дебита, учет пласта и участка трубы ниже насоса
''' Private c_PdischargeQl_curve As New TInterpolation ' кривая зависимости давления на выкиде насоса от дебита, учет потока по НКТ выше насоса с учетом Ксепарации(давления на приеме)
''' Private c_PwhQl_curve As New TInterpolation        ' кривая зависимости давления на устье (буфере) от забойного давления (дебита), учет пласта и скважины и скважинного оборудования
'''
'''
''' Private c_HeadRequiredQl_curve As New TInterpolation     ' кривая необходимого напора для скважины - дизайн УЭЦН, зависит от требуемого перепада давления
''' Private c_GasFarctionQl_curve As New TInterpolation      ' кривая доли газа для дизайна
''' Private c_KsepQl_curve As New TInterpolation             ' кривая коэффициента сепарации общего от дебита
''' Private c_KsepNatQl_curve As New TInterpolation          ' кривая коэффициента сепарации натурального  от дебита
''' Private c_KsepGasSepQl_curve As New TInterpolation       ' кривая коэффициента сепарации газосепаратора от дебита
'''
''' Private c_QmixQl_curve As New TInterpolation             ' кривая зависимости дебита смеси через насос от дебита на поверхности
''
''
''
''    RaiseEvent ReportProgress("Все результаты сохранены")
''
'' End Function
''
''
' Private Sub BuildCurves(ByVal Pan_atma As Double, ByVal tbh_C As Double, ByVal pwf_atma As Double)
'    RaiseEvent ReportProgress("CProdSystem_old: Строим кривые для расчета скважины (Q = const), сепарацииб УЭЦН и штуцера")
'
'    ' построим кривые для скважины
'    With p_well
'        Call .Build_HdPwfcurve(Pan_atma, tbh_C, pwf_atma)
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Зависимость динамического уровня от забойного давления построена")
'
'        Call .Build_PwhPwfcurve(, pwf_atma)
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Зависимость устьевого давления от забойного давления построена")
'
'    '    Call .Build_SeparCurve
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Зависимость сепарации от дебита построена")
'
''        Call .ESP.BuildCurves
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Кривые по работе УЭЦН построены")
'
'        Call .choke.BuildCurves
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Кривые по характеристике штуцера построены")
'
'        Call .fluid.BuildCurves(p_twh_C)
'
'        Call .fluidTub.BuildCurves(p_twh_C)
'        RaiseEvent ReportProgress("CProdSystem_old: -------- Кривые PVT построены")
'    End With
'
'
' End Sub
'
' Public Sub BuildNodalWHCurve_pi(Optional Pwh_targ_atma As Double = 1)
''  метод для расчета кривой узлового анализа системы добычи на поверхности для заданной продуктивности
'' Pwh_targ_atma целевое значение устьевого давления, которое надо точнее найти
''
'' цель построения кривой - иметь возможность по ней восстановить пересечение с заданным значением устьевого давления
'' поэтому, чтобы избежать числовой ошибки надо точнее нарисовать кривую около этих точек.
'    Dim i As Integer, j As Integer
'    Dim MinPwf As Double, MaxPwf As Double
'    Dim pwf_0 As Double, Pwh_0 As Double
'    Dim pwf_1 As Double, Pwh_1 As Double
'    Dim Pwh_atma As Double
'    Dim Q As Double, pwf As Double, Pwfstep As Double, Pintake As Double
'    Dim NumIntervals As Integer
'    Dim Done As Boolean
'    Dim PointDone As Boolean
'    Dim FirstPointDone As Boolean
'    Dim errMsg As String
' On Error GoTo err1:
'    PointDone = False
'    Done = False
'    FirstPointDone = False
'    NumIntervals = 10
'    MinPwf = 1
'    MaxPwf = P_Reservoir.Pres_atma * 0.99  ' для максимальной границы расчета берем 0.99 от пластового чтобы не натыкаться на нулевой дебит
' ' первую точку все равно надо считать, сделаем это вне основного цикла
'    pwf = MaxPwf
'    curve("c_PlinQl_curve").ClearPoints
'    Pwfstep = (MaxPwf - MinPwf) / NumIntervals
'    Q = Reservoir.calc_qliq_sm3day(pwf)
'    Me.qliq_sm3day = Q
'    well.isCalcCasing = False
'    Pwh_atma = well.calc_plin_pwf_atma(pwf)
'    Pintake = well.Pint_atma          ' вытаскиваем значение из скважины
'    curve("c_PlinQl_curve").AddPoint Me.qliq_sm3day, Pwh_atma
'    pwf_0 = pwf
'    Pwh_0 = Pwh_atma
'    i = 0
'    RaiseEvent ReportProgress("BuildNodalWHCurve_pi: начало построения кривой узлового анализа на устье для Рлин = " & s(Pwh_targ_atma))
'    Do
'         If Pintake = 1 And i > 0 Then Exit Do
'         pwf = pwf - Pwfstep
'         If pwf < 1 Then pwf = 1
'         Q = Reservoir.calc_qliq_sm3day(pwf)                         ' нашли точку по индикаторной кривой
'         Me.qliq_sm3day = Q                                       ' установили дебит для расчета
'         well.isCalcCasing = False
'         Pwh_atma = well.calc_plin_pwf_atma(pwf)
'         If Pwh_atma > 1 Then FirstPointDone = True
'         If Pwh_atma > Pwh_targ_atma And pwf = 1 Then
'         ' значит даже при атмосферном давлении устьевое будет выше необходимого
'             curve("c_PlinQl_curve").AddPoint Me.qliq_sm3day - 0.0001, Pwh_atma
'             curve("c_PlinQl_curve").AddPoint Me.qliq_sm3day, Pwh_targ_atma
'             Exit Sub
'         End If
'         curve("c_PlinQl_curve").AddPoint Q, Pwh_atma
'
'         RaiseEvent ReportProgress("BuildNodalWHCurve_pi: Точка i = " & i & ":  pwf = " & s(pwf) & ":  Pwh_atma =" & s(Pwh_atma))
'
'         ' фиксируем вторую точку
'         pwf_1 = pwf
'         Pwh_1 = Pwh_atma
'         j = 0
'         If isBetween(Pwh_targ_atma, Pwh_0, Pwh_1) Then
'         ' здесь надо точнее найти точку пересения кривой, для этого используем метод дихотомии
'             Do
'                 j = j + 1
'                 pwf = (pwf_0 + pwf_1) / 2
'                 Me.qliq_sm3day = Reservoir.calc_qliq_sm3day(pwf)
'                 well.isCalcCasing = False
'                 Pwh_atma = well.calc_plin_pwf_atma(pwf)
'                 curve("c_PlinQl_curve").AddPoint Me.qliq_sm3day, Pwh_atma
'
'                 RaiseEvent ReportProgress("BuildNodalWHCurve_pi: Ищем пересечение. Точка i = " & i & " j = " & j & ":  pwf = " & s(pwf) & ":  Pwh_atma =" & s(Pwh_atma))
'
'                 If isBetween(Pwh_targ_atma, Pwh_0, Pwh_atma) Then
'                     pwf_1 = pwf
'                     Pwh_1 = Pwh_atma
'                 Else
'                     pwf_0 = pwf
'                     Pwh_0 = Pwh_atma
'                 End If
'             Loop Until j > 100 Or Abs(pwf_1 - pwf_0) < 0.1
'             If FirstPointDone And j < 100 Then Done = True    ' можно вместо  Pwh_atma поставить Pwh_1 и сократить 1 расчет
'        End If
'        pwf_0 = pwf_1
'        Pwh_0 = Pwh_1
'
'        i = i + 1
'    Loop Until i > 100 Or Done
'
'    RaiseEvent ReportProgress("BuildNodalWHCurve_pi: Готово для Рлин = " & s(Pwh_targ_atma))
'
''                Me.qliq_sm3day = curve("c_PlinQl_curve").FindMaxOneSolution(Pwh_targ_atma)
''                pwf = Reservoir.calc_pwf_atma(Me.qliq_sm3day)
''                Pwh_atma = well.calc_plin_pwf_atma(SetPT(pwf, well.tbh_C), CalcCasing:=False)
'
'    Exit Sub
'err1:
'    errMsg = "CProdSystem_old.BuildNodalWHCurve_pi: Ошибка при построении кривой узлового анализа на устье " & sDELIM & Err.Description
'    RaiseEvent ReportProgress("CProdSystem_old.BuildNodalWHCurve_pi: ошибка какая то: " & errMsg)
''    Err.Raise Err.Number, Err.Source, Err.Description
'    Err.Raise kErrBuildCurve, Err.Source, errMsg
'
' End Sub
'
' Public Sub BuildSysCurves(plin_atma As Double, tbh_C As Double, calcFast As Boolean, CalcForecast As Boolean)
' '
' ' построение набора системы графиков по системе добычи
' '
'
'    Dim i As Integer
'    Dim MinPwf As Double, MaxPwf As Double
'    Dim Q As Double, pwf As Double
'    Dim minQ As Double, maxQ As Double, maxQres As Double    ' вспомогательные переменные для построения системных графиков
'    Dim stepQ As Double, stepQ2 As Double
'    Dim numPoints As Integer    ' количество точек для построения графика
'    Dim WellAnalyseESPdP As Double
'    Dim WellAnalyseESPdP_old As Double
'
'
'    RaiseEvent ReportProgress("CProdSystem_old: Готовим данные для системного анализа скважины")
'
'    ' готовим объекты для построения графиков дизайна скважины
'    Call ESPdesign.loadESPdesign
'    ESPdesign.StageNum = 100
'    Set WellDesign = p_well.Clone()
'    Set WellDesign.ESP = ESPdesign
'    WellDesign.clearChoke ' отключим штуцер пока чтобы не мешал при дизайне
'
'    ' подготовим данные для анализа
'    Set WellAnalyse = p_well.Clone()    ' клонируем скважину, чтобы расчеты по анализу чувствительности не влияли на основную скважину
'    Set WellAnalyseTopDown = p_well.Clone() ' эта скважина нужна для расчет кривой лифта с учетом ЭЦН
'
'    WellAnalyseTopDown.ESP.cfHead_fr = p_well.ESP.cfHead_fr
'    WellAnalyse.ESP.cfHead_fr = p_well.ESP.cfHead_fr
'
'    Set WellSelfFlow = p_well.Clone()   ' клонируем еще одну скважину чтобы построить кривую VLP без учета насоса
'    Set WellSelfFlow.ESP = Nothing
'    WellSelfFlow.clearChoke  ' отключим штуцер пока чтобы не мешал для расчета фонтана
'
'
'    ' для построения графиков подготовим данные необходимые и для дизайна тоже
'    numPoints = 10
'    MinPwf = 1 ' well.PLine_atma
'    MaxPwf = P_Reservoir.Pres_atma * 0.99  ' для максимальной границы расчета берем 0.99 от пластового чтобы не натыкаться на нулевой дебит
'    minQ = P_Reservoir.calc_qliq_sm3day(MaxPwf)  ' начнем строить графики с минимального дебита
'    If minQ < 1 Then minQ = 1
'
'    maxQres = P_Reservoir.calc_qliq_sm3day(MinPwf)
'
'    maxQ = maxQres * 1.2   ' строить будем немного дальше конца пласта (некоторые графики)
'    If maxQ < 2 Then
'        addLogMsg "CProdSystem_old.BuildSysCurves: Не удается построить системные графики  - слишком низкая продуктивность = " & Format(Reservoir.pi_sm3dayatm)
'    End If
'
'    stepQ = (maxQ - minQ) / numPoints
'    stepQ2 = stepQ
'    Q = minQ - stepQ
'
'    RaiseEvent ReportProgress("CProdSystem_old: Подготовка системного анализа завершена, созданы клоны для сравнения дизайна, фонтана и анализа")
'    RaiseEvent ReportProgress("CProdSystem_old: Старт системного анализа. Всего точек = " & numPoints)
'
'    WellAnalyseESPdP_old = 100
'    i = 0
'    Do
'        i = i + 1
'        If Q < maxQres And Q + stepQ >= maxQres Then
'            Q = maxQres
'        Else
'            Q = Q + stepQ
'        End If
'setQ:
'        RaiseEvent ReportProgress("итерация " & i & "  Q =" & Format(Q, "##0.0") & "   шаг по Q =" & Format(stepQ, "##0.00"))
'        pwf = P_Reservoir.calc_pwf_atma(Q)
'
'        WellAnalyse.qliq_sm3day = Q
'        WellSelfFlow.qliq_sm3day = Q
'        WellDesign.qliq_sm3day = Q
'        WellAnalyseTopDown.qliq_sm3day = Q
'
'        'Debug.Assert i < 17
'        If Not calcFast Then
'            Call WellAnalyseTopDown.calc_pwf_plin_atma(plin_atma, tbh_C)
'            Call WellSelfFlow.calc_pwf_plin_atma(plin_atma, tbh_C)   ' тут надо бы разобраться с линейным и буферным давлением
'        End If
'
'        If Q < maxQres Then
'            well.isCalcCasing = False
'            Call WellAnalyse.calc_plin_pwf_atma(pwf)
'
'            WellAnalyseESPdP = WellAnalyse.Pdis_atma - WellAnalyse.Pint_atma  ' нашли перепад давления при текущем дебите и забойном по пласту
'            If (Abs(WellAnalyseESPdP) > 1) Then             ' здесь 1 это допустимая погрешность расчета
'                WellAnalyseESPdP_old = WellAnalyseESPdP
'            Else
'                If (Q < maxQres) Then
'                    If (Abs(WellAnalyseESPdP) > 0) Then
'                        WellAnalyseESPdP_old = WellAnalyseESPdP   ' финализируем процесс поиска тут
'                    ElseIf (Abs(WellAnalyseESPdP_old) > 1) And (stepQ > 0.5) Then   ' на предыдущем расчете перепад давления был, а теперь нет - надо найти точнее дебит при котором это произошло
'                        stepQ = stepQ / 2
'                        Q = Q - stepQ
'                        GoTo setQ:
'                    Else
'                        stepQ = stepQ2 / 2
'                        WellAnalyseESPdP_old = WellAnalyseESPdP
'                    End If
'                End If
'            End If
'         ''''   Call WellDesign.calc_well(plin_atma, 0, pwf, tbh_C, CalcChoke:=False)
'            p_ESPdesignHead_m = 100 * (1 - WellDesign.ESP.cfHead_fr)
'            ' набор кривых полученных при расчете дизайна установки под скважину
'            c_HeadRequiredQl_curve.AddPoint Q, p_ESPdesignHead_m                   ' напор необходимый для данной скважины для данного дебита
'            p_ESPdesignRate_m3day = WellDesign.ESP.QmixPumpIntake_m3day
'            c_PdischargeDesignQl_curve.AddPoint Q, WellDesign.Pdis_atma       ' давление на выкиде расчетное по дизайну для установки
'           If Not CalcForecast Then c_PS_curve.AddPoint Q, WellDesign.Pdis_atma - WellAnalyse.Pint_atma
'            'набор кривых полученных при расчете анализа установки - расчете снизу вверх по заданному забойному давлению
'          If Not calcFast Then
'
'            c_GasFarctionQl_curve.AddPoint Q, WellAnalyse.ESP.GasFraction_PumpIntake_d ' доля газа при заданном забойном
'            c_PintakeQl_curve.AddPoint Q, WellAnalyse.Pint_atma                  ' давление на приеме
'            c_PdischargeESPQl_curve.AddPoint Q, WellAnalyse.Pdis_atma         ' давление на выкиде которое сможет развить текушая установка
'            c_HdynQl_curve.AddPoint Q, WellAnalyse.Hdyn_m                          ' динамический уровень
'            c_PanQl_curve.AddPoint Q, WellAnalyse.Pan_atma                          ' затрубное давление
'            c_PwhQl_curve.AddPoint Q, WellAnalyse.pbuf_atma                         ' буферное давление
'            c_PlinQl_curve.AddPoint Q, WellAnalyse.Pline_atma                       ' линейное давление
'
'            c_KsepQl_curve.AddPoint Q, WellAnalyse.Kseptotal_d                          '
''            c_KsepNatQl_curve.AddPoint Q, WellAnalyse.KsepNat_d
''            c_KsepGasSepQl_curve.AddPoint Q, WellAnalyse.KsepGasSep_d
'            ' дополнительные "странные" графики
'            c_QmixQl_curve.AddPoint Q, WellAnalyse.ESP.QmixPumpIntake_m3day
'          End If
'        End If
'        c_IPR_curve.AddPoint Q, pwf
'If Not calcFast Then
'
'        ' начинаем строит кривые для отчета
'        ' набор кривых для фонтанирующей скважины
'        c_VLPselfFlowing_curve.AddPoint Q, WellSelfFlow.pwf_atma
'        c_PdischargeSelfFlowQl_curve.AddPoint Q, WellSelfFlow.Pdis_atma
'
'        ' набор кривых для скважины с граничным условием на поверхности
'        If Not CalcForecast Then c_VLP_curve.AddPoint Q, WellAnalyseTopDown.pwf_atma
''        c_VLP_ESP_curve.AddPoint Q, WellAnalyseTopDown.Pdis_atma
'        c_PdischargeFromTopQl_curve.AddPoint Q, WellAnalyseTopDown.Pdis_atma
'        c_PintakeFromTopQl_curve.AddPoint Q, WellAnalyseTopDown.Pint_atma
'End If
'Loop Until Q >= maxQ
'
'    RaiseEvent ReportProgress("системный анализ завершен, графики построены!!! ")
'
'
'     RaiseEvent ReportProgress("начинаем расчет параметров дизайна на текущее давление")
'
'    pwf = p_PwfSol_atma
'
'    Q = P_Reservoir.calc_qliq_sm3day(pwf)
'    WellDesign.qliq_sm3day = Q
'
'  ''''  Call WellDesign.calc_well(plin_atma, 0, pwf, tbh_C, CalcChoke:=False)
'
'    p_Pwfdesign_atma = pwf
'    p_Qldesign_m3day = Q
'    p_ESPdesigndP_atma = WellDesign.Pdis_atma - WellDesign.Pint_atma
'    p_ESPdesignHead_m = 100 * (1 - WellDesign.ESP.cfHead_fr)
'    p_ESPdesignRate_m3day = WellDesign.ESP.QmixPumpIntake_m3day     ' надо будет поправить чтобы тут использовался средний дебит а не максимальный
' '   p_ESPdesignPower_W = WellDesign.ESP.PowerMotor_Wt
'    ' теперь тут надо вытащить забойное давление - определить продуктивность и построить кривые VLP и IPR
'    RaiseEvent ReportProgress("расчет параметров дизайна завершен")
'
'
' End Sub
'
' Private Sub ClearCurves()
'
'    c_HeadRequiredQl_curve.ClearPoints
'    c_GasFarctionQl_curve.ClearPoints
'    c_KsepQl_curve.ClearPoints
'    c_KsepNatQl_curve.ClearPoints
'    c_KsepGasSepQl_curve.ClearPoints
'    c_PintakeQl_curve.ClearPoints
'    c_PdischargeDesignQl_curve.ClearPoints
'    c_PwhQl_curve.ClearPoints
'    c_IPR_curve.ClearPoints
'    c_PS_curve.ClearPoints
'    c_VLPselfFlowing_curve.ClearPoints
'    c_VLP_ESP_curve.ClearPoints
'    c_QmixQl_curve.ClearPoints
'    c_PdischargeSelfFlowQl_curve.ClearPoints
'    c_PdischargeFromTopQl_curve.ClearPoints
'
' End Sub
'
'
'' код, который возможно надо удалить
'
'
'' Public Sub InitQ(Optional arr_Hmes_m = 2000, Optional arr_Hvert_m = 2000, Optional arr_Dcas_m = 0.12, Optional arr_Dtub_m = 0.062, Optional Dchoke_m As Double = -1, _
''                 Optional ByVal qliq_m3day As Double, Optional ByVal Pres_atma As Double = 250, Optional ByVal fw_perc As Double = 0, _
''                 Optional ByVal tbh_C As Double = 90, Optional ByVal twh_C As Double = 20, _
''                 Optional ByVal gamma_o As Double = 0.86, Optional ByVal gamma_g As Double = 0.6, Optional ByVal gamma_w As Double = 1, _
''                 Optional ByVal rp_m3m3 As Double = 100, Optional ByVal rsb_m3m3 As Double = 100, Optional ByVal pb_atma As Double = 100, Optional ByVal Bo_m3m3 As Double = 1.2, _
''                 Optional ByVal Qgfree_scm3day As Double = 0, Optional arr_roughness_m = 0.0001, _
''                 Optional ByVal correlation As H_CORRELATION = Ansari, Optional ByVal Pvt_cor As PVT_CORRELATION = 0, Optional ByVal CalcCorrection As Double = 1, Optional AlongFlow As Integer = 0)
''
''    p_Reservoir.InitProp Pres_atma, pb_atma, fw_perc
''
''    p_well.InitWell arr_Hmes_m, arr_Hvert_m, arr_Dcas_m, arr_Dtub_m, arr_roughness_m, correlation, _
''                    Pvt_cor, CalcCorrection
''    p_well.Dchoke_m = Dchoke_m
''
''
'' End Sub
'
'
'
'
' ' ----- gamma_o ----------------------------------------------------------------------------------------
'' Public Property get gamma_o() As Double
''    gamma_o = fluid.gamma_o
'' End Property
''
'' Public Property Let gamma_o(val As Double)
''    If (val > const_gamma_oil_min) And (val < const_gamma_oil_max) Then
''        p_fluid.gamma_o = val
''        p_well.fluid.gamma_o = val
''        p_PScalculated = False
''    Else
''        addLogMsg "gamma_o: попытка некорректного ввода gamma_o = " & val
''        Err.Raise vbObjectError + 514, , "gamma_o: попытка некорректного ввода gamma_o = " & val
''    End If
'' End Property
'
''  ' ----- gamma_w ----------------------------------------------------------------------------------------
'' Public Property get gamma_w() As Double
''    gamma_w = fluid.gamma_w
'' End Property
'' Public Property Let gamma_w(val As Double)
''    If (val > const_gamma_water_min) And (val < const_gamma_water_max) Then
''        p_fluid.gamma_w = val
''        p_well.fluid.gamma_w = val
''        p_PScalculated = False
''    Else
''        addLogMsg "gamma_o: попытка некорректного ввода gamma_w = " & val
''        Err.Raise vbObjectError + 514, , "gamma_w: попытка некорректного ввода gamma_w = " & val
''    End If
'' End Property
'
'
''  ' ----- gamma_g ----------------------------------------------------------------------------------------
'' Public Property get gamma_g() As Double
''    gamma_g = fluid.gamma_g
'' End Property
'' Public Property Let gamma_g(val As Double)
''    If (val > const_gamma_gas_min) And (val < const_gamma_gas_max) Then
''         p_fluid.gamma_g = val
''         p_well.fluid.gamma_g = val
''         p_PScalculated = False
''    Else
''        addLogMsg "gamma_o: попытка некорректного ввода gamma_g = " & val
''        Err.Raise vbObjectError + 514, , "gamma_o: попытка некорректного ввода gamma_g = " & val
''    End If
'' End Property
'
