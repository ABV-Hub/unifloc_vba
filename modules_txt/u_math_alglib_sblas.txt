''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub SymmetricMatrixVectorMultiply(ByRef A() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Double, _
         ByVal Alpha As Double, _
         ByRef Y() As Double)
    Dim I As Long
    Dim BA1 As Long
    Dim BA2 As Long
    Dim BY1 As Long
    Dim BY2 As Long
    Dim BX1 As Long
    Dim BX2 As Long
    Dim N As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    N = I2 - I1 + 1#
    If N <= 0# Then
        Exit Sub
    End If
    
    '
    ' Let A = L + D + U, where
    '  L is strictly lower triangular (main diagonal is zero)
    '  D is diagonal
    '  U is strictly upper triangular (main diagonal is zero)
    '
    ' A*x = L*x + D*x + U*x
    '
    ' Calculate D*x first
    '
    For I = I1 To I2 Step 1
        Y(I - I1 + 1#) = A(I, I) * X(I - I1 + 1#)
    Next I
    
    '
    ' Add L*x + U*x
    '
    If IsUpper Then
        For I = I1 To I2 - 1# Step 1
            
            '
            ' Add L*x to the result
            '
            V = X(I - I1 + 1#)
            BY1 = I - I1 + 2#
            BY2 = N
            BA1 = I + 1#
            BA2 = I2
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                Y(i_) = Y(i_) + V * A(I, i_ + i1_)
            Next i_
            
            '
            ' Add U*x to the result
            '
            BX1 = I - I1 + 2#
            BX2 = N
            BA1 = I + 1#
            BA2 = I2
            i1_ = (BA1) - (BX1)
            V = 0#
            For i_ = BX1 To BX2 Step 1
                V = V + X(i_) * A(I, i_ + i1_)
            Next i_
            Y(I - I1 + 1#) = Y(I - I1 + 1#) + V
        Next I
    Else
        For I = I1 + 1# To I2 Step 1
            
            '
            ' Add L*x to the result
            '
            BX1 = 1#
            BX2 = I - I1
            BA1 = I1
            BA2 = I - 1#
            i1_ = (BA1) - (BX1)
            V = 0#
            For i_ = BX1 To BX2 Step 1
                V = V + X(i_) * A(I, i_ + i1_)
            Next i_
            Y(I - I1 + 1#) = Y(I - I1 + 1#) + V
            
            '
            ' Add U*x to the result
            '
            V = X(I - I1 + 1#)
            BY1 = 1#
            BY2 = I - I1
            BA1 = I1
            BA2 = I - 1#
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                Y(i_) = Y(i_) + V * A(I, i_ + i1_)
            Next i_
        Next I
    End If
    For i_ = 1# To N Step 1
        Y(i_) = Alpha * Y(i_)
    Next i_
End Sub
Public Sub SymmetricRank2Update(ByRef A() As Double, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Double, _
         ByRef Y() As Double, _
         ByRef T() As Double, _
         ByVal Alpha As Double)
    Dim I As Long
    Dim TP1 As Long
    Dim TP2 As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If IsUpper Then
        For I = I1 To I2 Step 1
            TP1 = I + 1# - I1
            TP2 = I2 - I1 + 1#
            V = X(I + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = V * Y(i_)
            Next i_
            V = Y(I + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = T(i_) + V * X(i_)
            Next i_
            For i_ = TP1 To TP2 Step 1
                T(i_) = Alpha * T(i_)
            Next i_
            i1_ = (TP1) - (I)
            For i_ = I To I2 Step 1
                A(I, i_) = A(I, i_) + T(i_ + i1_)
            Next i_
        Next I
    Else
        For I = I1 To I2 Step 1
            TP1 = 1#
            TP2 = I + 1# - I1
            V = X(I + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = V * Y(i_)
            Next i_
            V = Y(I + 1# - I1)
            For i_ = TP1 To TP2 Step 1
                T(i_) = T(i_) + V * X(i_)
            Next i_
            For i_ = TP1 To TP2 Step 1
                T(i_) = Alpha * T(i_)
            Next i_
            i1_ = (TP1) - (I1)
            For i_ = I1 To I Step 1
                A(I, i_) = A(I, i_) + T(i_ + i1_)
            Next i_
        Next I
    End If
End Sub
