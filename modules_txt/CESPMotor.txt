'=======================================================================================
'Unifloc 7.25  coronav                                          khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
'
'
' Класс для описания характеристик погружного двигателя (как ассинхронного, так и вентильного)
'
Option Explicit
' параметры асинхронного двигателя номинальные
' предполагается что ассинхронный двигатель соединен звездой
' надо будет сделать возможность задания треугольником и сделать вентильные привода
Private is_induction_ As Boolean   ' признак того что двигатель ассинхронный
Private is_star_ As Boolean        ' соединение звезда (альтернатива - треугольник если ассинхронный)
Private nom_data_ As MOTOR_DATA
Private data_ As MOTOR_DATA
Private m_Nm_ As Double           ' момент развиваемый при текущих параметрах
' параметры холостого хода
Private Ix_A_ As Double            ' ток холостого хода
Private cos_phix_d_ As Double       ' коэф мощности при холостом ходе
Private phix_d_ As Double          ' коэф мощности при холостом ходе
' параметры двигателя по схеме замещения
Private lambda_d_ As Double       ' отношение максимального момента к номинальному для АД
Private I_start_A_ As Double       ' пусковой ток для двигателя
Private R1_  As Double             ' активное сопротивление обмотки статора для схемы замещения
Private R2__ As Double             ' активное сопротивление обмотки ротока приведеное к обмотке статора
Private xk_  As Double             ' индуктивное сопротивление обмоток для режима короткого замыкания
Private xi_  As Double
Private C1    As Double             ' коээфициент приведения Т образной схемы к Г образной
' параметры из каталога, которые потенциально могут пригодится
Private d_cas_min_mm_ As Double      ' минимальный диаметр скважины, мм
Private v_liq_min_msec_ As Double    ' минимально допустимая скорость жидкости для охлаждения, м/с
'Private num_sections_ As Integer    ' количество секций
Private h_mes_top_ As Double                 ' глубина установки ЭЦН (по верхней части)
Private m_kg_  As Double           ' масса, кг
Private length_m_  As Double        ' установочная длина, м  вместе с гидрозащитой
Private diam_mm_ As Double         ' диаметр насоса - габарит
Private ID_ As Integer
Private motor_name_ As String
Private manufacturer_name_ As String
Public alpha0 As Double   '= 0.65  ' константа рекомендованная в методичке Гридина
'Public xi_ As Double '= 1.05
Private motor_source_ As Integer             ' источник данных по мотору.0 дефлтный, другой потом
Public dPower_protector_W As Double ' потребление мощности гидрозашитой
'публичное свойство для номинального момента двигателя
Public Property Get Mnom_Nm() As Double
    Mnom_Nm = nom_data_.Mshaft_Nm
End Property
' максимальный момент двигателя
Public Property Get Mmax_Nm() As Double
' рассчитывается из перегрузочной способности
    Mmax_Nm = Mnom_Nm * lambda_d_
End Property
' отношение максимального момента к номинальному
Public Property Get lambda_d() As Double
    lambda_d = lambda_d_
End Property
' номинальное фазное напряжение на двигателе
Public Property Get Unom_phase_V() As Double
    Unom_phase_V = nom_data_.U_phase_V
End Property
' номинальное линейное напряжение на двигателе
Public Property Get Unom_lin_V() As Double
    Unom_lin_V = nom_data_.U_lin_V
End Property
' фактическое фазное напряжение на двигателе
Public Property Get U_phase_V() As Double
    U_phase_V = data_.U_phase_V
End Property
' фактическое линейное напряжение на двигателе
Public Property Get U_lin_V() As Double
    U_lin_V = data_.U_lin_V
End Property
' номинальный ток (фазный)
Public Property Get Inom_phase_A() As Double
   Inom_phase_A = nom_data_.I_phase_A
End Property
' номинальный ток (линейный)
Public Property Get Inom_lin_A() As Double
   Inom_lin_A = nom_data_.I_lin_A
End Property
' номинальное скольжение на двигателе (при других номинальных параметрах)
Public Property Get Snom_d() As Double
    Snom_d = nom_data_.s_d
End Property
' номинальная мощность двигателя при номинальной частоте тока
Public Property Get Pnom_W() As Double
    Pnom_W = nom_data_.Pshaft_kW * 1000
End Property
Public Property Get Pnom_kW() As Double
    Pnom_kW = nom_data_.Pshaft_kW
End Property
' потребляемая мощность электрическая двигателем
Public Property Get Pel_kW() As Double
     Pel_kW = data_.Pelectr_kW
End Property
Public Property Get Pshaft_kW() As Double
     Pshaft_kW = data_.Pshaft_kW
End Property
' загрузка двигателя при текущих параметрах работы
Public Property Get load_d() As Double
' определяется как оношение текущей мощности к номинальной
    load_d = data_.load_d
End Property
' номинальный КПД двигателя
Public Property Get Effnom_d() As Double
    Effnom_d = nom_data_.eff_d
End Property
' номинальный коэффициент мощности двигателя
Public Property Get CosPhinom_d() As Double
    CosPhinom_d = nom_data_.cosphi
End Property
' номинальная скорость вращения поля статора
Public Property Get nnom_obmin() As Double
    nnom_obmin = Fnom_Hz * 60
End Property
' номинальная скорость вращения ротора с учетом проскальзования
Public Property Get nnoms_obmin() As Double
    nnoms_obmin = fnoms_Hz * 60 '* (1 - p_Snom_d)
End Property
Public Property Get Fnom_Hz() As Double
    Fnom_Hz = nom_data_.f_Hz
End Property
Public Property Get fnoms_Hz() As Double
    fnoms_Hz = nom_data_.f_Hz * (1 - nom_data_.s_d)
End Property
' фактическое проскальзование для текущего режима работы
Public Property Get s_d() As Double
    s_d = data_.s_d
End Property
' частота вращения поля статора для двигателя. Равна частоте тока питающего двигатель
Public Property Get f_Hz() As Double
    f_Hz = data_.f_Hz
End Property
Public Property Get n_obmin() As Double
    n_obmin = f_Hz * 60
End Property
' частота вращения ротора с учетом проскальзования
Public Property Get fs_Hz() As Double
    fs_Hz = f_Hz * (1 - data_.s_d)
End Property
' скорость вращения ротора с учетом проскальзования
Public Property Get ns_obmin() As Double
    ns_obmin = fs_Hz * 60
End Property
' синхронная угловая частота частота вращения при расчетном режиме
Public Property Get Omega_radsec() As Double
  Omega_radsec = f_Hz * (2 * const_Pi)
End Property
' угловая частота вращения при расчетном режиме
Public Property Get Omegas_radsec() As Double
  Omegas_radsec = fs_Hz * (2 * const_Pi)
End Property
' номинальная частота вращения вала (с учетом проскальзования)
Public Property Get OmegaNoms_radsec() As Double
  OmegaNoms_radsec = fnoms_Hz * 2 * const_Pi
End Property
' номинальная синхронная частота вращения вала
Public Property Get OmegaNom_radsec() As Double
  OmegaNom_radsec = Fnom_Hz * 2 * const_Pi
End Property
' свойства схемы замещения
' параметры c коррекцией на реальные показатели работы
' индуктивное сопротивление обмоток для режима короткого замыкания, при неподвижном роторе
Public Property Get xk() As Double
' сразу корректируем индуктивность обмотки на частоту
    xk = xk_ * f_Hz / Fnom_Hz
End Property
' активное сопротивление обмотки статора
Public Property Get R1() As Double
    R1 = R1_
End Property
' активное сопротивление обмотки ротора приведенное к обмотке статора
Public Property Get R2_() As Double
    R2_ = R2__
End Property
' расчет  тока холостого хода при произвольном напряжении и частоте
Public Property Get Ix_A() As Double
    Dim UUn_fnf As Double
    Dim Kn As Double
    UUn_fnf = U_phase_V / Unom_phase_V * Fnom_Hz / f_Hz
    Kn = 1.2786 * UUn_fnf - 0.2689   ' поправка по Гридину для учета намагничивающего тока
    Ix_A = Kn * Ix_A_ * UUn_fnf
    
End Property
Public Property Get cosPhix_d() As Double
    cosPhix_d = cos_phix_d_
End Property
Public Property Get Phix_d() As Double
    Phix_d = phix_d_
End Property
' оценка момента на холостом ходу
Public Property Get M0_Nm() As Double
  M0_Nm = Mnom_Nm * (xi_ - 1)
End Property
' метод расчета момента в зависимости от скольжения
Public Property Get M_Nm() As Double
 M_Nm = data_.Mshaft_Nm
End Property
' расчет потребляемого тока в зависимости от скольжения
Public Property Get I_phase_A() As Double
    I_phase_A = data_.I_phase_A
End Property
Public Property Get I_lin_A() As Double
    I_lin_A = data_.I_lin_A
End Property
Public Property Get CosPhi_d() As Double
    CosPhi_d = data_.cosphi
End Property
Public Property Get eff_d() As Double
    eff_d = data_.eff_d
End Property
Public Sub InitMotor(Optional ByVal M_ID As Integer = 0, _
                     Optional ByVal Unomlin_V As Double = 1000, _
                     Optional ByVal Pnom_kW As Double = 10, _
                     Optional ByVal Fnom_Hz As Double = 50, _
                     Optional ByVal eff_fr As Double = 0.85, _
                     Optional ByVal cosphi_fr As Double = 0.8, _
                     Optional ByVal slip_fr As Double = 0.05, _
                     Optional ByVal diam_mm As Double = 117, _
                     Optional ByVal lambda As Double = 2, _
                     Optional ByVal alpha0 As Double = 0.4, _
                     Optional ByVal xi0 As Double = 1.05)
    ID_ = M_ID
    Select Case ID_
        Case 0
            Call InitMotorSimple(Unomlin_V, Pnom_kW, Fnom_Hz, eff_fr, cosphi_fr, slip_fr)
        Case 1
            Call InitMotorDefaultPower(Unomlin_V, Pnom_kW, Fnom_Hz)
        Case 2
            Call InitMotorGridin(Unomlin_V, Pnom_kW, eff_fr, cosphi_fr, Fnom_Hz, slip_fr, diam_mm, lambda, alpha0, xi0)
    End Select
End Sub
Private Sub InitMotorSimple(Unomlin_V As Double, _
                            Pnom_kW As Double, _
                            Fnom_Hz As Double, _
                            eff_fr As Double, _
                            cosphi_fr As Double, _
                            slip_fr As Double)
           
    nom_data_ = set_motor_data_simple_(True, Pnom_kW, Unomlin_V, Fnom_Hz, eff_fr, slip_fr, cosphi_fr)
    
End Sub
Private Sub InitMotorGridin(Optional Unomlin_V As Double = 1000, _
                            Optional Pnom_kW As Double = 10, _
                            Optional eff As Double = 0.85, _
                            Optional cosphi As Double = 0.85, _
                            Optional f_Hz As Double = 50, _
                            Optional S As Double = 0.065, _
                     Optional ByVal diam_mm As Double = 117, _
                     Optional ByVal lambda As Double = 2, _
                     Optional ByVal alpha0 As Double = 0.4, _
                     Optional ByVal xi0 As Double = 1.05)
' инициализация двигателя на основе схемы замещения по Гридину
        Dim Inomlin_A As Double
On Error GoTo er1:
        nom_data_.Pshaft_kW = Pnom_kW
        nom_data_.Pelectr_kW = Pnom_kW / eff
        Inomlin_A = nom_data_.Pelectr_kW / (root3 * Unomlin_V * cosphi / 1000)
        
        motor_name_ = "ПЭД " & nom_data_.Pshaft_kW & "-" & diam_mm & "-" & Unomlin_V
        manufacturer_name_ = "Induction_motor"
        nom_data_.U_phase_V = Unomlin_V / root3
        nom_data_.I_phase_A = Inomlin_A
        nom_data_.U_lin_V = Unomlin_V
        nom_data_.I_lin_A = Inomlin_A
        nom_data_.eff_d = eff
        nom_data_.cosphi = cosphi
        nom_data_.f_Hz = f_Hz
        nom_data_.s_d = S
        lambda_d_ = lambda
        Me.alpha0 = alpha0
        xi_ = xi0
        d_cas_min_mm_ = diam_mm + 6
        diam_mm_ = diam_mm
        
        nom_data_.Mshaft_Nm = nom_data_.Pshaft_kW * 1000 / (f_Hz * (1 - S) * 2 * const_Pi)
        nom_data_.load_d = 1
                
        Call CalcModelGridin
        Exit Sub
er1:
     addLogMsg "Не удалось инициализировать асинхронный двигатель"
End Sub
Private Sub InitMotorDefaultPower(ByVal Unomlin_V As Double, _
                                  ByVal Pnom_kW As Double, _
                                  ByVal Fnom_Hz As Double)
   
    nom_data_ = set_motor_data_pow_nom_(Pnom_kW, Unomlin_V, Fnom_Hz)
   
    motor_name_ = "ПЭД " & Format(nom_data_.Pshaft_kW, 0)
    ' проверяем - если дефолтный мотор тогда грузим что есть
    lambda_d_ = 5 ' перегрузочная способность - с потолка экспертно
    I_start_A_ = nom_data_.I_lin_A * 5 ' пусковой ток тоже с потолка экспертно
    d_cas_min_mm_ = 120
    v_liq_min_msec_ = 0.06
    'num_sections_ = 1
    length_m_ = 10
    m_kg_ = 300
    manufacturer_name_ = "Тестовый ПЭД"
    
End Sub
Public Sub calc_motor_slip(S As Double, _
                      Optional freq_Hz As Double = 50, _
                      Optional Ulin_V As Double = 1000)
    ' Расчет по схеме замещения в зависимости от проскальзывания
    ' чтобы построить красивый график электромеханической характеристики
    '   в основных расчетах не применяется
    
    If S = 0 Then
        S = 0.00015
    End If
    data_.U_lin_V = Ulin_V
    data_.U_phase_V = Ulin_V / root3
    If ID = 2 Then
        Call calc_ADGridin(S, data_.U_phase_V, freq_Hz)
    End If
End Sub
Public Sub calc_motor_power(pow_mech_kW As Double, _
                      Optional freq_Hz As Double = 50, _
                      Optional Ulin_V As Double = 1000)
' расчет параметров двигателя при заданном моменте на валу
    Dim load As Double
    Dim S As Double, S1 As Double, S2 As Double
    Dim I As Integer
    
    I = 0
    data_.U_lin_V = Ulin_V
    data_.U_phase_V = Ulin_V / root3
    
    If ID = 2 Then
        S2 = nom_data_.s_d * 3 ' макс граница
        S1 = 0
        ' дихотомией найдем значение проскальзывания
        ' до 8 итераций обычно надо
        ' можно и быстрее сделать, но потом
        Do
            S = (S1 + S2) / 2
            Call calc_ADGridin(S, data_.U_phase_V, freq_Hz)
            If pow_mech_kW > data_.Pshaft_kW Then
                S1 = S
            Else
                S2 = S
            End If
            I = I + 1
        Loop Until Abs(pow_mech_kW - data_.Pshaft_kW) < 0.01 Or I > 25
       
        If I >= 25 Then
            Dim msg As String
            msg = "CESPMotor.calc_motor method Gridin Ошибка при расчете мотора, расчет проскальзования по мощности не сошелся, i =" + CStr(I)
            Err.Raise kErrESPcalc, , msg
        End If
        
    ElseIf ID = 1 Then
      '  data_ = set_motor_data_(load, nom_data_.U_lin_V, nom_data_.I_lin_A, freq_Hz, , Ulin_V)
    ElseIf ID = 0 Then
        data_ = set_motor_data_simple_(False, pow_mech_kW, Unom_lin_V, Fnom_Hz, Effnom_d, Snom_d, CosPhinom_d)
        
    End If
End Sub
Public Sub calc_motor_mom_Nm(Mshaft_Nm As Double, _
                      Optional freq_Hz As Double = 50, _
                      Optional Ulin_V As Double = 1000)
' расчет параметров двигателя при заданном моменте на валу
    Dim load As Double
    Dim S As Double, S1 As Double, S2 As Double
    Dim I As Integer
    Dim pow_mech_kW As Double
    
    I = 0
    data_.U_lin_V = Ulin_V
    data_.U_phase_V = Ulin_V / root3
    
    If ID = 2 Then
        S2 = nom_data_.s_d * 3 ' макс граница
        S1 = 0
        ' дихотомией найдем значение проскальзывания
        ' до 8 итераций обычно надо
        ' можно и быстрее сделать, но потом
        If Mshaft_Nm > 0 Then
            Do
                S = (S1 + S2) / 2
                Call calc_ADGridin(S, data_.U_phase_V, freq_Hz)
                If Mshaft_Nm > data_.Mshaft_Nm Then
                    S1 = S
                Else
                    S2 = S
                End If
                I = I + 1
            Loop Until Abs(Mshaft_Nm - data_.Mshaft_Nm) < 0.01 Or I > 25
        Else
            S = 0
            Call calc_ADGridin(S, data_.U_phase_V, freq_Hz)
        End If
       
        If I >= 25 Then
            Dim msg As String
            msg = "CESPMotor.calc_motor method Gridin Ошибка при расчете мотора, расчет проскальзования по мощности не сошелся, i =" + CStr(I)
            Err.Raise kErrESPcalc, , msg
        End If
        
    ElseIf ID = 1 Then
        data_ = set_motor_data_mom_(Mshaft_Nm, Ulin_V, freq_Hz)
    ElseIf ID = 0 Then
        data_ = set_motor_data_simple_(False, pow_mech_kW, Unom_lin_V, Fnom_Hz, Effnom_d, Snom_d, CosPhinom_d)
        
    End If
End Sub
Sub Class_Initialize()
     ' проинициализируем параметры двигателя значениями по  умолчанию, чтобы с ходу можно было счиатать
    Call InitMotor
    Call calc_motor_power(8)  ' инициализируем более менее разумными параметрами
    length_m_ = 5
    diam_mm_ = 117
    dPower_protector_W = 400
    
     alpha0 = 0.4  ' константа рекомендованная в методичке Гридина
     xi_ = 1.06
End Sub
Public Property Get minDcas_mm() As Double
    minDcas_mm = d_cas_min_mm_
End Property
Public Property Get minVliq_msec() As Double
   minVliq_msec = v_liq_min_msec_
End Property
 ' глубина установки  (верхняя точка)
 Public Property Get h_mes_top_m() As Double
    h_mes_top_m = h_mes_top_
 End Property
 
 Public Property Let h_mes_top_m(val As Double)
    h_mes_top_ = val
 End Property
 ' глубина нижней точки установки
 Public Property Get h_mes_down_m() As Double
    h_mes_down_m = h_mes_top_m + length_m
 End Property
Public Property Get length_m() As Double
   length_m = length_m_
End Property
Public Property Get M_kg() As Double
   M_kg = m_kg_
End Property
Public Property Get ID() As Integer
   ID = ID_
End Property
Public Property Get motorName() As String
    motorName = motor_name_
End Property
Public Property Get manufacturer_name() As String
    manufacturer_name = manufacturer_name_
End Property
Private Function set_motor_data_pow_nom_( _
                                 ByVal pow_kW As Double, _
                                 ByVal U As Double, _
                        Optional ByVal f As Double = 50) As MOTOR_DATA
    ' расчет параметров ПЭД по паспортным характеристикам
    ' load - загрузка на заданной частоте
    ' Unm, Inm, fnm - номинальные показатели, определяющие характеристики двигателя
    '
    ' freal, U - рабочие показатели, которые могут внести поправки на характеристики
    
        ' для расчета всех параметров дефолтного насоса можно использовать характеристики насоса
        Dim d As MOTOR_DATA
        Dim load As Double
        Dim Uf As Double    ' отличие рабочего напряжения от номинального
        Dim FF As Double    ' отличие рабочей частоты от номинальной
        Dim Inm As Double
        load = 100
        
        d.f_Hz = f
        d.U_lin_V = U
        d.U_phase_V = d.U_lin_V / root3
        ' напряжение оценили - возможно надо сделать поправку на напряжение
        d.eff_d = motor_eff_default_d(load, d.f_Hz) '* Eff_cf
        d.cosphi = motor_cosphi_default_d(load, d.f_Hz) '* cosphi_cf
        d.s_d = (1 - motor_rot_speed_default_rmp(load, d.f_Hz) / (d.f_Hz * 60)) '/ S_cf
        d.Pshaft_kW = pow_kW
        d.Mshaft_Nm = d.Pshaft_kW * 1000 / ((d.f_Hz * (1 - d.s_d) * 2 * const_Pi))
        d.Pelectr_kW = d.Pshaft_kW / d.eff_d
        d.I_phase_A = d.Pelectr_kW * 1000 / (root3 * d.U_lin_V * d.cosphi)
        d.I_lin_A = d.I_phase_A
        d.load_d = load
        set_motor_data_pow_nom_ = d
        
End Function
Private Function set_motor_data_mom_( _
                                 ByVal mom_Nm As Double, _
                                 ByVal U As Double, _
                        Optional ByVal f As Double = 50) As MOTOR_DATA
    ' расчет параметров ПЭД по паспортным характеристикам
    ' load - загрузка на заданной частоте
    ' Unm, Inm, fnm - номинальные показатели, определяющие характеристики двигателя
    '
    ' freal, U - рабочие показатели, которые могут внести поправки на характеристики
    
        ' для расчета всех параметров дефолтного насоса можно использовать характеристики насоса
        Dim d As MOTOR_DATA
        ' correction factors depends on U/Unm
        Dim load As Double
        Dim Eff_cf As Double
        Dim I_cf As Double
        Dim cosphi_cf As Double
        Dim S_cf As Double
        Dim Uf As Double    ' отличие рабочего напряжения от номинального
        Dim FF As Double    ' отличие рабочей частоты от номинальной
            ' оценим загрузку для заданной частоты
        load = mom_Nm / nom_data_.Mshaft_Nm * 100
        FF = f / Fnom_Hz
        Uf = U / Unom_lin_V * 100
        
        d.f_Hz = f
        d.U_lin_V = U
        d.U_phase_V = d.U_lin_V / root3
        ' напряжение оценили - возможно надо сделать поправку на напряжение
        
        ' поправочные параметры, рассчитаны на основе рисунка 3.14 из книги Takacs Gabor: ESP Manual
        If Uf = 100 Then
            ' чтобы устранить отличия от 1 поправок присвоем точные значения
            Eff_cf = 1
            I_cf = 1
            cosphi_cf = 1
            S_cf = 1
        Else
            Eff_cf = motor_eff_u_corr(Uf)
            I_cf = motor_I_u_corr(Uf)
            cosphi_cf = motor_cosphi_u_corr(Uf)
            S_cf = motor_slip_u_corr(Uf)
        End If
        
        d.eff_d = motor_eff_default_d(load, d.f_Hz) * Eff_cf
        d.I_phase_A = motor_current_default_d(load, d.f_Hz) * I_cf * Inom_lin_A
        d.s_d = (1 - motor_rot_speed_default_rmp(load, d.f_Hz) / (d.f_Hz * 60)) / S_cf
        d.Mshaft_Nm = mom_Nm
        d.Pshaft_kW = d.Mshaft_Nm * (d.f_Hz * (1 - d.s_d) * 2 * const_Pi) / 1000
        d.Pelectr_kW = d.Pshaft_kW / d.eff_d
        d.cosphi = d.Pelectr_kW * 1000 / (root3 * d.U_lin_V * d.I_phase_A)
        d.I_lin_A = d.I_phase_A
        d.load_d = load
        set_motor_data_mom_ = d
        
End Function
Private Function set_motor_data_simple_(ByVal nom As Boolean, _
                                        ByVal pow_mech_kW As Double, _
                                        ByVal U As Double, _
                                        ByVal f As Double, _
                                        ByVal eff As Double, _
                                        ByVal slip As Double, _
                                        ByVal cosphi As Double) As MOTOR_DATA
    ' расчет параметров ПЭД по паспортным характеристикам
    ' load - загрузка на заданной частоте
    ' Unm, Inm, fnm - номинальные показатели, определяющие характеристики двигателя
    '
    ' freal, U - рабочие показатели, которые могут внести поправки на характеристики
    
    Dim d As MOTOR_DATA
    
    If nom Then
        d.f_Hz = f
        d.U_lin_V = U
        d.U_phase_V = d.U_lin_V / root3
        
        d.eff_d = eff
        d.cosphi = cosphi
        d.s_d = slip
        
        d.Pshaft_kW = pow_mech_kW
        If d.eff_d > 0 Then
            d.Pelectr_kW = pow_mech_kW / d.eff_d
        Else
            Dim msg As String
            msg = "CESPMotor.set_motor_data_simple_ error  eff=0"
            Err.Raise kErrESPbase, , msg
        End If
        d.I_phase_A = d.Pelectr_kW / (root3 * U * cosphi / 1000)
        d.I_lin_A = d.I_phase_A
        ' оценим мощность на валу с учетом скольжения и частоты
        d.Mshaft_Nm = d.Pshaft_kW * 1000 / (d.f_Hz * (1 - d.s_d) * 2 * const_Pi)
        d.load_d = 100
    Else
        
        d.f_Hz = f
        d.U_lin_V = U
        d.U_phase_V = d.U_lin_V / root3
        
        d.eff_d = eff
        d.cosphi = cosphi
        d.s_d = slip
        
        d.Pshaft_kW = pow_mech_kW
        d.Pelectr_kW = pow_mech_kW / d.eff_d
        d.I_phase_A = d.Pelectr_kW / (root3 * U * cosphi / 1000)
        d.I_lin_A = d.I_phase_A
        ' оценим мощность на валу с учетом скольжения и частоты
        d.Mshaft_Nm = d.Pshaft_kW * 1000 / (d.f_Hz * (1 - d.s_d) * 2 * const_Pi)
        d.load_d = pow_mech_kW / Pnom_kW * f / Fnom_Hz
    End If
    
    set_motor_data_simple_ = d
        
End Function
Private Function motor_rot_speed_default_rmp(load, Optional freq_Hz = 50, Optional motID = 0)
' вывод параметров стандартного двигателя
' обороты -2.07391E-09    5.66468E-07 -4.70742E-05    -0.004462241    -1.526740367    3012.664336
    Dim l As Double
    Dim SPD As Double
    If load >= 0 Or load < 150 Then
        l = load
        SPD = -0.00000000207391 * l ^ 5 + 0.000000566468 * l ^ 4 - 0.0000470742 * l ^ 3 - 0.004462241 * l ^ 2 - 1.526740367 * l + 3012.664336
        motor_rot_speed_default_rmp = SPD + (freq_Hz * 60 - 3000) - 0.0035 * 3000
    Else
        motor_rot_speed_default_rmp = 0
    End If
End Function
Private Function motor_current_default_d(load, Optional freq_Hz = 50, Optional motID = 0)
' вывод параметров стандартного двигателя
'ток 6.03318E-10 -3.73389E-07    5.7149E-05  0.000128248 0.362600747 36.76223776
    Dim l As Double
    If load >= 0 Or load < 150 Then
        l = load
        motor_current_default_d = 0.000000000603318 * l ^ 5 - 0.000000373389 * l ^ 4 + 0.000057149 * l ^ 3 + 0.000128248 * l ^ 2 + 0.362600747 * l + 36.76223776
        motor_current_default_d = motor_current_default_d / 100
    Else
        motor_current_default_d = 0
    End If
End Function
Private Function motor_cosphi_default_d(load, Optional freq_Hz = 50, Optional motID = 0)
' вывод параметров стандартного двигателя
'коэф мощ    -5.46757E-10    -1.08923E-07    0.000123969 -0.026538059    2.410930241 0.394405594
    Dim l As Double
    If load >= 0 Or load < 150 Then
        l = load
        motor_cosphi_default_d = -0.000000000546757 * l ^ 5 - 0.000000108923 * l ^ 4 + _
                                    0.000123969 * l ^ 3 - 0.026538059 * l ^ 2 + 2.410930241 * l + 0.394405594
        motor_cosphi_default_d = motor_cosphi_default_d / 100
        
        motor_cosphi_default_d = (motor_cosphi_default_d + 0.25) / 1.25
        
    Else
        motor_cosphi_default_d = 0
    End If
End Function
Private Function motor_eff_default_d(load, Optional freq_Hz = 50, Optional motID = 0)
' вывод параметров стандартного двигателя
'КПД 1.0313E-08  -4.9338E-06 0.000914116 -0.083174452    3.73047825  16.13321678
    Dim l As Double
    If load >= 0 Or load < 150 Then
        l = load
        motor_eff_default_d = 0.000000010313 * l ^ 5 - 0.0000049338 * l ^ 4 + _
                              0.000914116 * l ^ 3 - 0.083174452 * l ^ 2 + 3.73047825 * l + 16.13321678
        motor_eff_default_d = motor_eff_default_d / 100
    Else
        motor_eff_default_d = 0
    End If
End Function
' ====== расчет по Гридину по П образной схеме замещения
' расчет текущих параметров работы двигателя при заданных частоте и напряжении и при вращении
Public Sub calc_ADGridin(ByVal S As Double, _
                         ByVal Uph_V As Double, _
                         ByVal Fw_Hz As Double)
     Dim R2_s As Double
     Dim I2_ As Double
     Dim phi2 As Double
     
     data_.s_d = S     ' сохраняем скольжение
     data_.f_Hz = Fw_Hz
     data_.U_phase_V = Uph_V
     data_.U_lin_V = Uph_V * 3 ^ 0.5
     If S < 0.00015 Then
         S = 0.00015
     End If
     'S = 0.065
     R2_s = R2__ / S     ' вычисляем вспомогательный параметр - активное сопротивление обмотки ротора деленное на скольжение
    data_.Mshaft_Nm = 3 * Uph_V ^ 2 * R2_s / (Fw_Hz * (2 * const_Pi) * ((R1_ + R2_s) ^ 2 + xk ^ 2)) * (2 - xi_) '- M0_Nm
'    data_.Mshaft_Nm = data_.Mshaft_Nm - data_.Mshaft_Nm * (xi_ - 1)
    I2_ = Uph_V / ((R1 + R2_s) ^ 2 + xk ^ 2) ^ 0.5
    phi2 = Atn(xk / (R1 + R2_s))
    data_.I_phase_A = (Ix_A ^ 2 + I2_ ^ 2 + 2 * Ix_A * I2_ * Cos(Phix_d - phi2)) ^ 0.5
    data_.I_lin_A = data_.I_phase_A
    data_.cosphi = (Ix_A * Cos(phix_d_) + I2_ * Cos(phi2)) / data_.I_phase_A
    data_.Pelectr_kW = 3 * U_phase_V * data_.I_phase_A * data_.cosphi / 1000
    data_.Pshaft_kW = data_.Mshaft_Nm * Fw_Hz * (1 - S) * (2 * const_Pi) / 1000
    data_.eff_d = data_.Pshaft_kW / data_.Pelectr_kW
     
   
End Sub
' процедура расчета скольжения по заданному моменту на валу двигателя
Public Function calc_s_d(M_Nm As Double, Uphase_V As Double, f_Hz) As Double
    Dim Rs As Double
    Dim S As Double
    
    Rs = 3 * (Uphase_V ^ 2) / (2 * (M_Nm + M0_Nm) * f_Hz * 2 * const_Pi) - R1
    S = R2_ / (Rs + (Rs ^ 2 - (R1 ^ 2 + xk ^ 2)) ^ 0.5)
    Call calc_ADGridin(S, Uphase_V, f_Hz)
    calc_s_d = S
End Function
' процедура расчета параметров схемы замещения по Гридину
Public Sub CalcModelGridin()
    ' при расчете модели идет расчет на номинальной частоте вращения и номинальном напряжении
     
    ' Dim alpha0 As Double
     Dim A As Double
     Dim b As Double
     Dim Rm As Double
     Dim G As Double
     Dim P1n_W As Double  ' потребляемая мощность двигателя
     Dim I1n_A As Double  ' фазный ток
     Dim I2n__A As Double
     Dim phinom As Double
     Dim phi2n As Double
     Dim R2s_ As Double
     With nom_data_
        ' расчитываем показатели схемы замещения. Сначала вспомогательные переменные
        A = alpha0 / xi_ * (1 - .eff_d) / .eff_d * (1 - .s_d) / .s_d - 1
        Rm = 3 * .U_phase_V ^ 2 * (1 - .s_d) / (2 * .Pshaft_kW * 1000 * (lambda_d_ + xi_ - 1))
        G = 1 / .s_d ^ 2 + 2 * A / .s_d + A ^ 2
        b = (lambda_d_ + xi_ - 1) / xi_
        ' далее считаем сопротивления статора и ротора и индуктивность
        R2__ = Rm / G * (b / .s_d + A + ((b / .s_d + A) ^ 2 - G) ^ 0.5)
        R2s_ = R2__ / .s_d
        R1_ = A * R2__ '* 2
        xk_ = (Rm ^ 2 - 2 * Rm * R1_) ^ 0.5
        ' теперь считаем показатели холостого хода при номинальной частоте вращения
        P1n_W = .Pshaft_kW * 1000 / .eff_d
        I1n_A = P1n_W / (3 * .U_phase_V * .cosphi)    ' оценили номинальный ток, хотя он может быть и задан
        ' найдем ток в обмотке ротока приведенный к обмотке статора
        I2n__A = .U_phase_V / ((R1_ + R2s_) ^ 2 + xk_ ^ 2) ^ 0.5
        phinom = ArcCos(.cosphi)
        phi2n = Atn(xk_ / (R1_ + R2s_))  ' * 3
        Ix_A_ = (I1n_A ^ 2 + I2n__A ^ 2 - 2 * I1n_A * I2n__A * Cos(phinom - phi2n)) ^ 0.5
        cos_phix_d_ = (I1n_A * .cosphi - I2n__A * Cos(phi2n)) / Ix_A_
        phix_d_ = ArcCos(cos_phix_d_)
    End With
     
End Sub

