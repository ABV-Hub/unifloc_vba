''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2007-2008, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Neural networks ensemble
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type MLPEnsemble
    StructInfo() As Long
    EnsembleSize As Long
    NIn As Long
    NOut As Long
    WCount As Long
    IsSoftmax As Boolean
    PostProcessing As Boolean
    Weights() As Double
    ColumnMeans() As Double
    ColumnSigmas() As Double
    SerializedLen As Long
    SerializedMLP() As Double
    TmpWeights() As Double
    TmpMeans() As Double
    TmpSigmas() As Double
    Neurons() As Double
    DFDNET() As Double
    Y() As Double
End Type
'Global constants
Private Const MLPNTotalOffset As Long = 3#
Private Const MLPEVNum As Long = 9#
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreate0, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreate0(ByVal NIn As Long, _
         ByVal NOut As Long, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreate0(NIn, NOut, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreate1, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreate1(ByVal NIn As Long, _
         ByVal NHid As Long, _
         ByVal NOut As Long, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreate1(NIn, NHid, NOut, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreate2, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreate2(ByVal NIn As Long, _
         ByVal NHid1 As Long, _
         ByVal NHid2 As Long, _
         ByVal NOut As Long, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreate2(NIn, NHid1, NHid2, NOut, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateB0, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateB0(ByVal NIn As Long, _
         ByVal NOut As Long, _
         ByVal B As Double, _
         ByVal D As Double, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateB0(NIn, NOut, B, D, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateB1, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateB1(ByVal NIn As Long, _
         ByVal NHid As Long, _
         ByVal NOut As Long, _
         ByVal B As Double, _
         ByVal D As Double, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateB1(NIn, NHid, NOut, B, D, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateB2, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateB2(ByVal NIn As Long, _
         ByVal NHid1 As Long, _
         ByVal NHid2 As Long, _
         ByVal NOut As Long, _
         ByVal B As Double, _
         ByVal D As Double, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateB2(NIn, NHid1, NHid2, NOut, B, D, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateR0, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateR0(ByVal NIn As Long, _
         ByVal NOut As Long, _
         ByVal A As Double, _
         ByVal B As Double, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateR0(NIn, NOut, A, B, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateR1, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateR1(ByVal NIn As Long, _
         ByVal NHid As Long, _
         ByVal NOut As Long, _
         ByVal A As Double, _
         ByVal B As Double, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateR1(NIn, NHid, NOut, A, B, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateR2, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateR2(ByVal NIn As Long, _
         ByVal NHid1 As Long, _
         ByVal NHid2 As Long, _
         ByVal NOut As Long, _
         ByVal A As Double, _
         ByVal B As Double, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateR2(NIn, NHid1, NHid2, NOut, A, B, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateC0, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateC0(ByVal NIn As Long, _
         ByVal NOut As Long, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateC0(NIn, NOut, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateC1, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateC1(ByVal NIn As Long, _
         ByVal NHid As Long, _
         ByVal NOut As Long, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateC1(NIn, NHid, NOut, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Like MLPCreateC2, but for ensembles.
'
'  -- ALGLIB --
'     Copyright 18.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateC2(ByVal NIn As Long, _
         ByVal NHid1 As Long, _
         ByVal NHid2 As Long, _
         ByVal NOut As Long, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim Net As MultiLayerPerceptron
    Call MLPCreateC2(NIn, NHid1, NHid2, NOut, Net)
    Call MLPECreateFromNetwork(Net, EnsembleSize, Ensemble)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Creates ensemble from network. Only network geometry is copied.
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECreateFromNetwork(ByRef Network As MultiLayerPerceptron, _
         ByVal EnsembleSize As Long, _
         ByRef Ensemble As MLPEnsemble)
    Dim i As Long
    Dim CCount As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' network properties
    '
    Call MLPProperties(Network, Ensemble.NIn, Ensemble.NOut, Ensemble.WCount)
    If MLPIsSoftmax(Network) Then
        CCount = Ensemble.NIn
    Else
        CCount = Ensemble.NIn + Ensemble.NOut
    End If
    Ensemble.PostProcessing = False
    Ensemble.IsSoftmax = MLPIsSoftmax(Network)
    Ensemble.EnsembleSize = EnsembleSize
    
    '
    ' structure information
    '
    ReDim Ensemble.StructInfo(0# To Network.StructInfo(0#) - 1#)
    For i = 0# To Network.StructInfo(0#) - 1# Step 1
        Ensemble.StructInfo(i) = Network.StructInfo(i)
    Next i
    
    '
    ' weights, means, sigmas
    '
    ReDim Ensemble.Weights(0# To EnsembleSize * Ensemble.WCount - 1#)
    ReDim Ensemble.ColumnMeans(0# To EnsembleSize * CCount - 1#)
    ReDim Ensemble.ColumnSigmas(0# To EnsembleSize * CCount - 1#)
    For i = 0# To EnsembleSize * Ensemble.WCount - 1# Step 1
        Ensemble.Weights(i) = Rnd() - 0.5
    Next i
    For i = 0# To EnsembleSize - 1# Step 1
        i1_ = (0#) - (i * CCount)
        For i_ = i * CCount To (i + 1#) * CCount - 1# Step 1
            Ensemble.ColumnMeans(i_) = Network.ColumnMeans(i_ + i1_)
        Next i_
        i1_ = (0#) - (i * CCount)
        For i_ = i * CCount To (i + 1#) * CCount - 1# Step 1
            Ensemble.ColumnSigmas(i_) = Network.ColumnSigmas(i_ + i1_)
        Next i_
    Next i
    
    '
    ' serialized part
    '
    Call MLPSerialize(Network, Ensemble.SerializedMLP, Ensemble.SerializedLen)
    
    '
    ' temporaries, internal buffers
    '
    ReDim Ensemble.TmpWeights(0# To Ensemble.WCount - 1#)
    ReDim Ensemble.TmpMeans(0# To CCount - 1#)
    ReDim Ensemble.TmpSigmas(0# To CCount - 1#)
    ReDim Ensemble.Neurons(0# To Ensemble.StructInfo(MLPNTotalOffset) - 1#)
    ReDim Ensemble.DFDNET(0# To Ensemble.StructInfo(MLPNTotalOffset) - 1#)
    ReDim Ensemble.Y(0# To Ensemble.NOut - 1#)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copying of MLPEnsemble strucure
'
'INPUT PARAMETERS:
'    Ensemble1 -   original
'
'OUTPUT PARAMETERS:
'    Ensemble2 -   copy
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPECopy(ByRef Ensemble1 As MLPEnsemble, _
         ByRef Ensemble2 As MLPEnsemble)
    Dim i As Long
    Dim SSize As Long
    Dim CCount As Long
    Dim NTotal As Long
    Dim i_ As Long
    
    '
    ' Unload info
    '
    SSize = Ensemble1.StructInfo(0#)
    If Ensemble1.IsSoftmax Then
        CCount = Ensemble1.NIn
    Else
        CCount = Ensemble1.NIn + Ensemble1.NOut
    End If
    NTotal = Ensemble1.StructInfo(MLPNTotalOffset)
    
    '
    ' Allocate space
    '
    ReDim Ensemble2.StructInfo(0# To SSize - 1#)
    ReDim Ensemble2.Weights(0# To Ensemble1.EnsembleSize * Ensemble1.WCount - 1#)
    ReDim Ensemble2.ColumnMeans(0# To Ensemble1.EnsembleSize * CCount - 1#)
    ReDim Ensemble2.ColumnSigmas(0# To Ensemble1.EnsembleSize * CCount - 1#)
    ReDim Ensemble2.TmpWeights(0# To Ensemble1.WCount - 1#)
    ReDim Ensemble2.TmpMeans(0# To CCount - 1#)
    ReDim Ensemble2.TmpSigmas(0# To CCount - 1#)
    ReDim Ensemble2.SerializedMLP(0# To Ensemble1.SerializedLen - 1#)
    ReDim Ensemble2.Neurons(0# To NTotal - 1#)
    ReDim Ensemble2.DFDNET(0# To NTotal - 1#)
    ReDim Ensemble2.Y(0# To Ensemble1.NOut - 1#)
    
    '
    ' Copy
    '
    Ensemble2.NIn = Ensemble1.NIn
    Ensemble2.NOut = Ensemble1.NOut
    Ensemble2.WCount = Ensemble1.WCount
    Ensemble2.EnsembleSize = Ensemble1.EnsembleSize
    Ensemble2.IsSoftmax = Ensemble1.IsSoftmax
    Ensemble2.PostProcessing = Ensemble1.PostProcessing
    Ensemble2.SerializedLen = Ensemble1.SerializedLen
    For i = 0# To SSize - 1# Step 1
        Ensemble2.StructInfo(i) = Ensemble1.StructInfo(i)
    Next i
    For i_ = 0# To Ensemble1.EnsembleSize * Ensemble1.WCount - 1# Step 1
        Ensemble2.Weights(i_) = Ensemble1.Weights(i_)
    Next i_
    For i_ = 0# To Ensemble1.EnsembleSize * CCount - 1# Step 1
        Ensemble2.ColumnMeans(i_) = Ensemble1.ColumnMeans(i_)
    Next i_
    For i_ = 0# To Ensemble1.EnsembleSize * CCount - 1# Step 1
        Ensemble2.ColumnSigmas(i_) = Ensemble1.ColumnSigmas(i_)
    Next i_
    For i_ = 0# To Ensemble1.SerializedLen - 1# Step 1
        Ensemble2.SerializedMLP(i_) = Ensemble1.SerializedMLP(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Serialization of MLPEnsemble strucure
'
'INPUT PARAMETERS:
'    Ensemble-   original
'
'OUTPUT PARAMETERS:
'    RA      -   array of real numbers which stores ensemble,
'                array[0..RLen-1]
'    RLen    -   RA lenght
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPESerialize(ByRef Ensemble As MLPEnsemble, _
         ByRef RA() As Double, _
         ByRef RLen As Long)
    Dim i As Long
    Dim SSize As Long
    Dim NTotal As Long
    Dim CCount As Long
    Dim HSize As Long
    Dim Offs As Long
    Dim i_ As Long
    Dim i1_ As Long
    HSize = 13#
    SSize = Ensemble.StructInfo(0#)
    If Ensemble.IsSoftmax Then
        CCount = Ensemble.NIn
    Else
        CCount = Ensemble.NIn + Ensemble.NOut
    End If
    NTotal = Ensemble.StructInfo(MLPNTotalOffset)
    RLen = HSize + SSize + Ensemble.EnsembleSize * Ensemble.WCount + 2# * CCount * Ensemble.EnsembleSize + Ensemble.SerializedLen
    
    '
    '  RA format:
    '  [0]     RLen
    '  [1]     Version (MLPEVNum)
    '  [2]     EnsembleSize
    '  [3]     NIn
    '  [4]     NOut
    '  [5]     WCount
    '  [6]     IsSoftmax 0/1
    '  [7]     PostProcessing 0/1
    '  [8]     sizeof(StructInfo)
    '  [9]     NTotal (sizeof(Neurons), sizeof(DFDNET))
    '  [10]    CCount (sizeof(ColumnMeans), sizeof(ColumnSigmas))
    '  [11]    data offset
    '  [12]    SerializedLen
    '
    '  [..]    StructInfo
    '  [..]    Weights
    '  [..]    ColumnMeans
    '  [..]    ColumnSigmas
    '
    ReDim RA(0# To RLen - 1#)
    RA(0#) = RLen
    RA(1#) = MLPEVNum
    RA(2#) = Ensemble.EnsembleSize
    RA(3#) = Ensemble.NIn
    RA(4#) = Ensemble.NOut
    RA(5#) = Ensemble.WCount
    If Ensemble.IsSoftmax Then
        RA(6#) = 1#
    Else
        RA(6#) = 0#
    End If
    If Ensemble.PostProcessing Then
        RA(7#) = 1#
    Else
        RA(7#) = 9#
    End If
    RA(8#) = SSize
    RA(9#) = NTotal
    RA(10#) = CCount
    RA(11#) = HSize
    RA(12#) = Ensemble.SerializedLen
    Offs = HSize
    For i = Offs To Offs + SSize - 1# Step 1
        RA(i) = Ensemble.StructInfo(i - Offs)
    Next i
    Offs = Offs + SSize
    i1_ = (0#) - (Offs)
    For i_ = Offs To Offs + Ensemble.EnsembleSize * Ensemble.WCount - 1# Step 1
        RA(i_) = Ensemble.Weights(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.EnsembleSize * Ensemble.WCount
    i1_ = (0#) - (Offs)
    For i_ = Offs To Offs + Ensemble.EnsembleSize * CCount - 1# Step 1
        RA(i_) = Ensemble.ColumnMeans(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.EnsembleSize * CCount
    i1_ = (0#) - (Offs)
    For i_ = Offs To Offs + Ensemble.EnsembleSize * CCount - 1# Step 1
        RA(i_) = Ensemble.ColumnSigmas(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.EnsembleSize * CCount
    i1_ = (0#) - (Offs)
    For i_ = Offs To Offs + Ensemble.SerializedLen - 1# Step 1
        RA(i_) = Ensemble.SerializedMLP(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.SerializedLen
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unserialization of MLPEnsemble strucure
'
'INPUT PARAMETERS:
'    RA      -   real array which stores ensemble
'
'OUTPUT PARAMETERS:
'    Ensemble-   restored structure
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPEUnserialize(ByRef RA() As Double, ByRef Ensemble As MLPEnsemble)
    Dim i As Long
    Dim SSize As Long
    Dim NTotal As Long
    Dim CCount As Long
    Dim HSize As Long
    Dim Offs As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' load info
    '
    HSize = 13#
    Ensemble.EnsembleSize = Round(RA(2#))
    Ensemble.NIn = Round(RA(3#))
    Ensemble.NOut = Round(RA(4#))
    Ensemble.WCount = Round(RA(5#))
    Ensemble.IsSoftmax = Round(RA(6#)) = 1#
    Ensemble.PostProcessing = Round(RA(7#)) = 1#
    SSize = Round(RA(8#))
    NTotal = Round(RA(9#))
    CCount = Round(RA(10#))
    Offs = Round(RA(11#))
    Ensemble.SerializedLen = Round(RA(12#))
    
    '
    '  Allocate arrays
    '
    ReDim Ensemble.StructInfo(0# To SSize - 1#)
    ReDim Ensemble.Weights(0# To Ensemble.EnsembleSize * Ensemble.WCount - 1#)
    ReDim Ensemble.ColumnMeans(0# To Ensemble.EnsembleSize * CCount - 1#)
    ReDim Ensemble.ColumnSigmas(0# To Ensemble.EnsembleSize * CCount - 1#)
    ReDim Ensemble.TmpWeights(0# To Ensemble.WCount - 1#)
    ReDim Ensemble.TmpMeans(0# To CCount - 1#)
    ReDim Ensemble.TmpSigmas(0# To CCount - 1#)
    ReDim Ensemble.Neurons(0# To NTotal - 1#)
    ReDim Ensemble.DFDNET(0# To NTotal - 1#)
    ReDim Ensemble.SerializedMLP(0# To Ensemble.SerializedLen - 1#)
    ReDim Ensemble.Y(0# To Ensemble.NOut - 1#)
    
    '
    ' load data
    '
    For i = Offs To Offs + SSize - 1# Step 1
        Ensemble.StructInfo(i - Offs) = Round(RA(i))
    Next i
    Offs = Offs + SSize
    i1_ = (Offs) - (0#)
    For i_ = 0# To Ensemble.EnsembleSize * Ensemble.WCount - 1# Step 1
        Ensemble.Weights(i_) = RA(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.EnsembleSize * Ensemble.WCount
    i1_ = (Offs) - (0#)
    For i_ = 0# To Ensemble.EnsembleSize * CCount - 1# Step 1
        Ensemble.ColumnMeans(i_) = RA(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.EnsembleSize * CCount
    i1_ = (Offs) - (0#)
    For i_ = 0# To Ensemble.EnsembleSize * CCount - 1# Step 1
        Ensemble.ColumnSigmas(i_) = RA(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.EnsembleSize * CCount
    i1_ = (Offs) - (0#)
    For i_ = 0# To Ensemble.SerializedLen - 1# Step 1
        Ensemble.SerializedMLP(i_) = RA(i_ + i1_)
    Next i_
    Offs = Offs + Ensemble.SerializedLen
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Randomization of MLP ensemble
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPERandomize(ByRef Ensemble As MLPEnsemble)
    Dim i As Long
    For i = 0# To Ensemble.EnsembleSize * Ensemble.WCount - 1# Step 1
        Ensemble.Weights(i) = Rnd() - 0.5
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Return ensemble properties (number of inputs and outputs).
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPEProperties(ByRef Ensemble As MLPEnsemble, _
         ByRef NIn As Long, _
         ByRef NOut As Long)
    NIn = Ensemble.NIn
    NOut = Ensemble.NOut
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Return normalization type (whether ensemble is SOFTMAX-normalized or not).
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MLPEIsSoftmax(ByRef Ensemble As MLPEnsemble) As Boolean
    Dim Result As Boolean
    Result = Ensemble.IsSoftmax
    MLPEIsSoftmax = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Procesing
'
'INPUT PARAMETERS:
'    Ensemble-   neural networks ensemble
'    X       -   input vector,  array[0..NIn-1].
'
'OUTPUT PARAMETERS:
'    Y       -   result. Regression estimate when solving regression  task,
'                vector of posterior probabilities for classification task.
'                Subroutine does not allocate memory for this vector, it is
'                responsibility of a caller to allocate it. Array  must  be
'                at least [0..NOut-1].
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPEProcess(ByRef Ensemble As MLPEnsemble, _
         ByRef X() As Double, _
         ByRef Y() As Double)
    Dim i As Long
    Dim ES As Long
    Dim WC As Long
    Dim CC As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    ES = Ensemble.EnsembleSize
    WC = Ensemble.WCount
    If Ensemble.IsSoftmax Then
        CC = Ensemble.NIn
    Else
        CC = Ensemble.NIn + Ensemble.NOut
    End If
    V = 1# / ES
    For i = 0# To Ensemble.NOut - 1# Step 1
        Y(i) = 0#
    Next i
    For i = 0# To ES - 1# Step 1
        i1_ = (i * WC) - (0#)
        For i_ = 0# To WC - 1# Step 1
            Ensemble.TmpWeights(i_) = Ensemble.Weights(i_ + i1_)
        Next i_
        i1_ = (i * CC) - (0#)
        For i_ = 0# To CC - 1# Step 1
            Ensemble.TmpMeans(i_) = Ensemble.ColumnMeans(i_ + i1_)
        Next i_
        i1_ = (i * CC) - (0#)
        For i_ = 0# To CC - 1# Step 1
            Ensemble.TmpSigmas(i_) = Ensemble.ColumnSigmas(i_ + i1_)
        Next i_
        Call MLPInternalProcessVector(Ensemble.StructInfo, Ensemble.TmpWeights, Ensemble.TmpMeans, Ensemble.TmpSigmas, Ensemble.Neurons, Ensemble.DFDNET, X, Ensemble.Y)
        For i_ = 0# To Ensemble.NOut - 1# Step 1
            Y(i_) = Y(i_) + V * Ensemble.Y(i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Relative classification error on the test set
'
'INPUT PARAMETERS:
'    Ensemble-   ensemble
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    percent of incorrectly classified cases.
'    Works both for classifier betwork and for regression networks which
'are used as classifiers.
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MLPERelClsError(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MLPEAllErrors(Ensemble, XY, NPoints, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = RelCls
    MLPERelClsError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Average cross-entropy (in bits per element) on the test set
'
'INPUT PARAMETERS:
'    Ensemble-   ensemble
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    CrossEntropy/(NPoints*LN(2)).
'    Zero if ensemble solves regression task.
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MLPEAvgCE(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MLPEAllErrors(Ensemble, XY, NPoints, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = AvgCE
    MLPEAvgCE = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'RMS error on the test set
'
'INPUT PARAMETERS:
'    Ensemble-   ensemble
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    root mean square error.
'    Its meaning for regression task is obvious. As for classification task
'RMS error means error when estimating posterior probabilities.
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MLPERMSError(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MLPEAllErrors(Ensemble, XY, NPoints, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = RMS
    MLPERMSError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Average error on the test set
'
'INPUT PARAMETERS:
'    Ensemble-   ensemble
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    Its meaning for regression task is obvious. As for classification task
'it means average error when estimating posterior probabilities.
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MLPEAvgError(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MLPEAllErrors(Ensemble, XY, NPoints, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = Avg
    MLPEAvgError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Average relative error on the test set
'
'INPUT PARAMETERS:
'    Ensemble-   ensemble
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    Its meaning for regression task is obvious. As for classification task
'it means average relative error when estimating posterior probabilities.
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MLPEAvgRelError(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MLPEAllErrors(Ensemble, XY, NPoints, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = AvgRel
    MLPEAvgRelError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Training neural networks ensemble using  bootstrap  aggregating (bagging).
'Modified Levenberg-Marquardt algorithm is used as base training method.
'
'INPUT PARAMETERS:
'    Ensemble    -   model with initialized geometry
'    XY          -   training set
'    NPoints     -   training set size
'    Decay       -   weight decay coefficient, >=0.001
'    Restarts    -   restarts, >0.
'
'OUTPUT PARAMETERS:
'    Ensemble    -   trained model
'    Info        -   return code:
'                    * -2, if there is a point with class number
'                          outside of [0..NClasses-1].
'                    * -1, if incorrect parameters was passed
'                          (NPoints<0, Restarts<1).
'                    *  2, if task has been solved.
'    Rep         -   training report.
'    OOBErrors   -   out-of-bag generalization error estimate
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPEBaggingLM(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long, _
         ByVal Decay As Double, _
         ByVal Restarts As Long, _
         ByRef Info As Long, _
         ByRef Rep As MLPReport, _
         ByRef OOBErrors As MLPCVReport)
    Call MLPEBaggingInternal(Ensemble, XY, NPoints, Decay, Restarts, 0#, 0#, True, Info, Rep, OOBErrors)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Training neural networks ensemble using  bootstrap  aggregating (bagging).
'L-BFGS algorithm is used as base training method.
'
'INPUT PARAMETERS:
'    Ensemble    -   model with initialized geometry
'    XY          -   training set
'    NPoints     -   training set size
'    Decay       -   weight decay coefficient, >=0.001
'    Restarts    -   restarts, >0.
'    WStep       -   stopping criterion, same as in MLPTrainLBFGS
'    MaxIts      -   stopping criterion, same as in MLPTrainLBFGS
'
'OUTPUT PARAMETERS:
'    Ensemble    -   trained model
'    Info        -   return code:
'                    * -8, if both WStep=0 and MaxIts=0
'                    * -2, if there is a point with class number
'                          outside of [0..NClasses-1].
'                    * -1, if incorrect parameters was passed
'                          (NPoints<0, Restarts<1).
'                    *  2, if task has been solved.
'    Rep         -   training report.
'    OOBErrors   -   out-of-bag generalization error estimate
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPEBaggingLBFGS(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long, _
         ByVal Decay As Double, _
         ByVal Restarts As Long, _
         ByVal WStep As Double, _
         ByVal MaxIts As Long, _
         ByRef Info As Long, _
         ByRef Rep As MLPReport, _
         ByRef OOBErrors As MLPCVReport)
    Call MLPEBaggingInternal(Ensemble, XY, NPoints, Decay, Restarts, WStep, MaxIts, False, Info, Rep, OOBErrors)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Training neural networks ensemble using early stopping.
'
'INPUT PARAMETERS:
'    Ensemble    -   model with initialized geometry
'    XY          -   training set
'    NPoints     -   training set size
'    Decay       -   weight decay coefficient, >=0.001
'    Restarts    -   restarts, >0.
'
'OUTPUT PARAMETERS:
'    Ensemble    -   trained model
'    Info        -   return code:
'                    * -2, if there is a point with class number
'                          outside of [0..NClasses-1].
'                    * -1, if incorrect parameters was passed
'                          (NPoints<0, Restarts<1).
'                    *  6, if task has been solved.
'    Rep         -   training report.
'    OOBErrors   -   out-of-bag generalization error estimate
'
'  -- ALGLIB --
'     Copyright 10.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MLPETrainES(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long, _
         ByVal Decay As Double, _
         ByVal Restarts As Long, _
         ByRef Info As Long, _
         ByRef Rep As MLPReport)
    Dim i As Long
    Dim K As Long
    Dim CCount As Long
    Dim PCount As Long
    Dim TrnXY() As Double
    Dim ValXY() As Double
    Dim TrnSize As Long
    Dim ValSize As Long
    Dim Network As MultiLayerPerceptron
    Dim TmpInfo As Long
    Dim TmpRep As MLPReport
    Dim i_ As Long
    Dim i1_ As Long
    If NPoints < 2# Or Restarts < 1# Or Decay < 0# Then
        Info = -1#
        Exit Sub
    End If
    If Ensemble.IsSoftmax Then
        For i = 0# To NPoints - 1# Step 1
            If Round(XY(i, Ensemble.NIn)) < 0# Or Round(XY(i, Ensemble.NIn)) >= Ensemble.NOut Then
                Info = -2#
                Exit Sub
            End If
        Next i
    End If
    Info = 6#
    
    '
    ' allocate
    '
    If Ensemble.IsSoftmax Then
        CCount = Ensemble.NIn + 1#
        PCount = Ensemble.NIn
    Else
        CCount = Ensemble.NIn + Ensemble.NOut
        PCount = Ensemble.NIn + Ensemble.NOut
    End If
    ReDim TrnXY(0# To NPoints - 1#, 0# To CCount - 1#)
    ReDim ValXY(0# To NPoints - 1#, 0# To CCount - 1#)
    Call MLPUnserialize(Ensemble.SerializedMLP, Network)
    Rep.NGrad = 0#
    Rep.NHess = 0#
    Rep.NCholesky = 0#
    
    '
    ' train networks
    '
    For K = 0# To Ensemble.EnsembleSize - 1# Step 1
        
        '
        ' Split set
        '
        Do
            TrnSize = 0#
            ValSize = 0#
            For i = 0# To NPoints - 1# Step 1
                If Rnd() < 0.66 Then
                    
                    '
                    ' Assign sample to training set
                    '
                    For i_ = 0# To CCount - 1# Step 1
                        TrnXY(TrnSize, i_) = XY(i, i_)
                    Next i_
                    TrnSize = TrnSize + 1#
                Else
                    
                    '
                    ' Assign sample to validation set
                    '
                    For i_ = 0# To CCount - 1# Step 1
                        ValXY(ValSize, i_) = XY(i, i_)
                    Next i_
                    ValSize = ValSize + 1#
                End If
            Next i
        Loop Until TrnSize <> 0# And ValSize <> 0#
        
        '
        ' Train
        '
        Call MLPTrainES(Network, TrnXY, TrnSize, ValXY, ValSize, Decay, Restarts, TmpInfo, TmpRep)
        If TmpInfo < 0# Then
            Info = TmpInfo
            Exit Sub
        End If
        
        '
        ' save results
        '
        i1_ = (0#) - (K * Ensemble.WCount)
        For i_ = K * Ensemble.WCount To (K + 1#) * Ensemble.WCount - 1# Step 1
            Ensemble.Weights(i_) = Network.Weights(i_ + i1_)
        Next i_
        i1_ = (0#) - (K * PCount)
        For i_ = K * PCount To (K + 1#) * PCount - 1# Step 1
            Ensemble.ColumnMeans(i_) = Network.ColumnMeans(i_ + i1_)
        Next i_
        i1_ = (0#) - (K * PCount)
        For i_ = K * PCount To (K + 1#) * PCount - 1# Step 1
            Ensemble.ColumnSigmas(i_) = Network.ColumnSigmas(i_ + i1_)
        Next i_
        Rep.NGrad = Rep.NGrad + TmpRep.NGrad
        Rep.NHess = Rep.NHess + TmpRep.NHess
        Rep.NCholesky = Rep.NCholesky + TmpRep.NCholesky
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of all types of errors
'
'  -- ALGLIB --
'     Copyright 17.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub MLPEAllErrors(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long, _
         ByRef RelCls As Double, _
         ByRef AvgCE As Double, _
         ByRef RMS As Double, _
         ByRef Avg As Double, _
         ByRef AvgRel As Double)
    Dim i As Long
    Dim Buf() As Double
    Dim WorkX() As Double
    Dim Y() As Double
    Dim DY() As Double
    Dim i_ As Long
    Dim i1_ As Long
    ReDim WorkX(0# To Ensemble.NIn - 1#)
    ReDim Y(0# To Ensemble.NOut - 1#)
    If Ensemble.IsSoftmax Then
        ReDim DY(0# To 0#)
        Call DSErrAllocate(Ensemble.NOut, Buf)
    Else
        ReDim DY(0# To Ensemble.NOut - 1#)
        Call DSErrAllocate(-Ensemble.NOut, Buf)
    End If
    For i = 0# To NPoints - 1# Step 1
        For i_ = 0# To Ensemble.NIn - 1# Step 1
            WorkX(i_) = XY(i, i_)
        Next i_
        Call MLPEProcess(Ensemble, WorkX, Y)
        If Ensemble.IsSoftmax Then
            DY(0#) = XY(i, Ensemble.NIn)
        Else
            i1_ = (Ensemble.NIn) - (0#)
            For i_ = 0# To Ensemble.NOut - 1# Step 1
                DY(i_) = XY(i, i_ + i1_)
            Next i_
        End If
        Call DSErrAccumulate(Buf, Y, DY)
    Next i
    Call DSErrFinish(Buf)
    RelCls = Buf(0#)
    AvgCE = Buf(1#)
    RMS = Buf(2#)
    Avg = Buf(3#)
    AvgRel = Buf(4#)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal bagging subroutine.
'
'  -- ALGLIB --
'     Copyright 19.02.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub MLPEBaggingInternal(ByRef Ensemble As MLPEnsemble, _
         ByRef XY() As Double, _
         ByVal NPoints As Long, _
         ByVal Decay As Double, _
         ByVal Restarts As Long, _
         ByVal WStep As Double, _
         ByVal MaxIts As Long, _
         ByVal LMAlgorithm As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MLPReport, _
         ByRef OOBErrors As MLPCVReport)
    Dim XYS() As Double
    Dim S() As Boolean
    Dim OOBBuf() As Double
    Dim OOBCntBuf() As Long
    Dim X() As Double
    Dim Y() As Double
    Dim DY() As Double
    Dim DSBuf() As Double
    Dim NIn As Long
    Dim NOut As Long
    Dim CCnt As Long
    Dim PCnt As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Dim TmpRep As MLPReport
    Dim Network As MultiLayerPerceptron
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Test for inputs
    '
    If Not LMAlgorithm And WStep = 0# And MaxIts = 0# Then
        Info = -8#
        Exit Sub
    End If
    If NPoints <= 0# Or Restarts < 1# Or WStep < 0# Or MaxIts < 0# Then
        Info = -1#
        Exit Sub
    End If
    If Ensemble.IsSoftmax Then
        For i = 0# To NPoints - 1# Step 1
            If Round(XY(i, Ensemble.NIn)) < 0# Or Round(XY(i, Ensemble.NIn)) >= Ensemble.NOut Then
                Info = -2#
                Exit Sub
            End If
        Next i
    End If
    
    '
    ' allocate temporaries
    '
    Info = 2#
    Rep.NGrad = 0#
    Rep.NHess = 0#
    Rep.NCholesky = 0#
    OOBErrors.RelCLSError = 0#
    OOBErrors.AvgCE = 0#
    OOBErrors.RMSError = 0#
    OOBErrors.AvgError = 0#
    OOBErrors.AvgRelError = 0#
    NIn = Ensemble.NIn
    NOut = Ensemble.NOut
    If Ensemble.IsSoftmax Then
        CCnt = NIn + 1#
        PCnt = NIn
    Else
        CCnt = NIn + NOut
        PCnt = NIn + NOut
    End If
    ReDim XYS(0# To NPoints - 1#, 0# To CCnt - 1#)
    ReDim S(0# To NPoints - 1#)
    ReDim OOBBuf(0# To NPoints - 1#, 0# To NOut - 1#)
    ReDim OOBCntBuf(0# To NPoints - 1#)
    ReDim X(0# To NIn - 1#)
    ReDim Y(0# To NOut - 1#)
    If Ensemble.IsSoftmax Then
        ReDim DY(0# To 0#)
    Else
        ReDim DY(0# To NOut - 1#)
    End If
    For i = 0# To NPoints - 1# Step 1
        For J = 0# To NOut - 1# Step 1
            OOBBuf(i, J) = 0#
        Next J
    Next i
    For i = 0# To NPoints - 1# Step 1
        OOBCntBuf(i) = 0#
    Next i
    Call MLPUnserialize(Ensemble.SerializedMLP, Network)
    
    '
    ' main bagging cycle
    '
    For K = 0# To Ensemble.EnsembleSize - 1# Step 1
        
        '
        ' prepare dataset
        '
        For i = 0# To NPoints - 1# Step 1
            S(i) = False
        Next i
        For i = 0# To NPoints - 1# Step 1
            J = RandomInteger(NPoints)
            S(J) = True
            For i_ = 0# To CCnt - 1# Step 1
                XYS(i, i_) = XY(J, i_)
            Next i_
        Next i
        
        '
        ' train
        '
        If LMAlgorithm Then
            Call MLPTrainLM(Network, XYS, NPoints, Decay, Restarts, Info, TmpRep)
        Else
            Call MLPTrainLBFGS(Network, XYS, NPoints, Decay, Restarts, WStep, MaxIts, Info, TmpRep)
        End If
        If Info < 0# Then
            Exit Sub
        End If
        
        '
        ' save results
        '
        Rep.NGrad = Rep.NGrad + TmpRep.NGrad
        Rep.NHess = Rep.NHess + TmpRep.NHess
        Rep.NCholesky = Rep.NCholesky + TmpRep.NCholesky
        i1_ = (0#) - (K * Ensemble.WCount)
        For i_ = K * Ensemble.WCount To (K + 1#) * Ensemble.WCount - 1# Step 1
            Ensemble.Weights(i_) = Network.Weights(i_ + i1_)
        Next i_
        i1_ = (0#) - (K * PCnt)
        For i_ = K * PCnt To (K + 1#) * PCnt - 1# Step 1
            Ensemble.ColumnMeans(i_) = Network.ColumnMeans(i_ + i1_)
        Next i_
        i1_ = (0#) - (K * PCnt)
        For i_ = K * PCnt To (K + 1#) * PCnt - 1# Step 1
            Ensemble.ColumnSigmas(i_) = Network.ColumnSigmas(i_ + i1_)
        Next i_
        
        '
        ' OOB estimates
        '
        For i = 0# To NPoints - 1# Step 1
            If Not S(i) Then
                For i_ = 0# To NIn - 1# Step 1
                    X(i_) = XY(i, i_)
                Next i_
                Call MLPProcess(Network, X, Y)
                For i_ = 0# To NOut - 1# Step 1
                    OOBBuf(i, i_) = OOBBuf(i, i_) + Y(i_)
                Next i_
                OOBCntBuf(i) = OOBCntBuf(i) + 1#
            End If
        Next i
    Next K
    
    '
    ' OOB estimates
    '
    If Ensemble.IsSoftmax Then
        Call DSErrAllocate(NOut, DSBuf)
    Else
        Call DSErrAllocate(-NOut, DSBuf)
    End If
    For i = 0# To NPoints - 1# Step 1
        If OOBCntBuf(i) <> 0# Then
            V = 1# / OOBCntBuf(i)
            For i_ = 0# To NOut - 1# Step 1
                Y(i_) = V * OOBBuf(i, i_)
            Next i_
            If Ensemble.IsSoftmax Then
                DY(0#) = XY(i, NIn)
            Else
                i1_ = (NIn) - (0#)
                For i_ = 0# To NOut - 1# Step 1
                    DY(i_) = V * XY(i, i_ + i1_)
                Next i_
            End If
            Call DSErrAccumulate(DSBuf, Y, DY)
        End If
    Next i
    Call DSErrFinish(DSBuf)
    OOBErrors.RelCLSError = DSBuf(0#)
    OOBErrors.AvgCE = DSBuf(1#)
    OOBErrors.RMSError = DSBuf(2#)
    OOBErrors.AvgError = DSBuf(3#)
    OOBErrors.AvgRelError = DSBuf(4#)
End Sub
