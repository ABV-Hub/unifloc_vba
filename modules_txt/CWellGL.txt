'=======================================================================================
'Unifloc 7.12  Apodemus agrarius                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' класс для расчета свойств скважины c газлифтом - распределение давления и температуры в скважине
Option Explicit
Option Base 0
Implements IWell
' ============ general well objects ===========
' штуцер установленный на поверхности
' choke always exist in well (but can have diam = 0 means - no influence on flow)
Private choke_ As New Cchoke
' input fluid object
Private fluid_ As New CPVT                  ' флюид из пласта
Public trajectory As New CTrajectory         ' полная траектория скважины с инклинометрии (основной способ задания скважины)
' abbient formation object needed for full temperature calculation
' must be accessed through property - in order to pass it to pipes properly
Private ambient_formation_ As New CAmbientFormation
Private PT_buf_ As PTtype
Private PT_lin_ As PTtype
'Private PT_cas_ As PTtype
Private PT_wf_ As PTtype
' temperature params
' температура задается отдельно, поэтому для удобства прямые параметры для работы с температурной моделью скважины заданы
Private t_wh_C_ As Double
Private t_surf_C_ As Double
Private t_bh_C_ As Double
Private t_valve_C_ As Double
Private tres_C_ As Double
Private param_ As PARAMCALC                 ' параметры расчета по трубе
 ' поправочные коэффициенты для расчета распределения давления
Private c_calibr_grav_ As Double
Private c_calibr_fric_ As Double
Public curve As New CCurves ' коллекция кривых с результатами расчетов
Public Event ReportProgress(msg As String)
' ============Gas Lift well objects =======================================
'  класс для описания работы газлифтной скважины
'  предполагается, что есть пакер отделяющий затруб и газлифтные клапана
Public isCalcCasing As Boolean
Private PipesProd As New Collection      ' коллеция труб по которым идет добыча из которых состоит скважина
Private PipesInj As New Collection       '  коллекция труб по которым идет закачка газа
Public valves As New CGLValveSet         ' коллекция клапанов установленных в скважине
Private fluid_cas_ As New CPVT
' it is assumed - one fluid in tubing - other in casing
' in gasing gas - with additional amount of gas in flow
Private q_gas_inj_scm3day_ As Double          '
Private PT_gas_inj_ As PTtype
' ============ constructor ====================
Private Sub Class_Initialize()
    With param_
        .correlation = Ansari
        .FlowDirection = FlowAgainstCoord
        .temp_method = AmbientTemp
    End With
    PT_gas_inj_.t_C = 30
    c_calibr_grav_ = 1
    c_calibr_fric_ = 1
    isCalcCasing = True
End Sub
'------------------------------------------------------------
' choke general  properties
'------------------------------------------------------------
Property Get choke() As Cchoke
   Set choke = choke_
End Property
Public Sub set_choke(dchoke_mm, Optional dtub_mm = 62)
' установка параметров штуцера
   choke_.d_choke_m = dchoke_mm / 1000
   choke_.d_down_m = dtub_mm / 1000
   choke_.d_up_m = dtub_mm / 1000
End Sub
 
Public Sub clearChoke()
   choke_.d_choke_m = 0
End Sub
Private Function is_choke() As Boolean
   is_choke = choke_.d_choke_m > 0
End Function
'------------------------------------------------------------
' fluid general properties
'------------------------------------------------------------
Public Property Get fluid() As CPVT
    Set fluid = fluid_
End Property
Public Property Get fluid_tub() As CPVT
    Set fluid_tub = fluid_
End Property
Public Property Get fluid_cas() As CPVT
    Set fluid_cas = fluid_cas_
End Property
Public Property Set fluid(val As CPVT)
    Dim pipe As CPipe
    ' set main tubing fluid here
    Set fluid_ = val
    ' set clone fluid object in casing
    Set fluid_cas_ = val.clone
    
    For Each pipe In PipesProd
        Set pipe.fluid = fluid_
    Next pipe
    For Each pipe In PipesInj
        Set pipe.fluid = fluid_cas_
    Next pipe
    
    Set choke.fluid = fluid_
    Set valves.fluid = fluid_
End Property
' ---------------------------------------------------------------
' flow correlations tuning methods
' ---------------------------------------------------------------
Public Property Get c_calibr_grav() As Double
   c_calibr_grav = c_calibr_grav_
End Property
Public Property Get c_calibr_fric() As Double
   c_calibr_fric = c_calibr_fric_
End Property
Public Property Let c_calibr_grav(val As Double)
   Dim pipe As CPipe
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
        For Each pipe In PipesProd
            pipe.c_calibr_grav = val
        Next pipe
        For Each pipe In PipesInj
            pipe.c_calibr_grav = val
        Next pipe
        c_calibr_grav_ = val
        If val <> 1 Then addLogMsg_debug "CWellGL.c_calibr_grav = " & str(val) & " warning. correction to multiphase flow correlation active!"
   Else
        addLogMsg_debug "CWellGL.c_calibr_grav: value " & str(val) & " not set. Out of range"
   End If
End Property
 
Public Property Let c_calibr_fric(val As Double)
   Dim pipe As CPipe
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
        For Each pipe In PipesProd
            pipe.c_calibr_fric = val
        Next pipe
        For Each pipe In PipesInj
            pipe.c_calibr_fric = val
        Next pipe
        c_calibr_fric_ = val
        If val <> 1 Then addLogMsg_debug "CWellGL.c_calibr_fric = " & str(val) & " warning. correction to multiphase flow correlation friction active!"
   Else
        addLogMsg_debug "CWellGL.c_calibr_fric: value " & str(val) & " not set. Out of range"
   End If
End Property
 
Public Property Get hydraulic_correlation() As H_CORRELATION
    hydraulic_correlation = param.correlation
End Property
Public Property Let hydraulic_correlation(val As H_CORRELATION)
    Dim prm As PARAMCALC
    prm = param
    prm.correlation = val
    param = prm
End Property
 
Public Property Get temp_correlation() As TEMP_CALC_METHOD
    temp_correlation = param.temp_method
End Property
 
Public Property Let temp_correlation(val As TEMP_CALC_METHOD)
    Dim prm As PARAMCALC
    prm = param
    prm.temp_method = val
    param = prm
End Property
 
Public Property Get param() As PARAMCALC
    param = param_
End Property
Public Property Let param(val As PARAMCALC)
    param_ = val
    Dim pipe As CPipe
    
    For Each pipe In PipesProd
        pipe.param = val
    Next pipe
    For Each pipe In PipesInj
        pipe.param = val
    Next pipe
End Property
 
'------------------------------------------------------------
' temperature general properties
'------------------------------------------------------------
Public Property Get t_line_C() As Double
    t_line_C = PT_lin_.t_C
End Property
Public Property Get t_buf_C() As Double
    t_buf_C = PT_buf_.t_C
End Property
 
Public Property Get t_bh_C() As Double
    t_bh_C = PT_wf_.t_C
End Property
 
Public Property Get t_wh_C() As Double
    t_wh_C = PT_buf_.t_C
End Property
Public Property Get t_surf_C() As Double
    On Error Resume Next
    t_surf_C = PT_buf_.t_C
    t_surf_C = ambient_formation.amb_temp_C(0)
End Property
Public Property Get ambient_formation() As CAmbientFormation
    Set ambient_formation = ambient_formation_
End Property
Public Property Set ambient_formation(ByVal vNewValue As CAmbientFormation)
    Dim pipe As CPipe
    Set ambient_formation_ = vNewValue
    For Each pipe In PipesProd
        Set pipe.ambient_formation = ambient_formation_
    Next pipe
    For Each pipe In PipesInj
        Set pipe.ambient_formation = ambient_formation_
    Next pipe
    
    Call init_well_temperature
End Property
'------------------------------------------------------------
' pressure general properties
'------------------------------------------------------------
Public Property Get p_line_atma() As Double
   p_line_atma = PT_lin_.p_atma
End Property
Public Property Get pbuf_atma() As Double
' buffer pressure
   pbuf_atma = PT_buf_.p_atma
End Property
Public Property Get pwf_atma() As Double
' давление на забое
   pwf_atma = PT_wf_.p_atma
End Property
'Public Property Get p_an_atma() As Double
'' annulus presure
'   p_an_atma = PT_gas_inj_.p_atma
'End Property
Public Property Get pcas_atma() As Double
    pcas_atma = PT_gas_inj_.p_atma
End Property
'------------------------------------------------------------
' well rates general properties
'------------------------------------------------------------
Property Let qliq_sm3day(Qval_scm3day As Double)
   fluid.qliq_sm3day = Qval_scm3day
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid
 '  p_Calculated = False
End Property
' дебит жидкости из скважины в поверхностных условиях
Public Property Get qliq_sm3day() As Double
   qliq_sm3day = fluid_.qliq_sm3day
End Property
Public Property Get w_kgsec() As Double
'    массовый расход продукции рассчитаем
   w_kgsec = fluid_.wm_kgsec
End Property
Public Property Get q_oil_sm3day() As Double
   q_oil_sm3day = fluid_.q_oil_sm3day
End Property
Public Property Get q_oil_sctday() As Double
   q_oil_sctday = qliq_sm3day * (1 - fluid_.fw_fr) * fluid_.gamma_o
End Property
Public Property Get q_wat_sm3day() As Double
   q_wat_sm3day = qliq_sm3day * fluid_.fw_fr
End Property
Public Property Get q_gas_scm3day() As Double
   q_gas_scm3day = fluid_.q_gas_sm3day
End Property
Property Get fw_perc() As Double
    fw_perc = fluid_.fw_perc
End Property
Property Let fw_perc(wcval As Double)
   Dim Wc As Double
   Wc = wcval / 100
   fluid.fw_fr = Wc
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid_
End Property
Property Let rp_m3m3(Rpval As Double)
   fluid.rp_m3m3 = Rpval
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid_
End Property
' ---------------------------------------------------------------
' service function
' ---------------------------------------------------------------
   
 Public Function clone() As CWellGL
    Dim wl As New CWellGL
    Dim i As Integer
    Set wl.trajectory = trajectory   ' это должно сработать вместо инициализации
    Call wl.choke.Copy(choke)
    Set wl.fluid = fluid.clone
    
    Set clone = wl
 End Function
    
 
 
' =======================================
' методы инициализации скважины
' =======================================
Public Sub init_well_construction(ByVal h_perf_m As Double, _
                                ByVal htub_m As Double, _
                        Optional ByVal d_cas_mm As Double = 125, _
                        Optional ByVal dtub_mm As Double = 72, _
                        Optional ByVal udl_m As Double = 0, _
                        Optional ByVal hmes_incl_range_m_ = -1, _
                        Optional ByVal hvert_incl_range_m_ = -1, _
                        Optional ByVal hmes_dcas_range_m_ = -1, _
                        Optional ByVal dcas_range_mm_ = -1, _
                        Optional ByVal hmes_dtub_range_m_ = -1, _
                        Optional ByVal dtub_range_mm_ = -1)
    ' универсальный метод инициализации скважины - должен использоваться для инициализации скважины
    ' поддерживает три варианта инициалиции
    '       - с упрощенным набором данных с удлинением (загрузка из тех режима)
    '       - с заданием инклинометрии через range и упрощенным набором труб (диаметры)
    '       - с заданием инклинометрии и диаметров с использованием range
    '
    ' параметры обязательные для всех вариантов задания
    ' h_perf_m               - глубина перфорации измеренная, м. Используется для расчета забойного давления
    ' htub_m                - глубина спуска НКТ измеренная, м. Соответствует глубине спуска насоса
    '
    ' параметры упрощенного режима задания
    ' d_cas_mm               - внутренний диамет эксплуатационной колонны, мм
    ' dtub_mm               - внешний диамет НКТ, мм (толщина стенки 10 мм)
    ' udl_m                 - удлинение на глубину перфорации, м (разница между измеренной и вертикальной глубиной)
    '
    ' параметры детального задания скважины  (все - вертикальные range)
    ' hmes_incl_range_m_    - измеренная глубина скважины для задания инклинометрии
    ' hvert_incl_range_m_   - вертикальная глубина скважины для задания инклинометрии
    '                       - если инклинометрии как range задана, то удлинение игнорируется
    '
    ' hmes_dcas_range_m_    - измеренная глубина для задания диаметра эксплуатационной колонны (начинается с 0)
    ' dcas_range_mm_        - диаметр эксплуатационной колонны на соответствующей глубине (действует от глубины и вниз до след изменения)
    ' hmes_dtub_range_m_    - измеренная глубина для задания диаметра НКТ
    ' dtub_range_mm_        - диаметр НКТ внешний на соответствующей глубине (действует от глубины и вниз до след изменения)
    '                       - для полного задания скважины все range должны быть заданы
    
    
    
    Dim simpleNumbers As Boolean
    Dim fullRange As Boolean
    Dim inclRange As Boolean
    Dim fullArray As Boolean
    
    simpleNumbers = IsNumeric(hmes_incl_range_m_)
    inclRange = IsObject(hmes_incl_range_m_) And IsObject(hvert_incl_range_m_)
    fullRange = inclRange And IsObject(hmes_dcas_range_m_) And IsObject(dcas_range_mm_) And _
                              IsObject(hmes_dtub_range_m_) And IsObject(dtub_range_mm_)
    
    If simpleNumbers Then
    ' use simple numbers here
        Call FillWellConstructionSimple(h_perf_m, htub_m, udl_m, d_cas_mm, dtub_mm)
    ElseIf fullRange Then
        Call FillWellConstructionRangeAll(hmes_incl_range_m_, hvert_incl_range_m_, hmes_dcas_range_m_, _
                              dcas_range_mm_, hmes_dtub_range_m_, dtub_range_mm_, _
                              h_perf_m, htub_m)
'    ElseIf inclRange Then
'        Call FillWellConstructionRange(hmes_incl_range_m_, hvert_incl_range_m_, h_perf_m, htub_m, d_cas_mm, dtub_mm)
    End If
    
End Sub
Public Sub init_well_temperature(Optional ByVal t_bh_C As Double = -1, _
                               Optional ByVal t_wh_C As Double = -1, _
                               Optional ByVal hmes_tamb_arr_m_ = -1, _
                               Optional ByVal tamb_arr_C_ = -1)
   ' основная функция инициализации температуры в скважине
   ' задает по исходным данным объект ambient_formation, который определяет параметры температуры в скважине
   '
   ' если никакие параметры не заданы, скважине переинициализируется используя уже заданный объект ambient_formation_
   '
   ' t_bh_C              - температура на забое скважины
   ' t_wh_C              - температура на устье скважины
   ' hmes_tamb_arr_m_   - массив (range) измеренных глубин для задания распределения температуры по глубине
   ' tamb_arr_C_        - значения температуры по глубине
   
   
    Dim simpleNumbers As Boolean
    Dim ambRange As Boolean
    Dim newTempValues As Boolean
    
    Dim geoGrad As New CInterpolation
    Dim ambTemp As New CAmbientFormation
    Dim RangX As Range, RangY As Range
On Error GoTo err1:
    simpleNumbers = IsNumeric(hmes_tamb_arr_m_)
    ambRange = IsObject(hmes_tamb_arr_m_) And IsObject(tamb_arr_C_)
    newTempValues = ((t_bh_C > 20) And (t_wh_C > 0)) Or ambRange
    
    If newTempValues Then
        If simpleNumbers Then
            geoGrad.AddPoint 0, t_wh_C
            geoGrad.AddPoint trajectory.h_perf_vert_m, t_bh_C
        ElseIf ambRange Then
            Set RangX = hmes_tamb_arr_m_
            Set RangY = tamb_arr_C_
            Call geoGrad.loadFromVertRange(RangX, RangY)
        End If
        Set ambTemp.amb_temp_curve = geoGrad
        Set ambient_formation_ = ambTemp
    End If
    
    ' here we must have ambient_formation_ ready for initialisation
    
    t_bh_C_ = ambient_formation_.amb_temp_C(trajectory.h_perf_vert_m)
    t_wh_C_ = ambient_formation_.amb_temp_C(0)
    t_surf_C_ = t_wh_C_
    tres_C_ = fluid.tres_C
    
    ' инициализируем все элементы скважины для расчета по линейной зависимости от измеренной глубине
    ' это метод расчета по умолчанию
    ' все другие режимы расчета используют объект ambient_formation_ и не зависят от этой инициализации
    Dim TempGrad As Double
    Dim t_int_C As Double
    TempGrad = (t_bh_C_ - t_wh_C_) / trajectory.h_perf_m
    
     
    Dim i As Integer
    Dim tempDown_C As Double
    Dim tempUp_C As Double
    Dim pipe As CPipe
    Dim HvalveVert0_m  As Double
    
    
    tempUp_C = t_bh_C_
    For i = 1 To PipesProd.Count
         Set pipe = PipesProd(i)
         tempDown_C = tempUp_C
         tempUp_C = tempDown_C - TempGrad * pipe.length_mes_m
         pipe.InitTlinear tempUp_C, tempDown_C
    Next i
    
    HvalveVert0_m = trajectory.h_abs_hmes_m(valves.Hmes_lowest_m)
    tempUp_C = ambient_formation.amb_temp_C(HvalveVert0_m)
    For i = 1 To PipesInj.Count
         Set pipe = PipesInj(i)
         tempDown_C = tempUp_C
         tempUp_C = tempDown_C - TempGrad * pipe.length_mes_m
         pipe.InitTlinear tempUp_C, tempDown_C
    Next i
    ' зададим значения всех температур в ключевых точках в соответствии с исходными параметрами
    ' некоторые из этих параметров потом могут быть перевычисленны
    PT_buf_.t_C = t_wh_C_
    PT_lin_.t_C = t_wh_C_
    PT_gas_inj_.t_C = t_wh_C_
    PT_wf_.t_C = t_bh_C_
    
    Exit Sub
err1:
    Dim errmsg As String
    errmsg = "CWellGL.init_well_temperature: error in temperature init " & sDELIM & Err.Description
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
' метод инициализации газлифтной скважины
' должен уметь задавать все трубы по скважине из исходных данных по траектории
'
'
Public Sub init_well_GLV(Optional ByVal GLV_h_mes_m = 0, _
                       Optional ByVal GLV_dvalve_mm = 0, _
                       Optional ByVal GLV_Pbellow_atma = 0)
   Dim RangeX As Range
   Dim RangeY As Range
   If IsObject(GLV_h_mes_m) Then
        Set RangeX = GLV_h_mes_m
        Set RangeY = GLV_dvalve_mm
        Call valves.loadFromVertRange(RangeX, RangeY)
   ElseIf IsArray(GLV_h_mes_m) Then
        Call valves.loadFromArray(GLV_h_mes_m, GLV_dvalve_mm, GLV_Pbellow_atma)
   End If
  
End Sub
Private Sub FillWellConstructionSimple(ByVal h_perf_m As Double, _
                    ByVal htub_m As Double, _
                    ByVal udl_m As Double, _
                    ByVal d_cas_mm As Double, _
                    ByVal dtub_mm As Double)
' метод для инициализации скважины простыми числами
On Error GoTo err1:
   Dim errmsg As String
   
   ' задаем траекторию свола скважины, на основе которого потом будет задано все остальное
   Dim tr As New CTrajectory
   Dim HabsCurve_m As New CInterpolation  ' инклинометрия - две точки
   HabsCurve_m.AddPoint 0, 0
   HabsCurve_m.AddPoint h_perf_m, h_perf_m - udl_m
   
   Dim DcasCurve_mm As New CInterpolation  ' casing diameter
   DcasCurve_mm.AddPoint 0, d_cas_mm
   DcasCurve_mm.AddPoint h_perf_m, d_cas_mm  ' casing goes from top to bottom here
   
   Dim DtubCurve_mm As New CInterpolation  ' tubing diameter
   DtubCurve_mm.AddPoint 0, dtub_mm
   DtubCurve_mm.AddPoint htub_m, dtub_mm  ' goes to tubing setting depth
   
   ' initialise trajectory (same as ESP well class)
   Call tr.init_trajectory_h_abs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, h_perf_m, htub_m)
   Set trajectory = tr
   Call FillWellConstructionTr
   
   Exit Sub
   
err1:
   errmsg = "CWellGL.FillWellConstructionSimple: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errmsg)
   Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
Private Sub FillWellConstructionRangeAll(ByVal Incl_h_mes_m_ As Range, _
                           ByVal Incl_h_vert_m_ As Range, _
                           ByVal hmes_d_cas_m_ As Range, _
                           ByVal dcas_arr_mm_ As Range, _
                           ByVal hmes_d_tub_m_ As Range, _
                           ByVal dtub_arr_mm_ As Range, _
                           ByVal h_perf_m As Double, _
                           ByVal htub_m As Double)
' метод для инициализации скважины из диапазонов измнения ключевых параметров
On Error GoTo err1:
   Dim HabsCurve_m As New CInterpolation
   Dim DcasCurve_mm As New CInterpolation
   Dim DtubCurve_mm As New CInterpolation
   Dim geoGrad As New CInterpolation
   Dim ambTemp As New CAmbientFormation
   Dim errmsg As String
   
   Call HabsCurve_m.loadFromVertRange(Incl_h_mes_m_, Incl_h_vert_m_)
   Call DcasCurve_mm.loadFromVertRange(hmes_d_cas_m_, dcas_arr_mm_)
   Call DtubCurve_mm.loadFromVertRange(hmes_d_tub_m_, dtub_arr_mm_)
  
   h_perf_m = DcasCurve_mm.maxx
   htub_m = DtubCurve_mm.maxx
   
   Call trajectory.init_trajectory_h_abs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, h_perf_m, htub_m, valves)
   Call FillWellConstructionTr
   
   Exit Sub
err1:
   errmsg = "CWellESP.InitWellRangeAll: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errmsg)
   Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
' ============================================================
' основные расчетные функции
' ============================================================
Public Sub set_qgas_inj(Optional ByVal Pcas_inj_atma As Double = 1, _
                      Optional ByVal Qgas_inj_scm3day As Double = -1)
    q_gas_inj_scm3day_ = Qgas_inj_scm3day
    PT_gas_inj_.p_atma = Pcas_inj_atma
End Sub
Public Function calc_plin_pwf_atma(ByVal pwf_atma As Double, _
                            Optional ByVal saveCurve As CALC_RESULTS = nocurves) As Double
' @brief расчет давления на устье через забойное давление (снизу -> вверх)
' @param p_wf - исходное забойное давление и температура
' @Qgas_inj_scm3day - gas rate injected. If given - used at deepest GLV
' @CalcCasing - флаг показывает надо ли считать ветку распределения давления по забтрубу - динамический уровень и затрубное давление
' @CalcChoke - показывает надо ли считать штуцер
' @saveCurve - показывает насколько детально надо сохранять результаты расчета
Dim Tintake_esp_C As Double
Dim PT_temp As PTtype
Dim PTcas_temp As PTtype
Dim Tan_C As Double
Dim pcur As CInterpolation
Dim i As Integer
Dim pipe As CPipe
Dim Qgfree_tot_scm3day As Double
Qgfree_tot_scm3day = 0
Dim fluid_Pipe_Below As CPVT
' first initialize temp fluid with general one
Set fluid_Pipe_Below = fluid
' flag show if lowest GLV has been acounted
Dim LowestGLVdone As Boolean
LowestGLVdone = False
Dim Qgas_inj_GLV_scm3day As Double
Qgas_inj_GLV_scm3day = 0
    
On Error GoTo err1:
    ' 1. Start calculation from p_wf, Tbh
    PT_wf_.p_atma = pwf_atma
    PT_temp = PT_wf_
    PTcas_temp = PT_gas_inj_ 'SetPT(Pcas_inj_atma, PT_cas_.T_C)
    
    ' 2. calculate pressure distribution in annulus
    
    For i = PipesInj.Count To 1 Step -1
        Set pipe = PipesInj(i)
        pipe.param = param_calc_against_flow(Gas, temp_correlation)
        PTcas_temp = pipe.calc_dPipe(PTcas_temp.p_atma, saveCurve)
        If Not pipe.GLVin Is Nothing Then
            ' if  there is a valve - save PT in casing at valve intake
            pipe.GLVin.p_in_atma = PTcas_temp.p_atma
            pipe.GLVin.t_C = PTcas_temp.t_C
        End If
    Next i
    
    ' 3. calc tubing pressure
    For i = 1 To PipesProd.Count
        ' first segment - from bottom to tubing depth then goes up
        Set pipe = PipesProd(i)
        ' taking fluid from previos segment - if we had gas injected below it will acounted here
        Set pipe.fluid = fluid_Pipe_Below
        ' check if there is a valve on pipe bottom
        ' GLV meant it is possible ijection point
        If Not pipe.GLVin Is Nothing Then
            ' if valve set up then estimate gas coming through valve
            pipe.GLVin.p_out_atma = PT_temp.p_atma   ' pressure at pipe bottom from previos step
            pipe.GLVin.t_C = PT_temp.t_C
            ' adding additional gas coming trough valve
On Error GoTo err2:
            If q_gas_inj_scm3day_ > 0 Then
                ' use manual Qgas in well
                If Not LowestGLVdone Then
                    Qgas_inj_GLV_scm3day = q_gas_inj_scm3day_
                    LowestGLVdone = True
                Else
                    Qgas_inj_GLV_scm3day = 0
                End If
            Else
                Qgas_inj_GLV_scm3day = pipe.GLVin.calc_q_gas_sm3day(-1, -1, -1)
              '  i = i / 0
            End If
            pipe.GLVin.q_gas_inj_scm3day = Qgas_inj_GLV_scm3day
On Error GoTo err1:
            Qgfree_tot_scm3day = Qgfree_tot_scm3day + Qgas_inj_GLV_scm3day
            If Qgas_inj_GLV_scm3day > 0 Then
                Set pipe.fluid = fluid_Pipe_Below.clone
                pipe.fluid.q_gas_free_sm3day = Qgfree_tot_scm3day
                Set fluid_Pipe_Below = pipe.fluid
            End If
        End If
        ' считаем снизу в сторону буферного
        pipe.param = param_calc_along_flow(hydraulic_correlation, temp_correlation)
        PT_temp = pipe.calc_dPipe(PT_temp.p_atma, saveCurve)
    Next i
    PT_buf_ = PT_temp
    PT_lin_ = PT_buf_
On Error GoTo err3:
    ' 4. Расчет линейного давления по штуцеру
    If choke.d_choke_m > 0 Then      ' пока отключено
        Set choke.fluid = pipe.fluid   ' take fluid from last pipe
        PT_lin_ = choke.calc_choke_p_lin(PT_buf_)
        If PT_lin_.p_atma < 0 Then
            PT_lin_.p_atma = 1
        End If
    End If
On Error GoTo err1:
    calc_plin_pwf_atma = PT_temp.p_atma
    
    If saveCurve > 0 Then
        For i = 1 To PipesProd.Count
            Set pipe = PipesProd(i)
            Call curve(str_PtubHmes_curve).AddPointsCurve(pipe.curves("c_P"))
            Call curve(str_TtubHmes_curve).AddPointsCurve(pipe.curves("c_T"))
            Call curve(str_TambHmes_curve).AddPointsCurve(pipe.curves("c_Tamb"))
            If saveCurve > 1 Then
                Call curve(str_HlHmes_curve).AddPointsCurve(pipe.curvesOut("c_Hl"))
                curve(str_HlHmes_curve).yName = "Hl"
            End If
        Next i
        For i = 1 To PipesInj.Count
           Set pipe = PipesInj(i)
           Call curve(str_PcasHmes_curve).AddPointsCurve(pipe.curves("c_P"))
           Call curve(str_TcasHmes_curve).AddPointsCurve(pipe.curves("c_T"))
        Next i
        
        curve(str_PtubHmes_curve).xName = "hmes ptub"
        curve(str_PtubHmes_curve).yName = "Ptub"
        
        curve(str_TtubHmes_curve).xName = "hmes Ttub"
        curve(str_TtubHmes_curve).yName = "Ttub"
        
        curve(str_TambHmes_curve).xName = "hmes Tamb"
        curve(str_TambHmes_curve).yName = "Tamb"
        
        curve(str_PcasHmes_curve).xName = "hmes pcas"
        curve(str_PcasHmes_curve).yName = "pcas"
        
        curve(str_TcasHmes_curve).xName = "hmes pcas"
        curve(str_TcasHmes_curve).yName = "Tcas"
    End If
    Exit Function
err1:
    On Error Resume Next
    RaiseEvent ReportProgress("CWellGL.calc_plin_pwf_atma: some general error")
    Err.Raise Err.Number, Err.Source, Err.Description
    Exit Function
err2:
    On Error Resume Next
    addLogMsg "CWellGL.calc_plin_pwf_atma:error while GLV Hmes = " & CStr(pipe.GLVin.h_mes_m) & " calc - Qgas_inj_GLV_scm3day = " & CStr(Qgas_inj_GLV_scm3day)
    Resume Next
    Exit Function
err3:
    On Error Resume Next
    addLogMsg "CWellGL.calc_plin_pwf_atma:error while choke calc - choke have been  ignored"
    Resume Next
End Function
Public Function calc_pwf_plin_atma(ByVal plin_atma As Double, _
                                    ByVal t_bh_C As Double, _
                                    Optional saveCurve As CALC_RESULTS = nocurves)
' @brief calc_pwf_plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
' @param plin_atma - давление в линии
' @param Hd - динамический уровень
' @param t_bh_C - температура на забое скважины
' @return Подсчитанное для заданного линейного давление
On Error GoTo err1:
    Dim p_wf1 As Double      ' первое приближение
    Dim p_wfUp As Double, p_wfDown As Double
    Dim p_linUp As Double, p_linDown As Double
    Dim p_lin0 As Double, p_lin1 As Double
    Dim found_solution As Boolean
    Dim i As Integer
    found_solution = False
    i = 0
    p_wf1 = 60
    p_wfUp = -1
    p_wfDown = -1
    Do
        ' ищем  приближения
        p_lin1 = calc_plin_pwf_atma(p_wf1, saveCurve:=nocurves)
        If (Abs(p_lin1 - plin_atma) < const_well_P_tolerance) Then
             found_solution = True
             PT_wf_.p_atma = p_wf1
             PT_wf_.t_C = t_bh_C
        End If
        If Not found_solution Then
          If p_lin1 > plin_atma Then
              p_wfUp = p_wf1
              p_linUp = p_lin1
              If p_wfDown < 0 Then
                  p_wf1 = p_wfUp / 2
              Else
                  p_wf1 = p_wfDown + (p_wfUp - p_wfDown) * (plin_atma - p_linDown) / (p_linUp - p_linDown)
              End If
          Else
              p_wfDown = p_wf1
              p_linDown = p_lin1
              If p_wfUp < 0 Then
                  p_wf1 = p_wf1 * 2
              Else
                  p_wf1 = (p_wfUp + p_wfDown) / 2
              End If
          End If
        End If
        i = i + 1
    Loop While Not found_solution And i < 20
    
    If i = 20 Then
       addLogMsg "CWellGL.calc_pwf_plin_atma: max iteration num reached. i = " & CStr(i) & " tolerance reached = " & CStr(Abs(p_lin1 - plin_atma))
    End If
    
   ' Call set_qgas_inj(Pcas_inj_atma, Qgas_inj_scm3day)
    PT_lin_ = SetPT(calc_plin_pwf_atma(PT_wf_.p_atma, saveCurve:=saveCurve), t_buf_C)
    
    If Abs(p_line_atma - plin_atma) > const_well_P_tolerance Then
       addLogMsg "CWellGL.calc_pwf_plin_atma: BHP estimation error exceeds tolerance " & const_well_P_tolerance & ". Equal = " & Abs(Me.p_line_atma - plin_atma)
    End If
    calc_pwf_plin_atma = PT_wf_.p_atma
    
    Exit Function
err1:
    ' тут надо среагировать на ошибку
        On Error Resume Next
    RaiseEvent ReportProgress("CWellGL.calc_plin_pwf_atma: some general error")
    Err.Raise Err.Number, Err.Source, Err.Description
    Exit Function
 End Function
 
' =============================================================================
' specific properties and functions
' =============================================================================
Private Sub FillWellConstructionTr()
    Dim i As Integer, j As Integer
    Dim segmUp_m As Double
    Dim segmDown_m As Double
    Dim pipe As CPipe
    ' need to fill up individual pipe segments in well (production line)
    ' 1 segment from bottom hole to Htub  (lowest)
    ' next - from Htub to valve(0) depth - and so on
    ' at this point valve depth values must be ok (sorted and non zero)
        
    ' set up pipe segments for injection line
    ' 1 segment from lowest valve to upper
    ' not interested for now what happens bellow lowest valve
    
    ' set up csing flow below tubing depth
    segmDown_m = trajectory.h_perf_m
    segmUp_m = trajectory.h_tubing_m
    If segmDown_m > segmUp_m Then
        ' first segment from bottom to tubing depth exist
        ' hae to be created here
        Set pipe = New CPipe  ' creating new object
        Set pipe.fluid = fluid
        Call pipe.init_pipe_constr_by_trajectory(trajectory, segmUp_m, segmDown_m, pipeCasing)
        PipesProd.Add pipe    ' save it to collection
    End If
    segmDown_m = segmUp_m
    i = valves.Count
    If i > 0 Then
        segmUp_m = valves.h_mes_m(i)
    Else
        segmUp_m = 0
    End If
    For j = i To 0 Step -1
        If segmUp_m < segmDown_m Then
            Set pipe = New CPipe  ' creating new object
            Set pipe.fluid = fluid
            Call pipe.init_pipe_constr_by_trajectory(trajectory, segmUp_m, segmDown_m, pipeTubing)
            If j < i Then
                Set pipe.GLVin = valves.valves(j + 1)
            End If
            PipesProd.Add pipe    ' save it to collection
            segmDown_m = segmUp_m
        End If
        If j > 1 Then
            segmUp_m = valves.h_mes_m(j - 1)
        Else
            segmUp_m = 0
        End If
        If segmUp_m < segmDown_m Then
            ' if exist segment
            Set pipe = New CPipe  ' creating new object
            Set pipe.fluid = fluid
            Call pipe.init_pipe_constr_by_trajectory(trajectory, segmUp_m, segmDown_m, pipeAnnulus)
            Set pipe.GLVin = valves.valves(j)
            PipesInj.Add pipe
        End If
    Next j
       
'   Hvd_m = Trajectory.h_tubing_m ' определим глубину спуска установки
'   p_Hspvert_m = Trajectory.h_abs_hmes_m(h_sp_m_)    ' в том числе по вертикали
'   Call pipe_HspHvd_.init_pipe_constr_by_trajectory(Trajectory, Trajectory.h_tubing_m, Trajectory.h_perf_m, 1)
    choke.d_up_m = 0.06
    choke.d_down_m = 0.06
    For Each pipe In PipesProd
        Set pipe.ambient_formation = ambient_formation
    Next pipe
    For Each pipe In PipesInj
        Set pipe.ambient_formation = ambient_formation
    Next pipe
    
End Sub
' Public Sub InitTempTr(geoGrad As CInterpolation)
'' процедура для инициализации температуры в скважине, для линейнго расчета
'' при линейном расчете предполагается,
'' что температура меняется линейно относительно глубины скважины
''
'   Dim TempGradVert As Double
'   Dim pipe As CPipe
'
'   PT_wf_.T_C = geoGrad.getPoint(geoGrad.maxx)
'   PT_buf_.T_C = geoGrad.getPoint(geoGrad.minx)
'
'   TempGradVert = (PT_wf_.T_C - PT_buf_.T_C) / Trajectory.h_perf_m
'
'   For Each pipe In PipesProd
'       pipe.dTdLinit = TempGradVert
'   Next pipe
'   For Each pipe In PipesInj
'       pipe.dTdLinit = TempGradVert
'   Next pipe
'
'   temp_correlation = GeoGradTemp
'
'End Sub
 
 
Public Property Get p_gas_inj_atma() As Double
    p_gas_inj_atma = PT_gas_inj_.p_atma
End Property
Public Property Let p_gas_inj_atma(val As Double)
    PT_gas_inj_.p_atma = val
End Property
' ======================================================================
' Iwell implementation
' ======================================================================
Private Function IWell_CalcDown(p_line_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
 '   IWell_CalcDown = calc_pwf_plin_atma(p_line_atma, t_bh_C, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcUp(pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
 '   IWell_CalcUp = calc_plin_pwf_atma(pwf_atma, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcWell(pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
End Function
Private Property Get IWell_cfBettaFric() As Double
    IWell_cfBettaFric = c_calibr_fric
End Property
Private Property Get IWell_cfBettaGrav() As Double
    IWell_cfBettaGrav = c_calibr_grav
End Property
Private Property Get IWell_cDegradChoke() As Double
    IWell_cDegradChoke = choke.c_degrad_fr
End Property
Private Property Get IWell_cfESP() As Double
    IWell_cfESP = ESP.c_calibr_head
    ' пока учитывается только по напору
    ' наверное потом надо будет добавить по дебиту и по мощности как то
End Property
Private Property Get IWell_cfFw() As Double
    IWell_cfFw = 0
End Property
Private Property Get IWell_cfGLinj() As Double
    IWell_cfGLinj = 0
End Property
Private Property Get IWell_cfRp() As Double
    IWell_cfRp = 0
End Property
Private Property Get IWell_fw() As Double
    IWell_fw = fluid.fw_perc
End Property
Private Property Get IWell_Pintake() As Double
    IWell_Pintake = 0
End Property
Private Property Get IWell_Pline() As Double
    IWell_Pline = PT_lin_.p_atma
End Property
Private Property Get IWell_Pwf() As Double
    IWell_Pwf = PT_wf_.p_atma
End Property
Private Property Get IWell_Pwh() As Double
    IWell_Pwh = PT_buf_.p_atma
End Property
Private Property Get IWell_Qgascas() As Double
    IWell_Qgascas = 0
End Property
Private Property Get IWell_Qgasinj() As Double
    IWell_Qgasinj = 0
End Property
Private Property Let IWell_Qliq(RHS As Double)
    fluid.qliq_sm3day = RHS
End Property
Private Property Get IWell_Qliq() As Double
    IWell_Qliq = fluid.qliq_sm3day
End Property

