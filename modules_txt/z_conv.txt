''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2009, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional complex convolution.
'
'For given A/B returns conv(A,B) (non-circular). Subroutine can automatically
'choose between three implementations: straightforward O(M*N)  formula  for
'very small N (or M), overlap-add algorithm for  cases  where  max(M,N)  is
'significantly larger than min(M,N), but O(M*N) algorithm is too slow,  and
'general FFT-based formula for cases where two previois algorithms are  too
'slow.
'
'Algorithm has max(M,N)*log(max(M,N)) complexity for any M/N.
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - complex function to be transformed
'    M   -   problem size
'    B   -   array[0..N-1] - complex function to be transformed
'    N   -   problem size
'
'OUTPUT PARAMETERS
'    R   -   convolution: A*B. array[0..N+M-2].
'
'NOTE:
'    It is assumed that A is zero at T<0, B is zero too.  If  one  or  both
'functions have non-zero values at negative T's, you  can  still  use  this
'subroutine - just shift its result correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvC1D(ByRef A() As Complex, _
         ByVal M As Long, _
         ByRef B() As Complex, _
         ByVal N As Long, _
         ByRef R() As Complex)
    
    '
    ' normalize task: make M>=N,
    ' so A will be longer that B.
    '
    If M < N Then
        Call ConvC1D(B, N, A, M, R)
        Exit Sub
    End If
    Call ConvC1DX(A, M, B, N, False, -1#, 0#, R)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional complex non-circular deconvolution (inverse of ConvC1D()).
'
'Algorithm has M*log(M)) complexity for any M (composite or prime).
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
'    M   -   convolved signal length
'    B   -   array[0..N-1] - response
'    N   -   response length, N<=M
'
'OUTPUT PARAMETERS
'    R   -   deconvolved signal. array[0..M-N].
'
'NOTE:
'    deconvolution is unstable process and may result in division  by  zero
'(if your response function is degenerate, i.e. has zero Fourier coefficient).
'
'NOTE:
'    It is assumed that A is zero at T<0, B is zero too.  If  one  or  both
'functions have non-zero values at negative T's, you  can  still  use  this
'subroutine - just shift its result correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvC1DInv(ByRef A() As Complex, _
         ByVal M As Long, _
         ByRef B() As Complex, _
         ByVal N As Long, _
         ByRef R() As Complex)
    Dim i As Long
    Dim p As Long
    Dim Buf() As Double
    Dim Buf2() As Double
    Dim Plan As FTPlan
    Dim C1 As Complex
    Dim C2 As Complex
    Dim C3 As Complex
    Dim T As Double
    p = FTBaseFindSmooth(M)
    Call FTBaseGenerateComplexFFTPlan(p, Plan)
    ReDim Buf(0 To 2# * p - 1)
    For i = 0# To M - 1# Step 1
        Buf(2# * i + 0#) = A(i).X
        Buf(2# * i + 1#) = A(i).y
    Next i
    For i = M To p - 1# Step 1
        Buf(2# * i + 0#) = 0#
        Buf(2# * i + 1#) = 0#
    Next i
    ReDim Buf2(0 To 2# * p - 1)
    For i = 0# To N - 1# Step 1
        Buf2(2# * i + 0#) = B(i).X
        Buf2(2# * i + 1#) = B(i).y
    Next i
    For i = N To p - 1# Step 1
        Buf2(2# * i + 0#) = 0#
        Buf2(2# * i + 1#) = 0#
    Next i
    Call FTBaseExecutePlan(Buf, 0#, p, Plan)
    Call FTBaseExecutePlan(Buf2, 0#, p, Plan)
    For i = 0# To p - 1# Step 1
        C1.X = Buf(2# * i + 0#)
        C1.y = Buf(2# * i + 1#)
        C2.X = Buf2(2# * i + 0#)
        C2.y = Buf2(2# * i + 1#)
        C3 = C_Div(C1, C2)
        Buf(2# * i + 0#) = C3.X
        Buf(2# * i + 1#) = -C3.y
    Next i
    Call FTBaseExecutePlan(Buf, 0#, p, Plan)
    T = 1# / p
    ReDim R(0 To M - N + 1# - 1)
    For i = 0# To M - N Step 1
        R(i).X = (T * Buf(2# * i + 0#))
        R(i).y = -(T * Buf(2# * i + 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional circular complex convolution.
'
'For given S/R returns conv(S,R) (circular). Algorithm has linearithmic
'complexity for any M/N.
'
'IMPORTANT:  normal convolution is commutative,  i.e.   it  is symmetric  -
'conv(A,B)=conv(B,A).  Cyclic convolution IS NOT.  One function - S - is  a
'signal,  periodic function, and another - R - is a response,  non-periodic
'function with limited length.
'
'INPUT PARAMETERS
'    S   -   array[0..M-1] - complex periodic signal
'    M   -   problem size
'    B   -   array[0..N-1] - complex non-periodic response
'    N   -   problem size
'
'OUTPUT PARAMETERS
'    R   -   convolution: A*B. array[0..M-1].
'
'NOTE:
'    It is assumed that B is zero at T<0. If  it  has  non-zero  values  at
'negative T's, you can still use this subroutine - just  shift  its  result
'correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvC1DCircular(ByRef S() As Complex, _
         ByVal M As Long, _
         ByRef R() As Complex, _
         ByVal N As Long, _
         ByRef C() As Complex)
    Dim Buf() As Complex
    Dim I1 As Long
    Dim I2 As Long
    Dim J2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' normalize task: make M>=N,
    ' so A will be longer (at least - not shorter) that B.
    '
    If M < N Then
        ReDim Buf(0 To M - 1)
        For I1 = 0# To M - 1# Step 1
            Buf(I1) = C_Complex(0#)
        Next I1
        I1 = 0#
        Do While I1 < N
            I2 = MinInt(I1 + M - 1#, N - 1#)
            J2 = I2 - I1
            i1_ = (I1) - (0#)
            For i_ = 0# To J2 Step 1
                Buf(i_) = C_Add(Buf(i_), R(i_ + i1_))
            Next i_
            I1 = I1 + M
        Loop
        Call ConvC1DCircular(S, M, Buf, M, C)
        Exit Sub
    End If
    Call ConvC1DX(S, M, R, N, True, -1#, 0#, C)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional circular complex deconvolution (inverse of ConvC1DCircular()).
'
'Algorithm has M*log(M)) complexity for any M (composite or prime).
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - convolved periodic signal, A = conv(R, B)
'    M   -   convolved signal length
'    B   -   array[0..N-1] - non-periodic response
'    N   -   response length
'
'OUTPUT PARAMETERS
'    R   -   deconvolved signal. array[0..M-1].
'
'NOTE:
'    deconvolution is unstable process and may result in division  by  zero
'(if your response function is degenerate, i.e. has zero Fourier coefficient).
'
'NOTE:
'    It is assumed that B is zero at T<0. If  it  has  non-zero  values  at
'negative T's, you can still use this subroutine - just  shift  its  result
'correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvC1DCircularInv(ByRef A() As Complex, _
         ByVal M As Long, _
         ByRef B() As Complex, _
         ByVal N As Long, _
         ByRef R() As Complex)
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim J2 As Long
    Dim Buf() As Double
    Dim Buf2() As Double
    Dim CBuf() As Complex
    Dim Plan As FTPlan
    Dim C1 As Complex
    Dim C2 As Complex
    Dim C3 As Complex
    Dim T As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' normalize task: make M>=N,
    ' so A will be longer (at least - not shorter) that B.
    '
    If M < N Then
        ReDim CBuf(0 To M - 1)
        For i = 0# To M - 1# Step 1
            CBuf(i) = C_Complex(0#)
        Next i
        I1 = 0#
        Do While I1 < N
            I2 = MinInt(I1 + M - 1#, N - 1#)
            J2 = I2 - I1
            i1_ = (I1) - (0#)
            For i_ = 0# To J2 Step 1
                CBuf(i_) = C_Add(CBuf(i_), B(i_ + i1_))
            Next i_
            I1 = I1 + M
        Loop
        Call ConvC1DCircularInv(A, M, CBuf, M, R)
        Exit Sub
    End If
    
    '
    ' Task is normalized
    '
    Call FTBaseGenerateComplexFFTPlan(M, Plan)
    ReDim Buf(0 To 2# * M - 1)
    For i = 0# To M - 1# Step 1
        Buf(2# * i + 0#) = A(i).X
        Buf(2# * i + 1#) = A(i).y
    Next i
    ReDim Buf2(0 To 2# * M - 1)
    For i = 0# To N - 1# Step 1
        Buf2(2# * i + 0#) = B(i).X
        Buf2(2# * i + 1#) = B(i).y
    Next i
    For i = N To M - 1# Step 1
        Buf2(2# * i + 0#) = 0#
        Buf2(2# * i + 1#) = 0#
    Next i
    Call FTBaseExecutePlan(Buf, 0#, M, Plan)
    Call FTBaseExecutePlan(Buf2, 0#, M, Plan)
    For i = 0# To M - 1# Step 1
        C1.X = Buf(2# * i + 0#)
        C1.y = Buf(2# * i + 1#)
        C2.X = Buf2(2# * i + 0#)
        C2.y = Buf2(2# * i + 1#)
        C3 = C_Div(C1, C2)
        Buf(2# * i + 0#) = C3.X
        Buf(2# * i + 1#) = -C3.y
    Next i
    Call FTBaseExecutePlan(Buf, 0#, M, Plan)
    T = 1# / M
    ReDim R(0 To M - 1)
    For i = 0# To M - 1# Step 1
        R(i).X = (T * Buf(2# * i + 0#))
        R(i).y = -(T * Buf(2# * i + 1#))
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional real convolution.
'
'Analogous to ConvC1D(), see ConvC1D() comments for more details.
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - real function to be transformed
'    M   -   problem size
'    B   -   array[0..N-1] - real function to be transformed
'    N   -   problem size
'
'OUTPUT PARAMETERS
'    R   -   convolution: A*B. array[0..N+M-2].
'
'NOTE:
'    It is assumed that A is zero at T<0, B is zero too.  If  one  or  both
'functions have non-zero values at negative T's, you  can  still  use  this
'subroutine - just shift its result correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvR1D(ByRef A() As Double, _
         ByVal M As Long, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByRef R() As Double)
    
    '
    ' normalize task: make M>=N,
    ' so A will be longer that B.
    '
    If M < N Then
        Call ConvR1D(B, N, A, M, R)
        Exit Sub
    End If
    Call ConvR1DX(A, M, B, N, False, -1#, 0#, R)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional real deconvolution (inverse of ConvC1D()).
'
'Algorithm has M*log(M)) complexity for any M (composite or prime).
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
'    M   -   convolved signal length
'    B   -   array[0..N-1] - response
'    N   -   response length, N<=M
'
'OUTPUT PARAMETERS
'    R   -   deconvolved signal. array[0..M-N].
'
'NOTE:
'    deconvolution is unstable process and may result in division  by  zero
'(if your response function is degenerate, i.e. has zero Fourier coefficient).
'
'NOTE:
'    It is assumed that A is zero at T<0, B is zero too.  If  one  or  both
'functions have non-zero values at negative T's, you  can  still  use  this
'subroutine - just shift its result correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvR1DInv(ByRef A() As Double, _
         ByVal M As Long, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByRef R() As Double)
    Dim i As Long
    Dim p As Long
    Dim Buf() As Double
    Dim Buf2() As Double
    Dim Buf3() As Double
    Dim Plan As FTPlan
    Dim C1 As Complex
    Dim C2 As Complex
    Dim C3 As Complex
    Dim i_ As Long
    p = FTBaseFindSmoothEven(M)
    ReDim Buf(0 To p - 1)
    For i_ = 0# To M - 1# Step 1
        Buf(i_) = A(i_)
    Next i_
    For i = M To p - 1# Step 1
        Buf(i) = 0#
    Next i
    ReDim Buf2(0 To p - 1)
    For i_ = 0# To N - 1# Step 1
        Buf2(i_) = B(i_)
    Next i_
    For i = N To p - 1# Step 1
        Buf2(i) = 0#
    Next i
    ReDim Buf3(0 To p - 1)
    Call FTBaseGenerateComplexFFTPlan(p \ 2#, Plan)
    Call FFTR1DInternalEven(Buf, p, Buf3, Plan)
    Call FFTR1DInternalEven(Buf2, p, Buf3, Plan)
    Buf(0#) = Buf(0#) / Buf2(0#)
    Buf(1#) = Buf(1#) / Buf2(1#)
    For i = 1# To p \ 2# - 1# Step 1
        C1.X = Buf(2# * i + 0#)
        C1.y = Buf(2# * i + 1#)
        C2.X = Buf2(2# * i + 0#)
        C2.y = Buf2(2# * i + 1#)
        C3 = C_Div(C1, C2)
        Buf(2# * i + 0#) = C3.X
        Buf(2# * i + 1#) = C3.y
    Next i
    Call FFTR1DInvInternalEven(Buf, p, Buf3, Plan)
    ReDim R(0 To M - N + 1# - 1)
    For i_ = 0# To M - N Step 1
        R(i_) = Buf(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional circular real convolution.
'
'Analogous to ConvC1DCircular(), see ConvC1DCircular() comments for more details.
'
'INPUT PARAMETERS
'    S   -   array[0..M-1] - real signal
'    M   -   problem size
'    B   -   array[0..N-1] - real response
'    N   -   problem size
'
'OUTPUT PARAMETERS
'    R   -   convolution: A*B. array[0..M-1].
'
'NOTE:
'    It is assumed that B is zero at T<0. If  it  has  non-zero  values  at
'negative T's, you can still use this subroutine - just  shift  its  result
'correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvR1DCircular(ByRef S() As Double, _
         ByVal M As Long, _
         ByRef R() As Double, _
         ByVal N As Long, _
         ByRef C() As Double)
    Dim Buf() As Double
    Dim I1 As Long
    Dim I2 As Long
    Dim J2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' normalize task: make M>=N,
    ' so A will be longer (at least - not shorter) that B.
    '
    If M < N Then
        ReDim Buf(0 To M - 1)
        For I1 = 0# To M - 1# Step 1
            Buf(I1) = 0#
        Next I1
        I1 = 0#
        Do While I1 < N
            I2 = MinInt(I1 + M - 1#, N - 1#)
            J2 = I2 - I1
            i1_ = (I1) - (0#)
            For i_ = 0# To J2 Step 1
                Buf(i_) = Buf(i_) + R(i_ + i1_)
            Next i_
            I1 = I1 + M
        Loop
        Call ConvR1DCircular(S, M, Buf, M, C)
        Exit Sub
    End If
    
    '
    ' reduce to usual convolution
    '
    Call ConvR1DX(S, M, R, N, True, -1#, 0#, C)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional complex deconvolution (inverse of ConvC1D()).
'
'Algorithm has M*log(M)) complexity for any M (composite or prime).
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
'    M   -   convolved signal length
'    B   -   array[0..N-1] - response
'    N   -   response length
'
'OUTPUT PARAMETERS
'    R   -   deconvolved signal. array[0..M-N].
'
'NOTE:
'    deconvolution is unstable process and may result in division  by  zero
'(if your response function is degenerate, i.e. has zero Fourier coefficient).
'
'NOTE:
'    It is assumed that B is zero at T<0. If  it  has  non-zero  values  at
'negative T's, you can still use this subroutine - just  shift  its  result
'correspondingly.
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvR1DCircularInv(ByRef A() As Double, _
         ByVal M As Long, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByRef R() As Double)
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim J2 As Long
    Dim Buf() As Double
    Dim Buf2() As Double
    Dim Buf3() As Double
    Dim CBuf() As Complex
    Dim CBuf2() As Complex
    Dim Plan As FTPlan
    Dim C1 As Complex
    Dim C2 As Complex
    Dim C3 As Complex
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' normalize task: make M>=N,
    ' so A will be longer (at least - not shorter) that B.
    '
    If M < N Then
        ReDim Buf(0 To M - 1)
        For i = 0# To M - 1# Step 1
            Buf(i) = 0#
        Next i
        I1 = 0#
        Do While I1 < N
            I2 = MinInt(I1 + M - 1#, N - 1#)
            J2 = I2 - I1
            i1_ = (I1) - (0#)
            For i_ = 0# To J2 Step 1
                Buf(i_) = Buf(i_) + B(i_ + i1_)
            Next i_
            I1 = I1 + M
        Loop
        Call ConvR1DCircularInv(A, M, Buf, M, R)
        Exit Sub
    End If
    
    '
    ' Task is normalized
    '
    If M Mod 2# = 0# Then
        
        '
        ' size is even, use fast even-size FFT
        '
        ReDim Buf(0 To M - 1)
        For i_ = 0# To M - 1# Step 1
            Buf(i_) = A(i_)
        Next i_
        ReDim Buf2(0 To M - 1)
        For i_ = 0# To N - 1# Step 1
            Buf2(i_) = B(i_)
        Next i_
        For i = N To M - 1# Step 1
            Buf2(i) = 0#
        Next i
        ReDim Buf3(0 To M - 1)
        Call FTBaseGenerateComplexFFTPlan(M \ 2#, Plan)
        Call FFTR1DInternalEven(Buf, M, Buf3, Plan)
        Call FFTR1DInternalEven(Buf2, M, Buf3, Plan)
        Buf(0#) = Buf(0#) / Buf2(0#)
        Buf(1#) = Buf(1#) / Buf2(1#)
        For i = 1# To M \ 2# - 1# Step 1
            C1.X = Buf(2# * i + 0#)
            C1.y = Buf(2# * i + 1#)
            C2.X = Buf2(2# * i + 0#)
            C2.y = Buf2(2# * i + 1#)
            C3 = C_Div(C1, C2)
            Buf(2# * i + 0#) = C3.X
            Buf(2# * i + 1#) = C3.y
        Next i
        Call FFTR1DInvInternalEven(Buf, M, Buf3, Plan)
        ReDim R(0 To M - 1)
        For i_ = 0# To M - 1# Step 1
            R(i_) = Buf(i_)
        Next i_
    Else
        
        '
        ' odd-size, use general real FFT
        '
        Call FFTR1D(A, M, CBuf)
        ReDim Buf2(0 To M - 1)
        For i_ = 0# To N - 1# Step 1
            Buf2(i_) = B(i_)
        Next i_
        For i = N To M - 1# Step 1
            Buf2(i) = 0#
        Next i
        Call FFTR1D(Buf2, M, CBuf2)
        For i = 0# To Int(M / 2#) Step 1
            CBuf(i) = C_Div(CBuf(i), CBuf2(i))
        Next i
        Call FFTR1DInv(CBuf, M, R)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional complex convolution.
'
'Extended subroutine which allows to choose convolution algorithm.
'Intended for internal use, ALGLIB users should call ConvC1D()/ConvC1DCircular().
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - complex function to be transformed
'    M   -   problem size
'    B   -   array[0..N-1] - complex function to be transformed
'    N   -   problem size, N<=M
'    Alg -   algorithm type:
'            *-2     auto-select Q for overlap-add
'            *-1     auto-select algorithm and parameters
'            * 0     straightforward formula for small N's
'            * 1     general FFT-based code
'            * 2     overlap-add with length Q
'    Q   -   length for overlap-add
'
'OUTPUT PARAMETERS
'    R   -   convolution: A*B. array[0..N+M-1].
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvC1DX(ByRef A() As Complex, _
         ByVal M As Long, _
         ByRef B() As Complex, _
         ByVal N As Long, _
         ByVal Circular As Boolean, _
         ByVal Alg As Long, _
         ByVal q As Long, _
         ByRef R() As Complex)
    Dim i As Long
    Dim j As Long
    Dim p As Long
    Dim PTotal As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim BBuf() As Complex
    Dim V As Complex
    Dim AX As Double
    Dim AY As Double
    Dim BX As Double
    Dim BY As Double
    Dim T As Double
    Dim TX As Double
    Dim TY As Double
    Dim FlopCand As Double
    Dim FlopBest As Double
    Dim AlgBest As Long
    Dim Plan As FTPlan
    Dim Buf() As Double
    Dim Buf2() As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Auto-select
    '
    If Alg = -1# Or Alg = -2# Then
        
        '
        ' Initial candidate: straightforward implementation.
        '
        ' If we want to use auto-fitted overlap-add,
        ' flop count is initialized by large real number - to force
        ' another algorithm selection
        '
        AlgBest = 0#
        If Alg = -1# Then
            FlopBest = 2# * M * N
        Else
            FlopBest = MaxRealNumber
        End If
        
        '
        ' Another candidate - generic FFT code
        '
        If Alg = -1# Then
            If Circular And FTBaseIsSmooth(M) Then
                
                '
                ' special code for circular convolution of a sequence with a smooth length
                '
                FlopCand = 3# * FTBaseGetFLOPEstimate(M) + 6# * M
                If FlopCand < FlopBest Then
                    AlgBest = 1#
                    FlopBest = FlopCand
                End If
            Else
                
                '
                ' general cyclic/non-cyclic convolution
                '
                p = FTBaseFindSmooth(M + N - 1#)
                FlopCand = 3# * FTBaseGetFLOPEstimate(p) + 6# * p
                If FlopCand < FlopBest Then
                    AlgBest = 1#
                    FlopBest = FlopCand
                End If
            End If
        End If
        
        '
        ' Another candidate - overlap-add
        '
        q = 1#
        PTotal = 1#
        Do While PTotal < N
            PTotal = PTotal * 2#
        Loop
        Do While PTotal <= M + N - 1#
            p = PTotal - N + 1#
            FlopCand = Ceil(M / p) * (2# * FTBaseGetFLOPEstimate(PTotal) + 8# * PTotal)
            If FlopCand < FlopBest Then
                FlopBest = FlopCand
                AlgBest = 2#
                q = p
            End If
            PTotal = PTotal * 2#
        Loop
        Alg = AlgBest
        Call ConvC1DX(A, M, B, N, Circular, Alg, q, R)
        Exit Sub
    End If
    
    '
    ' straightforward formula for
    ' circular and non-circular convolutions.
    '
    ' Very simple code, no further comments needed.
    '
    If Alg = 0# Then
        
        '
        ' Special case: N=1
        '
        If N = 1# Then
            ReDim R(0 To M - 1)
            V = B(0#)
            For i_ = 0# To M - 1# Step 1
                R(i_) = C_Mul(V, A(i_))
            Next i_
            Exit Sub
        End If
        
        '
        ' use straightforward formula
        '
        If Circular Then
            
            '
            ' circular convolution
            '
            ReDim R(0 To M - 1)
            V = B(0#)
            For i_ = 0# To M - 1# Step 1
                R(i_) = C_Mul(V, A(i_))
            Next i_
            For i = 1# To N - 1# Step 1
                V = B(i)
                I1 = 0#
                I2 = i - 1#
                J1 = M - i
                J2 = M - 1#
                i1_ = (J1) - (I1)
                For i_ = I1 To I2 Step 1
                    R(i_) = C_Add(R(i_), C_Mul(V, A(i_ + i1_)))
                Next i_
                I1 = i
                I2 = M - 1#
                J1 = 0#
                J2 = M - i - 1#
                i1_ = (J1) - (I1)
                For i_ = I1 To I2 Step 1
                    R(i_) = C_Add(R(i_), C_Mul(V, A(i_ + i1_)))
                Next i_
            Next i
        Else
            
            '
            ' non-circular convolution
            '
            ReDim R(0 To M + N - 1# - 1)
            For i = 0# To M + N - 2# Step 1
                R(i) = C_Complex(0#)
            Next i
            For i = 0# To N - 1# Step 1
                V = B(i)
                i1_ = (0#) - (i)
                For i_ = i To i + M - 1# Step 1
                    R(i_) = C_Add(R(i_), C_Mul(V, A(i_ + i1_)))
                Next i_
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' general FFT-based code for
    ' circular and non-circular convolutions.
    '
    ' First, if convolution is circular, we test whether M is smooth or not.
    ' If it is smooth, we just use M-length FFT to calculate convolution.
    ' If it is not, we calculate non-circular convolution and wrap it arount.
    '
    ' IF convolution is non-circular, we use zero-padding + FFT.
    '
    If Alg = 1# Then
        If Circular And FTBaseIsSmooth(M) Then
            
            '
            ' special code for circular convolution with smooth M
            '
            Call FTBaseGenerateComplexFFTPlan(M, Plan)
            ReDim Buf(0 To 2# * M - 1)
            For i = 0# To M - 1# Step 1
                Buf(2# * i + 0#) = A(i).X
                Buf(2# * i + 1#) = A(i).y
            Next i
            ReDim Buf2(0 To 2# * M - 1)
            For i = 0# To N - 1# Step 1
                Buf2(2# * i + 0#) = B(i).X
                Buf2(2# * i + 1#) = B(i).y
            Next i
            For i = N To M - 1# Step 1
                Buf2(2# * i + 0#) = 0#
                Buf2(2# * i + 1#) = 0#
            Next i
            Call FTBaseExecutePlan(Buf, 0#, M, Plan)
            Call FTBaseExecutePlan(Buf2, 0#, M, Plan)
            For i = 0# To M - 1# Step 1
                AX = Buf(2# * i + 0#)
                AY = Buf(2# * i + 1#)
                BX = Buf2(2# * i + 0#)
                BY = Buf2(2# * i + 1#)
                TX = AX * BX - AY * BY
                TY = AX * BY + AY * BX
                Buf(2# * i + 0#) = TX
                Buf(2# * i + 1#) = -TY
            Next i
            Call FTBaseExecutePlan(Buf, 0#, M, Plan)
            T = 1# / M
            ReDim R(0 To M - 1)
            For i = 0# To M - 1# Step 1
                R(i).X = (T * Buf(2# * i + 0#))
                R(i).y = -(T * Buf(2# * i + 1#))
            Next i
        Else
            
            '
            ' M is non-smooth, general code (circular/non-circular):
            ' * first part is the same for circular and non-circular
            '   convolutions. zero padding, FFTs, inverse FFTs
            ' * second part differs:
            '   * for non-circular convolution we just copy array
            '   * for circular convolution we add array tail to its head
            '
            p = FTBaseFindSmooth(M + N - 1#)
            Call FTBaseGenerateComplexFFTPlan(p, Plan)
            ReDim Buf(0 To 2# * p - 1)
            For i = 0# To M - 1# Step 1
                Buf(2# * i + 0#) = A(i).X
                Buf(2# * i + 1#) = A(i).y
            Next i
            For i = M To p - 1# Step 1
                Buf(2# * i + 0#) = 0#
                Buf(2# * i + 1#) = 0#
            Next i
            ReDim Buf2(0 To 2# * p - 1)
            For i = 0# To N - 1# Step 1
                Buf2(2# * i + 0#) = B(i).X
                Buf2(2# * i + 1#) = B(i).y
            Next i
            For i = N To p - 1# Step 1
                Buf2(2# * i + 0#) = 0#
                Buf2(2# * i + 1#) = 0#
            Next i
            Call FTBaseExecutePlan(Buf, 0#, p, Plan)
            Call FTBaseExecutePlan(Buf2, 0#, p, Plan)
            For i = 0# To p - 1# Step 1
                AX = Buf(2# * i + 0#)
                AY = Buf(2# * i + 1#)
                BX = Buf2(2# * i + 0#)
                BY = Buf2(2# * i + 1#)
                TX = AX * BX - AY * BY
                TY = AX * BY + AY * BX
                Buf(2# * i + 0#) = TX
                Buf(2# * i + 1#) = -TY
            Next i
            Call FTBaseExecutePlan(Buf, 0#, p, Plan)
            T = 1# / p
            If Circular Then
                
                '
                ' circular, add tail to head
                '
                ReDim R(0 To M - 1)
                For i = 0# To M - 1# Step 1
                    R(i).X = (T * Buf(2# * i + 0#))
                    R(i).y = -(T * Buf(2# * i + 1#))
                Next i
                For i = M To M + N - 2# Step 1
                    R(i - M).X = R(i - M).X + T * Buf(2# * i + 0#)
                    R(i - M).y = R(i - M).y - T * Buf(2# * i + 1#)
                Next i
            Else
                
                '
                ' non-circular, just copy
                '
                ReDim R(0 To M + N - 1# - 1)
                For i = 0# To M + N - 2# Step 1
                    R(i).X = (T * Buf(2# * i + 0#))
                    R(i).y = -(T * Buf(2# * i + 1#))
                Next i
            End If
        End If
        Exit Sub
    End If
    
    '
    ' overlap-add method for
    ' circular and non-circular convolutions.
    '
    ' First part of code (separate FFTs of input blocks) is the same
    ' for all types of convolution. Second part (overlapping outputs)
    ' differs for different types of convolution. We just copy output
    ' when convolution is non-circular. We wrap it around, if it is
    ' circular.
    '
    If Alg = 2# Then
        ReDim Buf(0 To 2# * (q + N - 1#) - 1)
        
        '
        ' prepare R
        '
        If Circular Then
            ReDim R(0 To M - 1)
            For i = 0# To M - 1# Step 1
                R(i) = C_Complex(0#)
            Next i
        Else
            ReDim R(0 To M + N - 1# - 1)
            For i = 0# To M + N - 2# Step 1
                R(i) = C_Complex(0#)
            Next i
        End If
        
        '
        ' pre-calculated FFT(B)
        '
        ReDim BBuf(0 To q + N - 1# - 1)
        For i_ = 0# To N - 1# Step 1
            BBuf(i_) = B(i_)
        Next i_
        For j = N To q + N - 2# Step 1
            BBuf(j) = C_Complex(0#)
        Next j
        Call FFTC1D(BBuf, q + N - 1#)
        
        '
        ' prepare FFT plan for chunks of A
        '
        Call FTBaseGenerateComplexFFTPlan(q + N - 1#, Plan)
        
        '
        ' main overlap-add cycle
        '
        i = 0#
        Do While i <= M - 1#
            p = MinInt(q, M - i)
            For j = 0# To p - 1# Step 1
                Buf(2# * j + 0#) = A(i + j).X
                Buf(2# * j + 1#) = A(i + j).y
            Next j
            For j = p To q + N - 2# Step 1
                Buf(2# * j + 0#) = 0#
                Buf(2# * j + 1#) = 0#
            Next j
            Call FTBaseExecutePlan(Buf, 0#, q + N - 1#, Plan)
            For j = 0# To q + N - 2# Step 1
                AX = Buf(2# * j + 0#)
                AY = Buf(2# * j + 1#)
                BX = BBuf(j).X
                BY = BBuf(j).y
                TX = AX * BX - AY * BY
                TY = AX * BY + AY * BX
                Buf(2# * j + 0#) = TX
                Buf(2# * j + 1#) = -TY
            Next j
            Call FTBaseExecutePlan(Buf, 0#, q + N - 1#, Plan)
            T = 1# / (q + N - 1#)
            If Circular Then
                J1 = MinInt(i + p + N - 2#, M - 1#) - i
                J2 = J1 + 1#
            Else
                J1 = p + N - 2#
                J2 = J1 + 1#
            End If
            For j = 0# To J1 Step 1
                R(i + j).X = R(i + j).X + Buf(2# * j + 0#) * T
                R(i + j).y = R(i + j).y - Buf(2# * j + 1#) * T
            Next j
            For j = J2 To p + N - 2# Step 1
                R(j - J2).X = R(j - J2).X + Buf(2# * j + 0#) * T
                R(j - J2).y = R(j - J2).y - Buf(2# * j + 1#) * T
            Next j
            i = i + p
        Loop
        Exit Sub
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'1-dimensional real convolution.
'
'Extended subroutine which allows to choose convolution algorithm.
'Intended for internal use, ALGLIB users should call ConvR1D().
'
'INPUT PARAMETERS
'    A   -   array[0..M-1] - complex function to be transformed
'    M   -   problem size
'    B   -   array[0..N-1] - complex function to be transformed
'    N   -   problem size, N<=M
'    Alg -   algorithm type:
'            *-2     auto-select Q for overlap-add
'            *-1     auto-select algorithm and parameters
'            * 0     straightforward formula for small N's
'            * 1     general FFT-based code
'            * 2     overlap-add with length Q
'    Q   -   length for overlap-add
'
'OUTPUT PARAMETERS
'    R   -   convolution: A*B. array[0..N+M-1].
'
'  -- ALGLIB --
'     Copyright 21.07.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ConvR1DX(ByRef A() As Double, _
         ByVal M As Long, _
         ByRef B() As Double, _
         ByVal N As Long, _
         ByVal Circular As Boolean, _
         ByVal Alg As Long, _
         ByVal q As Long, _
         ByRef R() As Double)
    Dim V As Double
    Dim i As Long
    Dim j As Long
    Dim p As Long
    Dim PTotal As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim J1 As Long
    Dim J2 As Long
    Dim AX As Double
    Dim AY As Double
    Dim BX As Double
    Dim BY As Double
    Dim TX As Double
    Dim TY As Double
    Dim FlopCand As Double
    Dim FlopBest As Double
    Dim AlgBest As Long
    Dim Plan As FTPlan
    Dim Buf() As Double
    Dim Buf2() As Double
    Dim Buf3() As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' handle special cases
    '
    If MinInt(M, N) <= 2# Then
        Alg = 0#
    End If
    
    '
    ' Auto-select
    '
    If Alg < 0# Then
        
        '
        ' Initial candidate: straightforward implementation.
        '
        ' If we want to use auto-fitted overlap-add,
        ' flop count is initialized by large real number - to force
        ' another algorithm selection
        '
        AlgBest = 0#
        If Alg = -1# Then
            FlopBest = 0.15 * M * N
        Else
            FlopBest = MaxRealNumber
        End If
        
        '
        ' Another candidate - generic FFT code
        '
        If Alg = -1# Then
            If Circular And FTBaseIsSmooth(M) And M Mod 2# = 0# Then
                
                '
                ' special code for circular convolution of a sequence with a smooth length
                '
                FlopCand = 3# * FTBaseGetFLOPEstimate(M \ 2#) + 6# * M / 2#
                If FlopCand < FlopBest Then
                    AlgBest = 1#
                    FlopBest = FlopCand
                End If
            Else
                
                '
                ' general cyclic/non-cyclic convolution
                '
                p = FTBaseFindSmoothEven(M + N - 1#)
                FlopCand = 3# * FTBaseGetFLOPEstimate(p \ 2#) + 6# * p / 2#
                If FlopCand < FlopBest Then
                    AlgBest = 1#
                    FlopBest = FlopCand
                End If
            End If
        End If
        
        '
        ' Another candidate - overlap-add
        '
        q = 1#
        PTotal = 1#
        Do While PTotal < N
            PTotal = PTotal * 2#
        Loop
        Do While PTotal <= M + N - 1#
            p = PTotal - N + 1#
            FlopCand = Ceil(M / p) * (2# * FTBaseGetFLOPEstimate(PTotal \ 2#) + 1# * (PTotal \ 2#))
            If FlopCand < FlopBest Then
                FlopBest = FlopCand
                AlgBest = 2#
                q = p
            End If
            PTotal = PTotal * 2#
        Loop
        Alg = AlgBest
        Call ConvR1DX(A, M, B, N, Circular, Alg, q, R)
        Exit Sub
    End If
    
    '
    ' straightforward formula for
    ' circular and non-circular convolutions.
    '
    ' Very simple code, no further comments needed.
    '
    If Alg = 0# Then
        
        '
        ' Special case: N=1
        '
        If N = 1# Then
            ReDim R(0 To M - 1)
            V = B(0#)
            For i_ = 0# To M - 1# Step 1
                R(i_) = V * A(i_)
            Next i_
            Exit Sub
        End If
        
        '
        ' use straightforward formula
        '
        If Circular Then
            
            '
            ' circular convolution
            '
            ReDim R(0 To M - 1)
            V = B(0#)
            For i_ = 0# To M - 1# Step 1
                R(i_) = V * A(i_)
            Next i_
            For i = 1# To N - 1# Step 1
                V = B(i)
                I1 = 0#
                I2 = i - 1#
                J1 = M - i
                J2 = M - 1#
                i1_ = (J1) - (I1)
                For i_ = I1 To I2 Step 1
                    R(i_) = R(i_) + V * A(i_ + i1_)
                Next i_
                I1 = i
                I2 = M - 1#
                J1 = 0#
                J2 = M - i - 1#
                i1_ = (J1) - (I1)
                For i_ = I1 To I2 Step 1
                    R(i_) = R(i_) + V * A(i_ + i1_)
                Next i_
            Next i
        Else
            
            '
            ' non-circular convolution
            '
            ReDim R(0 To M + N - 1# - 1)
            For i = 0# To M + N - 2# Step 1
                R(i) = 0#
            Next i
            For i = 0# To N - 1# Step 1
                V = B(i)
                i1_ = (0#) - (i)
                For i_ = i To i + M - 1# Step 1
                    R(i_) = R(i_) + V * A(i_ + i1_)
                Next i_
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' general FFT-based code for
    ' circular and non-circular convolutions.
    '
    ' First, if convolution is circular, we test whether M is smooth or not.
    ' If it is smooth, we just use M-length FFT to calculate convolution.
    ' If it is not, we calculate non-circular convolution and wrap it arount.
    '
    ' If convolution is non-circular, we use zero-padding + FFT.
    '
    ' We assume that M+N-1>2 - we should call small case code otherwise
    '
    If Alg = 1# Then
        If Circular And FTBaseIsSmooth(M) And M Mod 2# = 0# Then
            
            '
            ' special code for circular convolution with smooth even M
            '
            ReDim Buf(0 To M - 1)
            For i_ = 0# To M - 1# Step 1
                Buf(i_) = A(i_)
            Next i_
            ReDim Buf2(0 To M - 1)
            For i_ = 0# To N - 1# Step 1
                Buf2(i_) = B(i_)
            Next i_
            For i = N To M - 1# Step 1
                Buf2(i) = 0#
            Next i
            ReDim Buf3(0 To M - 1)
            Call FTBaseGenerateComplexFFTPlan(M \ 2#, Plan)
            Call FFTR1DInternalEven(Buf, M, Buf3, Plan)
            Call FFTR1DInternalEven(Buf2, M, Buf3, Plan)
            Buf(0#) = Buf(0#) * Buf2(0#)
            Buf(1#) = Buf(1#) * Buf2(1#)
            For i = 1# To M \ 2# - 1# Step 1
                AX = Buf(2# * i + 0#)
                AY = Buf(2# * i + 1#)
                BX = Buf2(2# * i + 0#)
                BY = Buf2(2# * i + 1#)
                TX = AX * BX - AY * BY
                TY = AX * BY + AY * BX
                Buf(2# * i + 0#) = TX
                Buf(2# * i + 1#) = TY
            Next i
            Call FFTR1DInvInternalEven(Buf, M, Buf3, Plan)
            ReDim R(0 To M - 1)
            For i_ = 0# To M - 1# Step 1
                R(i_) = Buf(i_)
            Next i_
        Else
            
            '
            ' M is non-smooth or non-even, general code (circular/non-circular):
            ' * first part is the same for circular and non-circular
            '   convolutions. zero padding, FFTs, inverse FFTs
            ' * second part differs:
            '   * for non-circular convolution we just copy array
            '   * for circular convolution we add array tail to its head
            '
            p = FTBaseFindSmoothEven(M + N - 1#)
            ReDim Buf(0 To p - 1)
            For i_ = 0# To M - 1# Step 1
                Buf(i_) = A(i_)
            Next i_
            For i = M To p - 1# Step 1
                Buf(i) = 0#
            Next i
            ReDim Buf2(0 To p - 1)
            For i_ = 0# To N - 1# Step 1
                Buf2(i_) = B(i_)
            Next i_
            For i = N To p - 1# Step 1
                Buf2(i) = 0#
            Next i
            ReDim Buf3(0 To p - 1)
            Call FTBaseGenerateComplexFFTPlan(p \ 2#, Plan)
            Call FFTR1DInternalEven(Buf, p, Buf3, Plan)
            Call FFTR1DInternalEven(Buf2, p, Buf3, Plan)
            Buf(0#) = Buf(0#) * Buf2(0#)
            Buf(1#) = Buf(1#) * Buf2(1#)
            For i = 1# To p \ 2# - 1# Step 1
                AX = Buf(2# * i + 0#)
                AY = Buf(2# * i + 1#)
                BX = Buf2(2# * i + 0#)
                BY = Buf2(2# * i + 1#)
                TX = AX * BX - AY * BY
                TY = AX * BY + AY * BX
                Buf(2# * i + 0#) = TX
                Buf(2# * i + 1#) = TY
            Next i
            Call FFTR1DInvInternalEven(Buf, p, Buf3, Plan)
            If Circular Then
                
                '
                ' circular, add tail to head
                '
                ReDim R(0 To M - 1)
                For i_ = 0# To M - 1# Step 1
                    R(i_) = Buf(i_)
                Next i_
                If N >= 2# Then
                    i1_ = (M) - (0#)
                    For i_ = 0# To N - 2# Step 1
                        R(i_) = R(i_) + Buf(i_ + i1_)
                    Next i_
                End If
            Else
                
                '
                ' non-circular, just copy
                '
                ReDim R(0 To M + N - 1# - 1)
                For i_ = 0# To M + N - 2# Step 1
                    R(i_) = Buf(i_)
                Next i_
            End If
        End If
        Exit Sub
    End If
    
    '
    ' overlap-add method
    '
    If Alg = 2# Then
        ReDim Buf(0 To q + N - 1# - 1)
        ReDim Buf2(0 To q + N - 1# - 1)
        ReDim Buf3(0 To q + N - 1# - 1)
        Call FTBaseGenerateComplexFFTPlan((q + N - 1#) \ 2#, Plan)
        
        '
        ' prepare R
        '
        If Circular Then
            ReDim R(0 To M - 1)
            For i = 0# To M - 1# Step 1
                R(i) = 0#
            Next i
        Else
            ReDim R(0 To M + N - 1# - 1)
            For i = 0# To M + N - 2# Step 1
                R(i) = 0#
            Next i
        End If
        
        '
        ' pre-calculated FFT(B)
        '
        For i_ = 0# To N - 1# Step 1
            Buf2(i_) = B(i_)
        Next i_
        For j = N To q + N - 2# Step 1
            Buf2(j) = 0#
        Next j
        Call FFTR1DInternalEven(Buf2, q + N - 1#, Buf3, Plan)
        
        '
        ' main overlap-add cycle
        '
        i = 0#
        Do While i <= M - 1#
            p = MinInt(q, M - i)
            i1_ = (i) - (0#)
            For i_ = 0# To p - 1# Step 1
                Buf(i_) = A(i_ + i1_)
            Next i_
            For j = p To q + N - 2# Step 1
                Buf(j) = 0#
            Next j
            Call FFTR1DInternalEven(Buf, q + N - 1#, Buf3, Plan)
            Buf(0#) = Buf(0#) * Buf2(0#)
            Buf(1#) = Buf(1#) * Buf2(1#)
            For j = 1# To (q + N - 1#) \ 2# - 1# Step 1
                AX = Buf(2# * j + 0#)
                AY = Buf(2# * j + 1#)
                BX = Buf2(2# * j + 0#)
                BY = Buf2(2# * j + 1#)
                TX = AX * BX - AY * BY
                TY = AX * BY + AY * BX
                Buf(2# * j + 0#) = TX
                Buf(2# * j + 1#) = TY
            Next j
            Call FFTR1DInvInternalEven(Buf, q + N - 1#, Buf3, Plan)
            If Circular Then
                J1 = MinInt(i + p + N - 2#, M - 1#) - i
                J2 = J1 + 1#
            Else
                J1 = p + N - 2#
                J2 = J1 + 1#
            End If
            i1_ = (0#) - (i)
            For i_ = i To i + J1 Step 1
                R(i_) = R(i_) + Buf(i_ + i1_)
            Next i_
            If p + N - 2# >= J2 Then
                i1_ = (J2) - (0#)
                For i_ = 0# To p + N - 2# - J2 Step 1
                    R(i_) = R(i_) + Buf(i_ + i1_)
                Next i_
            End If
            i = i + p
        Loop
        Exit Sub
    End If
End Sub

