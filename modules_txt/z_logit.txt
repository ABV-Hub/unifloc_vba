''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2008, Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
Public Type LogitModel
    w() As Double
End Type
Public Type LOGITMCState
    BRACKT As Boolean
    STAGE1 As Boolean
    INFOC As Long
    DG As Double
    DGM As Double
    DGInit As Double
    DGTEST As Double
    DGX As Double
    DGXM As Double
    DGY As Double
    DGYM As Double
    FInit As Double
    FTEST1 As Double
    FM As Double
    FX As Double
    FXM As Double
    FY As Double
    FYM As Double
    STX As Double
    STY As Double
    STMIN As Double
    STMAX As Double
    WIDTH As Double
    WIDTH1 As Double
    XTRAPF As Double
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'MNLReport structure contains information about training process:
'* NGrad     -   number of gradient calculations
'* NHess     -   number of Hessian calculations
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Type MNLReport
    NGrad As Long
    NHess As Long
End Type
'Global constants
Private Const XTOL As Double = 100# * MachineEpsilon
Private Const FTOL As Double = 0.0001
Private Const GTOL As Double = 0.3
Private Const MAXFEV As Long = 20#
Private Const STPMIN As Double = 0.01
Private Const StpMax As Double = 100000#
Private Const LogitVNum As Long = 6#
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This subroutine trains logit model.
'
'INPUT PARAMETERS:
'    XY          -   training set, array[0..NPoints-1,0..NVars]
'                    First NVars columns store values of independent
'                    variables, next column stores number of class (from 0
'                    to NClasses-1) which dataset element belongs to. Fractional
'                    values are rounded to nearest integer.
'    NPoints     -   training set size, NPoints>=1
'    NVars       -   number of independent variables, NVars>=1
'    NClasses    -   number of classes, NClasses>=2
'
'OUTPUT PARAMETERS:
'    Info        -   return code:
'                    * -2, if there is a point with class number
'                          outside of [0..NClasses-1].
'                    * -1, if incorrect parameters was passed
'                          (NPoints<NVars+2, NVars<1, NClasses<2).
'                    *  1, if task has been solved
'    LM          -   model built
'    Rep         -   training report
'
'  -- ALGLIB --
'     Copyright 10.09.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MNLTrainH(ByRef XY() As Double, _
         ByVal NPoints As Long, _
         ByVal NVars As Long, _
         ByVal NClasses As Long, _
         ByRef Info As Long, _
         ByRef LM As LogitModel, _
         ByRef Rep As MNLReport)
    Dim i As Long
    Dim j As Long
    Dim K As Long
    Dim SSize As Long
    Dim AllSame As Boolean
    Dim Offs As Long
    Dim Threshold As Double
    Dim WMinStep As Double
    Dim Decay As Double
    Dim WDim As Long
    Dim ExpOffs As Long
    Dim V As Double
    Dim S As Double
    Dim Network As MultiLayerPerceptron
    Dim NIn As Long
    Dim NOut As Long
    Dim WCount As Long
    Dim E As Double
    Dim G() As Double
    Dim H() As Double
    Dim SPD As Boolean
    Dim X() As Double
    Dim y() As Double
    Dim WBase() As Double
    Dim WStep As Double
    Dim WDir() As Double
    Dim WORK() As Double
    Dim MCStage As Long
    Dim MCState As LOGITMCState
    Dim MCINFO As Long
    Dim MCNFEV As Long
    Dim SolverInfo As Long
    Dim SolverRep As DenseSolverReport
    Dim i_ As Long
    Dim i1_ As Long
    Threshold = 1000# * MachineEpsilon
    WMinStep = 0.001
    Decay = 0.001
    
    '
    ' Test for inputs
    '
    If NPoints < NVars + 2# Or NVars < 1# Or NClasses < 2# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To NPoints - 1# Step 1
        If Round(XY(i, NVars)) < 0# Or Round(XY(i, NVars)) >= NClasses Then
            Info = -2#
            Exit Sub
        End If
    Next i
    Info = 1#
    
    '
    ' Initialize data
    '
    Rep.NGrad = 0#
    Rep.NHess = 0#
    
    '
    ' Allocate array
    '
    WDim = (NVars + 1#) * (NClasses - 1#)
    Offs = 5#
    ExpOffs = Offs + WDim
    SSize = 5# + (NVars + 1#) * (NClasses - 1#) + NClasses
    ReDim LM.w(0# To SSize - 1#)
    LM.w(0#) = SSize
    LM.w(1#) = LogitVNum
    LM.w(2#) = NVars
    LM.w(3#) = NClasses
    LM.w(4#) = Offs
    
    '
    ' Degenerate case: all outputs are equal
    '
    AllSame = True
    For i = 1# To NPoints - 1# Step 1
        If Round(XY(i, NVars)) <> Round(XY(i - 1#, NVars)) Then
            AllSame = False
        End If
    Next i
    If AllSame Then
        For i = 0# To (NVars + 1#) * (NClasses - 1#) - 1# Step 1
            LM.w(Offs + i) = 0#
        Next i
        V = -(2# * Log(MinRealNumber))
        K = Round(XY(0#, NVars))
        If K = NClasses - 1# Then
            For i = 0# To NClasses - 2# Step 1
                LM.w(Offs + i * (NVars + 1#) + NVars) = -V
            Next i
        Else
            For i = 0# To NClasses - 2# Step 1
                If i = K Then
                    LM.w(Offs + i * (NVars + 1#) + NVars) = V
                Else
                    LM.w(Offs + i * (NVars + 1#) + NVars) = 0#
                End If
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' General case.
    ' Prepare task and network. Allocate space.
    '
    Call MLPCreateC0(NVars, NClasses, Network)
    Call MLPInitPreprocessor(Network, XY, NPoints)
    Call MLPProperties(Network, NIn, NOut, WCount)
    For i = 0# To WCount - 1# Step 1
        Network.Weights(i) = (2# * Rnd() - 1#) / NVars
    Next i
    ReDim G(0# To WCount - 1#)
    ReDim H(0# To WCount - 1#, 0# To WCount - 1#)
    ReDim WBase(0# To WCount - 1#)
    ReDim WDir(0# To WCount - 1#)
    ReDim WORK(0# To WCount - 1#)
    
    '
    ' First stage: optimize in gradient direction.
    '
    For K = 0# To WCount \ 3# + 10# Step 1
        
        '
        ' Calculate gradient in starting point
        '
        Call MLPGradNBatch(Network, XY, NPoints, E, G)
        V = 0#
        For i_ = 0# To WCount - 1# Step 1
            V = V + Network.Weights(i_) * Network.Weights(i_)
        Next i_
        E = E + 0.5 * Decay * V
        For i_ = 0# To WCount - 1# Step 1
            G(i_) = G(i_) + Decay * Network.Weights(i_)
        Next i_
        Rep.NGrad = Rep.NGrad + 1#
        
        '
        ' Setup optimization scheme
        '
        For i_ = 0# To WCount - 1# Step 1
            WDir(i_) = -G(i_)
        Next i_
        V = 0#
        For i_ = 0# To WCount - 1# Step 1
            V = V + WDir(i_) * WDir(i_)
        Next i_
        WStep = Sqr(V)
        V = 1# / Sqr(V)
        For i_ = 0# To WCount - 1# Step 1
            WDir(i_) = V * WDir(i_)
        Next i_
        MCStage = 0#
        Call MNLMCSRCH(WCount, Network.Weights, E, G, WDir, WStep, MCINFO, MCNFEV, WORK, MCState, MCStage)
        Do While MCStage <> 0#
            Call MLPGradNBatch(Network, XY, NPoints, E, G)
            V = 0#
            For i_ = 0# To WCount - 1# Step 1
                V = V + Network.Weights(i_) * Network.Weights(i_)
            Next i_
            E = E + 0.5 * Decay * V
            For i_ = 0# To WCount - 1# Step 1
                G(i_) = G(i_) + Decay * Network.Weights(i_)
            Next i_
            Rep.NGrad = Rep.NGrad + 1#
            Call MNLMCSRCH(WCount, Network.Weights, E, G, WDir, WStep, MCINFO, MCNFEV, WORK, MCState, MCStage)
        Loop
    Next K
    
    '
    ' Second stage: use Hessian when we are close to the minimum
    '
    Do While True
        
        '
        ' Calculate and update E/G/H
        '
        Call MLPHessianNBatch(Network, XY, NPoints, E, G, H)
        V = 0#
        For i_ = 0# To WCount - 1# Step 1
            V = V + Network.Weights(i_) * Network.Weights(i_)
        Next i_
        E = E + 0.5 * Decay * V
        For i_ = 0# To WCount - 1# Step 1
            G(i_) = G(i_) + Decay * Network.Weights(i_)
        Next i_
        For K = 0# To WCount - 1# Step 1
            H(K, K) = H(K, K) + Decay
        Next K
        Rep.NHess = Rep.NHess + 1#
        
        '
        ' Select step direction
        ' NOTE: it is important to use lower-triangle Cholesky
        ' factorization since it is much faster than higher-triangle version.
        '
        SPD = SPDMatrixCholesky(H, WCount, False)
        Call SPDMatrixCholeskySolve(H, WCount, False, G, SolverInfo, SolverRep, WDir)
        SPD = SolverInfo > 0#
        If SPD Then
            
            '
            ' H is positive definite.
            ' Step in Newton direction.
            '
            For i_ = 0# To WCount - 1# Step 1
                WDir(i_) = -1 * WDir(i_)
            Next i_
            SPD = True
        Else
            
            '
            ' H is indefinite.
            ' Step in gradient direction.
            '
            For i_ = 0# To WCount - 1# Step 1
                WDir(i_) = -G(i_)
            Next i_
            SPD = False
        End If
        
        '
        ' Optimize in WDir direction
        '
        V = 0#
        For i_ = 0# To WCount - 1# Step 1
            V = V + WDir(i_) * WDir(i_)
        Next i_
        WStep = Sqr(V)
        V = 1# / Sqr(V)
        For i_ = 0# To WCount - 1# Step 1
            WDir(i_) = V * WDir(i_)
        Next i_
        MCStage = 0#
        Call MNLMCSRCH(WCount, Network.Weights, E, G, WDir, WStep, MCINFO, MCNFEV, WORK, MCState, MCStage)
        Do While MCStage <> 0#
            Call MLPGradNBatch(Network, XY, NPoints, E, G)
            V = 0#
            For i_ = 0# To WCount - 1# Step 1
                V = V + Network.Weights(i_) * Network.Weights(i_)
            Next i_
            E = E + 0.5 * Decay * V
            For i_ = 0# To WCount - 1# Step 1
                G(i_) = G(i_) + Decay * Network.Weights(i_)
            Next i_
            Rep.NGrad = Rep.NGrad + 1#
            Call MNLMCSRCH(WCount, Network.Weights, E, G, WDir, WStep, MCINFO, MCNFEV, WORK, MCState, MCStage)
        Loop
        If SPD And (MCINFO = 2# Or MCINFO = 4# Or MCINFO = 6#) Then
            Exit Do
        End If
    Loop
    
    '
    ' Convert from NN format to MNL format
    '
    i1_ = (0#) - (Offs)
    For i_ = Offs To Offs + WCount - 1# Step 1
        LM.w(i_) = Network.Weights(i_ + i1_)
    Next i_
    For K = 0# To NVars - 1# Step 1
        For i = 0# To NClasses - 2# Step 1
            S = Network.ColumnSigmas(K)
            If S = 0# Then
                S = 1#
            End If
            j = Offs + (NVars + 1#) * i
            V = LM.w(j + K)
            LM.w(j + K) = V / S
            LM.w(j + NVars) = LM.w(j + NVars) + V * Network.ColumnMeans(K) / S
        Next i
    Next K
    For K = 0# To NClasses - 2# Step 1
        LM.w(Offs + (NVars + 1#) * K + NVars) = -LM.w(Offs + (NVars + 1#) * K + NVars)
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Procesing
'
'INPUT PARAMETERS:
'    LM      -   logit model, passed by non-constant reference
'                (some fields of structure are used as temporaries
'                when calculating model output).
'    X       -   input vector,  array[0..NVars-1].
'
'OUTPUT PARAMETERS:
'    Y       -   result, array[0..NClasses-1]
'                Vector of posterior probabilities for classification task.
'                Subroutine does not allocate memory for this vector, it is
'                responsibility of a caller to allocate it. Array  must  be
'                at least [0..NClasses-1].
'
'  -- ALGLIB --
'     Copyright 10.09.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MNLProcess(ByRef LM As LogitModel, _
         ByRef X() As Double, _
         ByRef y() As Double)
    Dim NVars As Long
    Dim NClasses As Long
    Dim Offs As Long
    Dim i As Long
    Dim I1 As Long
    Dim S As Double
    NVars = Round(LM.w(2#))
    NClasses = Round(LM.w(3#))
    Offs = Round(LM.w(4#))
    Call MNLIExp(LM.w, X)
    S = 0#
    I1 = Offs + (NVars + 1#) * (NClasses - 1#)
    For i = I1 To I1 + NClasses - 1# Step 1
        S = S + LM.w(i)
    Next i
    For i = 0# To NClasses - 1# Step 1
        y(i) = LM.w(I1 + i) / S
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacks coefficients of logit model. Logit model have form:
'
'    P(class=i) = S(i) / (S(0) + S(1) + ... +S(M-1))
'          S(i) = Exp(A[i,0]*X[0] + ... + A[i,N-1]*X[N-1] + A[i,N]), when i<M-1
'        S(M-1) = 1
'
'INPUT PARAMETERS:
'    LM          -   logit model in ALGLIB format
'
'OUTPUT PARAMETERS:
'    V           -   coefficients, array[0..NClasses-2,0..NVars]
'    NVars       -   number of independent variables
'    NClasses    -   number of classes
'
'  -- ALGLIB --
'     Copyright 10.09.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MNLUnpack(ByRef LM As LogitModel, _
         ByRef A() As Double, _
         ByRef NVars As Long, _
         ByRef NClasses As Long)
    Dim Offs As Long
    Dim i As Long
    Dim i_ As Long
    Dim i1_ As Long
    NVars = Round(LM.w(2#))
    NClasses = Round(LM.w(3#))
    Offs = Round(LM.w(4#))
    ReDim A(0# To NClasses - 2#, 0# To NVars)
    For i = 0# To NClasses - 2# Step 1
        i1_ = (Offs + i * (NVars + 1#)) - (0#)
        For i_ = 0# To NVars Step 1
            A(i, i_) = LM.w(i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'"Packs" coefficients and creates logit model in ALGLIB format (MNLUnpack
'reversed).
'
'INPUT PARAMETERS:
'    A           -   model (see MNLUnpack)
'    NVars       -   number of independent variables
'    NClasses    -   number of classes
'
'OUTPUT PARAMETERS:
'    LM          -   logit model.
'
'  -- ALGLIB --
'     Copyright 10.09.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MNLPack(ByRef A() As Double, _
         ByVal NVars As Long, _
         ByVal NClasses As Long, _
         ByRef LM As LogitModel)
    Dim Offs As Long
    Dim i As Long
    Dim WDim As Long
    Dim SSize As Long
    Dim i_ As Long
    Dim i1_ As Long
    WDim = (NVars + 1#) * (NClasses - 1#)
    Offs = 5#
    SSize = 5# + (NVars + 1#) * (NClasses - 1#) + NClasses
    ReDim LM.w(0# To SSize - 1#)
    LM.w(0#) = SSize
    LM.w(1#) = LogitVNum
    LM.w(2#) = NVars
    LM.w(3#) = NClasses
    LM.w(4#) = Offs
    For i = 0# To NClasses - 2# Step 1
        i1_ = (0#) - (Offs + i * (NVars + 1#))
        For i_ = Offs + i * (NVars + 1#) To Offs + i * (NVars + 1#) + NVars Step 1
            LM.w(i_) = A(i, i_ + i1_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copying of LogitModel strucure
'
'INPUT PARAMETERS:
'    LM1 -   original
'
'OUTPUT PARAMETERS:
'    LM2 -   copy
'
'  -- ALGLIB --
'     Copyright 15.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MNLCopy(ByRef LM1 As LogitModel, ByRef LM2 As LogitModel)
    Dim K As Long
    Dim i_ As Long
    K = Round(LM1.w(0#))
    ReDim LM2.w(0# To K - 1#)
    For i_ = 0# To K - 1# Step 1
        LM2.w(i_) = LM1.w(i_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Serialization of LogitModel strucure
'
'INPUT PARAMETERS:
'    LM      -   original
'
'OUTPUT PARAMETERS:
'    RA      -   array of real numbers which stores model,
'                array[0..RLen-1]
'    RLen    -   RA lenght
'
'  -- ALGLIB --
'     Copyright 15.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MNLSerialize(ByRef LM As LogitModel, _
         ByRef RA() As Double, _
         ByRef RLen As Long)
    Dim i_ As Long
    Dim i1_ As Long
    RLen = Round(LM.w(0#)) + 1#
    ReDim RA(0# To RLen - 1#)
    RA(0#) = LogitVNum
    i1_ = (0#) - (1#)
    For i_ = 1# To RLen - 1# Step 1
        RA(i_) = LM.w(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unserialization of LogitModel strucure
'
'INPUT PARAMETERS:
'    RA      -   real array which stores model
'
'OUTPUT PARAMETERS:
'    LM      -   restored model
'
'  -- ALGLIB --
'     Copyright 15.03.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub MNLUnserialize(ByRef RA() As Double, ByRef LM As LogitModel)
    Dim i_ As Long
    Dim i1_ As Long
    ReDim LM.w(0# To Round(RA(1#)) - 1#)
    i1_ = (1#) - (0#)
    For i_ = 0# To Round(RA(1#)) - 1# Step 1
        LM.w(i_) = RA(i_ + i1_)
    Next i_
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Average cross-entropy (in bits per element) on the test set
'
'INPUT PARAMETERS:
'    LM      -   logit model
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    CrossEntropy/(NPoints*ln(2)).
'
'  -- ALGLIB --
'     Copyright 10.09.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MNLAvgCE(ByRef LM As LogitModel, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim NVars As Long
    Dim NClasses As Long
    Dim i As Long
    Dim WorkX() As Double
    Dim WorkY() As Double
    Dim i_ As Long
    NVars = Round(LM.w(2#))
    NClasses = Round(LM.w(3#))
    ReDim WorkX(0# To NVars - 1#)
    ReDim WorkY(0# To NClasses - 1#)
    Result = 0#
    For i = 0# To NPoints - 1# Step 1
        
        '
        ' Process
        '
        For i_ = 0# To NVars - 1# Step 1
            WorkX(i_) = XY(i, i_)
        Next i_
        Call MNLProcess(LM, WorkX, WorkY)
        If WorkY(Round(XY(i, NVars))) > 0# Then
            Result = Result - Log(WorkY(Round(XY(i, NVars))))
        Else
            Result = Result - Log(MinRealNumber)
        End If
    Next i
    Result = Result / (NPoints * Log(2#))
    MNLAvgCE = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Relative classification error on the test set
'
'INPUT PARAMETERS:
'    LM      -   logit model
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    percent of incorrectly classified cases.
'
'  -- ALGLIB --
'     Copyright 10.09.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MNLRelClsError(ByRef LM As LogitModel, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Result = MNLClsError(LM, XY, NPoints) / NPoints
    MNLRelClsError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'RMS error on the test set
'
'INPUT PARAMETERS:
'    LM      -   logit model
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    root mean square error (error when estimating posterior probabilities).
'
'  -- ALGLIB --
'     Copyright 30.08.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MNLRMSError(ByRef LM As LogitModel, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MNLAllErrors(LM, XY, NPoints, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = RMS
    MNLRMSError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Average error on the test set
'
'INPUT PARAMETERS:
'    LM      -   logit model
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    average error (error when estimating posterior probabilities).
'
'  -- ALGLIB --
'     Copyright 30.08.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MNLAvgError(ByRef LM As LogitModel, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MNLAllErrors(LM, XY, NPoints, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = Avg
    MNLAvgError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Average relative error on the test set
'
'INPUT PARAMETERS:
'    LM      -   logit model
'    XY      -   test set
'    NPoints -   test set size
'
'RESULT:
'    average relative error (error when estimating posterior probabilities).
'
'  -- ALGLIB --
'     Copyright 30.08.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MNLAvgRelError(ByRef LM As LogitModel, _
         ByRef XY() As Double, _
         ByVal SSize As Long) As Double
    Dim Result As Double
    Dim RelCls As Double
    Dim AvgCE As Double
    Dim RMS As Double
    Dim Avg As Double
    Dim AvgRel As Double
    Call MNLAllErrors(LM, XY, SSize, RelCls, AvgCE, RMS, Avg, AvgRel)
    Result = AvgRel
    MNLAvgRelError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Classification error on test set = MNLRelClsError*NPoints
'
'  -- ALGLIB --
'     Copyright 10.09.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function MNLClsError(ByRef LM As LogitModel, _
         ByRef XY() As Double, _
         ByVal NPoints As Long) As Long
    Dim Result As Long
    Dim NVars As Long
    Dim NClasses As Long
    Dim i As Long
    Dim j As Long
    Dim WorkX() As Double
    Dim WorkY() As Double
    Dim NMAX As Long
    Dim i_ As Long
    NVars = Round(LM.w(2#))
    NClasses = Round(LM.w(3#))
    ReDim WorkX(0# To NVars - 1#)
    ReDim WorkY(0# To NClasses - 1#)
    Result = 0#
    For i = 0# To NPoints - 1# Step 1
        
        '
        ' Process
        '
        For i_ = 0# To NVars - 1# Step 1
            WorkX(i_) = XY(i, i_)
        Next i_
        Call MNLProcess(LM, WorkX, WorkY)
        
        '
        ' Logit version of the answer
        '
        NMAX = 0#
        For j = 0# To NClasses - 1# Step 1
            If WorkY(j) > WorkY(NMAX) Then
                NMAX = j
            End If
        Next j
        
        '
        ' compare
        '
        If NMAX <> Round(XY(i, NVars)) Then
            Result = Result + 1#
        End If
    Next i
    MNLClsError = Result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal subroutine. Places exponents of the anti-overflow shifted
'internal linear outputs into the service part of the W array.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub MNLIExp(ByRef w() As Double, ByRef X() As Double)
    Dim NVars As Long
    Dim NClasses As Long
    Dim Offs As Long
    Dim i As Long
    Dim I1 As Long
    Dim V As Double
    Dim MX As Double
    Dim i_ As Long
    Dim i1_ As Long
    NVars = Round(w(2#))
    NClasses = Round(w(3#))
    Offs = Round(w(4#))
    I1 = Offs + (NVars + 1#) * (NClasses - 1#)
    For i = 0# To NClasses - 2# Step 1
        i1_ = (0#) - (Offs + i * (NVars + 1#))
        V = 0#
        For i_ = Offs + i * (NVars + 1#) To Offs + i * (NVars + 1#) + NVars - 1# Step 1
            V = V + w(i_) * X(i_ + i1_)
        Next i_
        w(I1 + i) = V + w(Offs + i * (NVars + 1#) + NVars)
    Next i
    w(I1 + NClasses - 1#) = 0#
    MX = 0#
    For i = I1 To I1 + NClasses - 1# Step 1
        MX = MaxReal(MX, w(i))
    Next i
    For i = I1 To I1 + NClasses - 1# Step 1
        w(i) = Exp(w(i) - MX)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculation of all types of errors
'
'  -- ALGLIB --
'     Copyright 30.08.2008 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub MNLAllErrors(ByRef LM As LogitModel, _
         ByRef XY() As Double, _
         ByVal NPoints As Long, _
         ByRef RelCls As Double, _
         ByRef AvgCE As Double, _
         ByRef RMS As Double, _
         ByRef Avg As Double, _
         ByRef AvgRel As Double)
    Dim NVars As Long
    Dim NClasses As Long
    Dim i As Long
    Dim Buf() As Double
    Dim WorkX() As Double
    Dim y() As Double
    Dim DY() As Double
    Dim i_ As Long
    NVars = Round(LM.w(2#))
    NClasses = Round(LM.w(3#))
    ReDim WorkX(0# To NVars - 1#)
    ReDim y(0# To NClasses - 1#)
    ReDim DY(0# To 0#)
    Call DSErrAllocate(NClasses, Buf)
    For i = 0# To NPoints - 1# Step 1
        For i_ = 0# To NVars - 1# Step 1
            WorkX(i_) = XY(i, i_)
        Next i_
        Call MNLProcess(LM, WorkX, y)
        DY(0#) = XY(i, NVars)
        Call DSErrAccumulate(Buf, y, DY)
    Next i
    Call DSErrFinish(Buf)
    RelCls = Buf(0#)
    AvgCE = Buf(1#)
    RMS = Buf(2#)
    Avg = Buf(3#)
    AvgRel = Buf(4#)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'THE  PURPOSE  OF  MCSRCH  IS  TO  FIND A STEP WHICH SATISFIES A SUFFICIENT
'DECREASE CONDITION AND A CURVATURE CONDITION.
'
'AT EACH STAGE THE SUBROUTINE  UPDATES  AN  INTERVAL  OF  UNCERTAINTY  WITH
'ENDPOINTS  STX  AND  STY.  THE INTERVAL OF UNCERTAINTY IS INITIALLY CHOSEN
'SO THAT IT CONTAINS A MINIMIZER OF THE MODIFIED FUNCTION
'
'    F(X+STP*S) - F(X) - FTOL*STP*(GRADF(X)'S).
'
'IF  A STEP  IS OBTAINED FOR  WHICH THE MODIFIED FUNCTION HAS A NONPOSITIVE
'FUNCTION  VALUE  AND  NONNEGATIVE  DERIVATIVE,   THEN   THE   INTERVAL  OF
'UNCERTAINTY IS CHOSEN SO THAT IT CONTAINS A MINIMIZER OF F(X+STP*S).
'
'THE  ALGORITHM  IS  DESIGNED TO FIND A STEP WHICH SATISFIES THE SUFFICIENT
'DECREASE CONDITION
'
'    F(X+STP*S) .LE. F(X) + FTOL*STP*(GRADF(X)'S),
'
'AND THE CURVATURE CONDITION
'
'    ABS(GRADF(X+STP*S)'S)) .LE. GTOL*ABS(GRADF(X)'S).
'
'IF  FTOL  IS  LESS  THAN GTOL AND IF, FOR EXAMPLE, THE FUNCTION IS BOUNDED
'BELOW,  THEN  THERE  IS  ALWAYS  A  STEP  WHICH SATISFIES BOTH CONDITIONS.
'IF  NO  STEP  CAN BE FOUND  WHICH  SATISFIES  BOTH  CONDITIONS,  THEN  THE
'ALGORITHM  USUALLY STOPS  WHEN  ROUNDING ERRORS  PREVENT FURTHER PROGRESS.
'IN THIS CASE STP ONLY SATISFIES THE SUFFICIENT DECREASE CONDITION.
'
'PARAMETERS DESCRIPRION
'
'N IS A POSITIVE INTEGER INPUT VARIABLE SET TO THE NUMBER OF VARIABLES.
'
'X IS  AN  ARRAY  OF  LENGTH N. ON INPUT IT MUST CONTAIN THE BASE POINT FOR
'THE LINE SEARCH. ON OUTPUT IT CONTAINS X+STP*S.
'
'F IS  A  VARIABLE. ON INPUT IT MUST CONTAIN THE VALUE OF F AT X. ON OUTPUT
'IT CONTAINS THE VALUE OF F AT X + STP*S.
'
'G IS AN ARRAY OF LENGTH N. ON INPUT IT MUST CONTAIN THE GRADIENT OF F AT X.
'ON OUTPUT IT CONTAINS THE GRADIENT OF F AT X + STP*S.
'
'S IS AN INPUT ARRAY OF LENGTH N WHICH SPECIFIES THE SEARCH DIRECTION.
'
'STP  IS  A NONNEGATIVE VARIABLE. ON INPUT STP CONTAINS AN INITIAL ESTIMATE
'OF A SATISFACTORY STEP. ON OUTPUT STP CONTAINS THE FINAL ESTIMATE.
'
'FTOL AND GTOL ARE NONNEGATIVE INPUT VARIABLES. TERMINATION OCCURS WHEN THE
'SUFFICIENT DECREASE CONDITION AND THE DIRECTIONAL DERIVATIVE CONDITION ARE
'SATISFIED.
'
'XTOL IS A NONNEGATIVE INPUT VARIABLE. TERMINATION OCCURS WHEN THE RELATIVE
'WIDTH OF THE INTERVAL OF UNCERTAINTY IS AT MOST XTOL.
'
'STPMIN AND STPMAX ARE NONNEGATIVE INPUT VARIABLES WHICH SPECIFY LOWER  AND
'UPPER BOUNDS FOR THE STEP.
'
'MAXFEV IS A POSITIVE INTEGER INPUT VARIABLE. TERMINATION OCCURS WHEN THE
'NUMBER OF CALLS TO FCN IS AT LEAST MAXFEV BY THE END OF AN ITERATION.
'
'INFO IS AN INTEGER OUTPUT VARIABLE SET AS FOLLOWS:
'    INFO = 0  IMPROPER INPUT PARAMETERS.
'
'    INFO = 1  THE SUFFICIENT DECREASE CONDITION AND THE
'              DIRECTIONAL DERIVATIVE CONDITION HOLD.
'
'    INFO = 2  RELATIVE WIDTH OF THE INTERVAL OF UNCERTAINTY
'              IS AT MOST XTOL.
'
'    INFO = 3  NUMBER OF CALLS TO FCN HAS REACHED MAXFEV.
'
'    INFO = 4  THE STEP IS AT THE LOWER BOUND STPMIN.
'
'    INFO = 5  THE STEP IS AT THE UPPER BOUND STPMAX.
'
'    INFO = 6  ROUNDING ERRORS PREVENT FURTHER PROGRESS.
'              THERE MAY NOT BE A STEP WHICH SATISFIES THE
'              SUFFICIENT DECREASE AND CURVATURE CONDITIONS.
'              TOLERANCES MAY BE TOO SMALL.
'
'NFEV IS AN INTEGER OUTPUT VARIABLE SET TO THE NUMBER OF CALLS TO FCN.
'
'WA IS A WORK ARRAY OF LENGTH N.
'
'ARGONNE NATIONAL LABORATORY. MINPACK PROJECT. JUNE 1983
'JORGE J. MORE', DAVID J. THUENTE
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub MNLMCSRCH(ByRef N As Long, _
         ByRef X() As Double, _
         ByRef F As Double, _
         ByRef G() As Double, _
         ByRef S() As Double, _
         ByRef Stp As Double, _
         ByRef Info As Long, _
         ByRef NFEV As Long, _
         ByRef WA() As Double, _
         ByRef State As LOGITMCState, _
         ByRef Stage As Long)
    Dim V As Double
    Dim P5 As Double
    Dim P66 As Double
    Dim ZERO As Double
    Dim i_ As Long
    
    '
    ' init
    '
    P5 = 0.5
    P66 = 0.66
    State.XTRAPF = 4#
    ZERO = 0#
    
    '
    ' Main cycle
    '
    Do While True
        If Stage = 0# Then
            
            '
            ' NEXT
            '
            Stage = 2#
            GoTo Cont_1
        End If
        If Stage = 2# Then
            State.INFOC = 1#
            Info = 0#
            
            '
            '     CHECK THE INPUT PARAMETERS FOR ERRORS.
            '
            If N <= 0# Or Stp <= 0# Or FTOL < 0# Or GTOL < ZERO Or XTOL < ZERO Or STPMIN < ZERO Or StpMax < STPMIN Or MAXFEV <= 0# Then
                Stage = 0#
                Exit Sub
            End If
            
            '
            '     COMPUTE THE INITIAL GRADIENT IN THE SEARCH DIRECTION
            '     AND CHECK THAT S IS A DESCENT DIRECTION.
            '
            V = 0#
            For i_ = 0# To N - 1# Step 1
                V = V + G(i_) * S(i_)
            Next i_
            State.DGInit = V
            If State.DGInit >= 0# Then
                Stage = 0#
                Exit Sub
            End If
            
            '
            '     INITIALIZE LOCAL VARIABLES.
            '
            State.BRACKT = False
            State.STAGE1 = True
            NFEV = 0#
            State.FInit = F
            State.DGTEST = FTOL * State.DGInit
            State.WIDTH = StpMax - STPMIN
            State.WIDTH1 = State.WIDTH / P5
            For i_ = 0# To N - 1# Step 1
                WA(i_) = X(i_)
            Next i_
            
            '
            '     THE VARIABLES STX, FX, DGX CONTAIN THE VALUES OF THE STEP,
            '     FUNCTION, AND DIRECTIONAL DERIVATIVE AT THE BEST STEP.
            '     THE VARIABLES STY, FY, DGY CONTAIN THE VALUE OF THE STEP,
            '     FUNCTION, AND DERIVATIVE AT THE OTHER ENDPOINT OF
            '     THE INTERVAL OF UNCERTAINTY.
            '     THE VARIABLES STP, F, DG CONTAIN THE VALUES OF THE STEP,
            '     FUNCTION, AND DERIVATIVE AT THE CURRENT STEP.
            '
            State.STX = 0#
            State.FX = State.FInit
            State.DGX = State.DGInit
            State.STY = 0#
            State.FY = State.FInit
            State.DGY = State.DGInit
            
            '
            ' NEXT
            '
            Stage = 3#
            GoTo Cont_1
        End If
        If Stage = 3# Then
            
            '
            '     START OF ITERATION.
            '
            '     SET THE MINIMUM AND MAXIMUM STEPS TO CORRESPOND
            '     TO THE PRESENT INTERVAL OF UNCERTAINTY.
            '
            If State.BRACKT Then
                If State.STX < State.STY Then
                    State.STMIN = State.STX
                    State.STMAX = State.STY
                Else
                    State.STMIN = State.STY
                    State.STMAX = State.STX
                End If
            Else
                State.STMIN = State.STX
                State.STMAX = Stp + State.XTRAPF * (Stp - State.STX)
            End If
            
            '
            '        FORCE THE STEP TO BE WITHIN THE BOUNDS STPMAX AND STPMIN.
            '
            If Stp > StpMax Then
                Stp = StpMax
            End If
            If Stp < STPMIN Then
                Stp = STPMIN
            End If
            
            '
            '        IF AN UNUSUAL TERMINATION IS TO OCCUR THEN LET
            '        STP BE THE LOWEST POINT OBTAINED SO FAR.
            '
            If State.BRACKT And (Stp <= State.STMIN Or Stp >= State.STMAX) Or NFEV >= MAXFEV - 1# Or State.INFOC = 0# Or State.BRACKT And State.STMAX - State.STMIN <= XTOL * State.STMAX Then
                Stp = State.STX
            End If
            
            '
            '        EVALUATE THE FUNCTION AND GRADIENT AT STP
            '        AND COMPUTE THE DIRECTIONAL DERIVATIVE.
            '
            For i_ = 0# To N - 1# Step 1
                X(i_) = WA(i_)
            Next i_
            For i_ = 0# To N - 1# Step 1
                X(i_) = X(i_) + Stp * S(i_)
            Next i_
            
            '
            ' NEXT
            '
            Stage = 4#
            Exit Sub
        End If
        If Stage = 4# Then
            Info = 0#
            NFEV = NFEV + 1#
            V = 0#
            For i_ = 0# To N - 1# Step 1
                V = V + G(i_) * S(i_)
            Next i_
            State.DG = V
            State.FTEST1 = State.FInit + Stp * State.DGTEST
            
            '
            '        TEST FOR CONVERGENCE.
            '
            If State.BRACKT And (Stp <= State.STMIN Or Stp >= State.STMAX) Or State.INFOC = 0# Then
                Info = 6#
            End If
            If Stp = StpMax And F <= State.FTEST1 And State.DG <= State.DGTEST Then
                Info = 5#
            End If
            If Stp = STPMIN And (F > State.FTEST1 Or State.DG >= State.DGTEST) Then
                Info = 4#
            End If
            If NFEV >= MAXFEV Then
                Info = 3#
            End If
            If State.BRACKT And State.STMAX - State.STMIN <= XTOL * State.STMAX Then
                Info = 2#
            End If
            If F <= State.FTEST1 And Abs(State.DG) <= -(GTOL * State.DGInit) Then
                Info = 1#
            End If
            
            '
            '        CHECK FOR TERMINATION.
            '
            If Info <> 0# Then
                Stage = 0#
                Exit Sub
            End If
            
            '
            '        IN THE FIRST STAGE WE SEEK A STEP FOR WHICH THE MODIFIED
            '        FUNCTION HAS A NONPOSITIVE VALUE AND NONNEGATIVE DERIVATIVE.
            '
            If State.STAGE1 And F <= State.FTEST1 And State.DG >= MinReal(FTOL, GTOL) * State.DGInit Then
                State.STAGE1 = False
            End If
            
            '
            '        A MODIFIED FUNCTION IS USED TO PREDICT THE STEP ONLY IF
            '        WE HAVE NOT OBTAINED A STEP FOR WHICH THE MODIFIED
            '        FUNCTION HAS A NONPOSITIVE FUNCTION VALUE AND NONNEGATIVE
            '        DERIVATIVE, AND IF A LOWER FUNCTION VALUE HAS BEEN
            '        OBTAINED BUT THE DECREASE IS NOT SUFFICIENT.
            '
            If State.STAGE1 And F <= State.FX And F > State.FTEST1 Then
                
                '
                '           DEFINE THE MODIFIED FUNCTION AND DERIVATIVE VALUES.
                '
                State.FM = F - Stp * State.DGTEST
                State.FXM = State.FX - State.STX * State.DGTEST
                State.FYM = State.FY - State.STY * State.DGTEST
                State.DGM = State.DG - State.DGTEST
                State.DGXM = State.DGX - State.DGTEST
                State.DGYM = State.DGY - State.DGTEST
                
                '
                '           CALL CSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
                '           AND TO COMPUTE THE NEW STEP.
                '
                Call MNLMCSTEP(State.STX, State.FXM, State.DGXM, State.STY, State.FYM, State.DGYM, Stp, State.FM, State.DGM, State.BRACKT, State.STMIN, State.STMAX, State.INFOC)
                
                '
                '           RESET THE FUNCTION AND GRADIENT VALUES FOR F.
                '
                State.FX = State.FXM + State.STX * State.DGTEST
                State.FY = State.FYM + State.STY * State.DGTEST
                State.DGX = State.DGXM + State.DGTEST
                State.DGY = State.DGYM + State.DGTEST
            Else
                
                '
                '           CALL MCSTEP TO UPDATE THE INTERVAL OF UNCERTAINTY
                '           AND TO COMPUTE THE NEW STEP.
                '
                Call MNLMCSTEP(State.STX, State.FX, State.DGX, State.STY, State.FY, State.DGY, Stp, F, State.DG, State.BRACKT, State.STMIN, State.STMAX, State.INFOC)
            End If
            
            '
            '        FORCE A SUFFICIENT DECREASE IN THE SIZE OF THE
            '        INTERVAL OF UNCERTAINTY.
            '
            If State.BRACKT Then
                If Abs(State.STY - State.STX) >= P66 * State.WIDTH1 Then
                    Stp = State.STX + P5 * (State.STY - State.STX)
                End If
                State.WIDTH1 = State.WIDTH
                State.WIDTH = Abs(State.STY - State.STX)
            End If
            
            '
            '  NEXT.
            '
            Stage = 3#
            GoTo Cont_1
        End If
Cont_1:
    Loop
End Sub
Private Sub MNLMCSTEP(ByRef STX As Double, _
         ByRef FX As Double, _
         ByRef DX As Double, _
         ByRef STY As Double, _
         ByRef FY As Double, _
         ByRef DY As Double, _
         ByRef Stp As Double, _
         ByRef FP As Double, _
         ByRef DP As Double, _
         ByRef BRACKT As Boolean, _
         ByRef STMIN As Double, _
         ByRef STMAX As Double, _
         ByRef Info As Long)
    Dim BOUND As Boolean
    Dim Gamma As Double
    Dim p As Double
    Dim q As Double
    Dim R As Double
    Dim S As Double
    Dim SGND As Double
    Dim STPC As Double
    Dim STPF As Double
    Dim STPQ As Double
    Dim Theta As Double
    Info = 0#
    
    '
    '     CHECK THE INPUT PARAMETERS FOR ERRORS.
    '
    If BRACKT And (Stp <= MinReal(STX, STY) Or Stp >= MaxReal(STX, STY)) Or DX * (Stp - STX) >= 0# Or STMAX < STMIN Then
        Exit Sub
    End If
    
    '
    '     DETERMINE IF THE DERIVATIVES HAVE OPPOSITE SIGN.
    '
    SGND = DP * (DX / Abs(DX))
    
    '
    '     FIRST CASE. A HIGHER FUNCTION VALUE.
    '     THE MINIMUM IS BRACKETED. IF THE CUBIC STEP IS CLOSER
    '     TO STX THAN THE QUADRATIC STEP, THE CUBIC STEP IS TAKEN,
    '     ELSE THE AVERAGE OF THE CUBIC AND QUADRATIC STEPS IS TAKEN.
    '
    If FP > FX Then
        Info = 1#
        BOUND = True
        Theta = 3# * (FX - FP) / (Stp - STX) + DX + DP
        S = MaxReal(Abs(Theta), MaxReal(Abs(DX), Abs(DP)))
        Gamma = S * Sqr(Square(Theta / S) - DX / S * (DP / S))
        If Stp < STX Then
            Gamma = -Gamma
        End If
        p = Gamma - DX + Theta
        q = Gamma - DX + Gamma + DP
        R = p / q
        STPC = STX + R * (Stp - STX)
        STPQ = STX + DX / ((FX - FP) / (Stp - STX) + DX) / 2# * (Stp - STX)
        If Abs(STPC - STX) < Abs(STPQ - STX) Then
            STPF = STPC
        Else
            STPF = STPC + (STPQ - STPC) / 2#
        End If
        BRACKT = True
    Else
        If SGND < 0# Then
            
            '
            '     SECOND CASE. A LOWER FUNCTION VALUE AND DERIVATIVES OF
            '     OPPOSITE SIGN. THE MINIMUM IS BRACKETED. IF THE CUBIC
            '     STEP IS CLOSER TO STX THAN THE QUADRATIC (SECANT) STEP,
            '     THE CUBIC STEP IS TAKEN, ELSE THE QUADRATIC STEP IS TAKEN.
            '
            Info = 2#
            BOUND = False
            Theta = 3# * (FX - FP) / (Stp - STX) + DX + DP
            S = MaxReal(Abs(Theta), MaxReal(Abs(DX), Abs(DP)))
            Gamma = S * Sqr(Square(Theta / S) - DX / S * (DP / S))
            If Stp > STX Then
                Gamma = -Gamma
            End If
            p = Gamma - DP + Theta
            q = Gamma - DP + Gamma + DX
            R = p / q
            STPC = Stp + R * (STX - Stp)
            STPQ = Stp + DP / (DP - DX) * (STX - Stp)
            If Abs(STPC - Stp) > Abs(STPQ - Stp) Then
                STPF = STPC
            Else
                STPF = STPQ
            End If
            BRACKT = True
        Else
            If Abs(DP) < Abs(DX) Then
                
                '
                '     THIRD CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
                '     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DECREASES.
                '     THE CUBIC STEP IS ONLY USED IF THE CUBIC TENDS TO INFINITY
                '     IN THE DIRECTION OF THE STEP OR IF THE MINIMUM OF THE CUBIC
                '     IS BEYOND STP. OTHERWISE THE CUBIC STEP IS DEFINED TO BE
                '     EITHER STPMIN OR STPMAX. THE QUADRATIC (SECANT) STEP IS ALSO
                '     COMPUTED AND IF THE MINIMUM IS BRACKETED THEN THE THE STEP
                '     CLOSEST TO STX IS TAKEN, ELSE THE STEP FARTHEST AWAY IS TAKEN.
                '
                Info = 3#
                BOUND = True
                Theta = 3# * (FX - FP) / (Stp - STX) + DX + DP
                S = MaxReal(Abs(Theta), MaxReal(Abs(DX), Abs(DP)))
                
                '
                '        THE CASE GAMMA = 0 ONLY ARISES IF THE CUBIC DOES NOT TEND
                '        TO INFINITY IN THE DIRECTION OF THE STEP.
                '
                Gamma = S * Sqr(MaxReal(0#, Square(Theta / S) - DX / S * (DP / S)))
                If Stp > STX Then
                    Gamma = -Gamma
                End If
                p = Gamma - DP + Theta
                q = Gamma + (DX - DP) + Gamma
                R = p / q
                If R < 0# And Gamma <> 0# Then
                    STPC = Stp + R * (STX - Stp)
                Else
                    If Stp > STX Then
                        STPC = STMAX
                    Else
                        STPC = STMIN
                    End If
                End If
                STPQ = Stp + DP / (DP - DX) * (STX - Stp)
                If BRACKT Then
                    If Abs(Stp - STPC) < Abs(Stp - STPQ) Then
                        STPF = STPC
                    Else
                        STPF = STPQ
                    End If
                Else
                    If Abs(Stp - STPC) > Abs(Stp - STPQ) Then
                        STPF = STPC
                    Else
                        STPF = STPQ
                    End If
                End If
            Else
                
                '
                '     FOURTH CASE. A LOWER FUNCTION VALUE, DERIVATIVES OF THE
                '     SAME SIGN, AND THE MAGNITUDE OF THE DERIVATIVE DOES
                '     NOT DECREASE. IF THE MINIMUM IS NOT BRACKETED, THE STEP
                '     IS EITHER STPMIN OR STPMAX, ELSE THE CUBIC STEP IS TAKEN.
                '
                Info = 4#
                BOUND = False
                If BRACKT Then
                    Theta = 3# * (FP - FY) / (STY - Stp) + DY + DP
                    S = MaxReal(Abs(Theta), MaxReal(Abs(DY), Abs(DP)))
                    Gamma = S * Sqr(Square(Theta / S) - DY / S * (DP / S))
                    If Stp > STY Then
                        Gamma = -Gamma
                    End If
                    p = Gamma - DP + Theta
                    q = Gamma - DP + Gamma + DY
                    R = p / q
                    STPC = Stp + R * (STY - Stp)
                    STPF = STPC
                Else
                    If Stp > STX Then
                        STPF = STMAX
                    Else
                        STPF = STMIN
                    End If
                End If
            End If
        End If
    End If
    
    '
    '     UPDATE THE INTERVAL OF UNCERTAINTY. THIS UPDATE DOES NOT
    '     DEPEND ON THE NEW STEP OR THE CASE ANALYSIS ABOVE.
    '
    If FP > FX Then
        STY = Stp
        FY = FP
        DY = DP
    Else
        If SGND < 0# Then
            STY = STX
            FY = FX
            DY = DX
        End If
        STX = Stp
        FX = FP
        DX = DP
    End If
    
    '
    '     COMPUTE THE NEW STEP AND SAFEGUARD IT.
    '
    STPF = MinReal(STMAX, STPF)
    STPF = MaxReal(STMIN, STPF)
    Stp = STPF
    If BRACKT And BOUND Then
        If STY > STX Then
            Stp = MinReal(STX + 0.66 * (STY - STX), Stp)
        Else
            Stp = MaxReal(STX + 0.66 * (STY - STX), Stp)
        End If
    End If
End Sub

