''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee.  All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
Public Sub HermitianMatrixVectorMultiply(ByRef A() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Complex, _
         ByRef Alpha_ As Complex, _
         ByRef Y() As Complex)
    Dim Alpha As Complex
    Dim I As Long
    Dim BA1 As Long
    Dim BA2 As Long
    Dim BY1 As Long
    Dim BY2 As Long
    Dim BX1 As Long
    Dim BX2 As Long
    Dim N As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    Alpha = Alpha_
    N = I2 - I1 + 1#
    If N <= 0# Then
        Exit Sub
    End If
    
    '
    ' Let A = L + D + U, where
    '  L is strictly lower triangular (main diagonal is zero)
    '  D is diagonal
    '  U is strictly upper triangular (main diagonal is zero)
    '
    ' A*x = L*x + D*x + U*x
    '
    ' Calculate D*x first
    '
    For I = I1 To I2 Step 1
        Y(I - I1 + 1#) = C_Mul(A(I, I), X(I - I1 + 1#))
    Next I
    
    '
    ' Add L*x + U*x
    '
    If IsUpper Then
        For I = I1 To I2 - 1# Step 1
            
            '
            ' Add L*x to the result
            '
            V = X(I - I1 + 1#)
            BY1 = I - I1 + 2#
            BY2 = N
            BA1 = I + 1#
            BA2 = I2
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                Y(i_) = C_Add(Y(i_), C_Mul(V, Conj(A(I, i_ + i1_))))
            Next i_
            
            '
            ' Add U*x to the result
            '
            BX1 = I - I1 + 2#
            BX2 = N
            BA1 = I + 1#
            BA2 = I2
            i1_ = (BA1) - (BX1)
            V = C_Complex(0#)
            For i_ = BX1 To BX2 Step 1
                V = C_Add(V, C_Mul(X(i_), A(I, i_ + i1_)))
            Next i_
            Y(I - I1 + 1#) = C_Add(Y(I - I1 + 1#), V)
        Next I
    Else
        For I = I1 + 1# To I2 Step 1
            
            '
            ' Add L*x to the result
            '
            BX1 = 1#
            BX2 = I - I1
            BA1 = I1
            BA2 = I - 1#
            i1_ = (BA1) - (BX1)
            V = C_Complex(0#)
            For i_ = BX1 To BX2 Step 1
                V = C_Add(V, C_Mul(X(i_), A(I, i_ + i1_)))
            Next i_
            Y(I - I1 + 1#) = C_Add(Y(I - I1 + 1#), V)
            
            '
            ' Add U*x to the result
            '
            V = X(I - I1 + 1#)
            BY1 = 1#
            BY2 = I - I1
            BA1 = I1
            BA2 = I - 1#
            i1_ = (BA1) - (BY1)
            For i_ = BY1 To BY2 Step 1
                Y(i_) = C_Add(Y(i_), C_Mul(V, Conj(A(I, i_ + i1_))))
            Next i_
        Next I
    End If
    For i_ = 1# To N Step 1
        Y(i_) = C_Mul(Alpha, Y(i_))
    Next i_
End Sub
Public Sub HermitianRank2Update(ByRef A() As Complex, _
         ByVal IsUpper As Boolean, _
         ByVal I1 As Long, _
         ByVal I2 As Long, _
         ByRef X() As Complex, _
         ByRef Y() As Complex, _
         ByRef T() As Complex, _
         ByRef Alpha_ As Complex)
    Dim Alpha As Complex
    Dim I As Long
    Dim TP1 As Long
    Dim TP2 As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    Alpha = Alpha_
    If IsUpper Then
        For I = I1 To I2 Step 1
            TP1 = I + 1# - I1
            TP2 = I2 - I1 + 1#
            V = C_Mul(Alpha, X(I + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Mul(V, Conj(Y(i_)))
            Next i_
            V = C_Mul(Conj(Alpha), Y(I + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Add(T(i_), C_Mul(V, Conj(X(i_))))
            Next i_
            i1_ = (TP1) - (I)
            For i_ = I To I2 Step 1
                A(I, i_) = C_Add(A(I, i_), T(i_ + i1_))
            Next i_
        Next I
    Else
        For I = I1 To I2 Step 1
            TP1 = 1#
            TP2 = I + 1# - I1
            V = C_Mul(Alpha, X(I + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Mul(V, Conj(Y(i_)))
            Next i_
            V = C_Mul(Conj(Alpha), Y(I + 1# - I1))
            For i_ = TP1 To TP2 Step 1
                T(i_) = C_Add(T(i_), C_Mul(V, Conj(X(i_))))
            Next i_
            i1_ = (TP1) - (I1)
            For i_ = I1 To I Step 1
                A(I, i_) = C_Add(A(I, i_), T(i_ + i1_))
            Next i_
        Next I
    End If
End Sub
