'=======================================================================================
'Unifloc 7.12  Apodemus agrarius                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
'
Option Explicit
' Класс описывающий траекторию скважины. Содержит методы для работы с инклинометрией
' На вход подаются данные по конструкции скважины в исходном виде (из базы данных)
' На выходе могут быть получены данные пригодные для проведения расчетов с использованием класса скважины
'
'
'
'
' История
' 2016.01.18    Хабибуллин Ринат
'
'
'
' тип описывающий полную конструкцию скважины в заданной точке
Private Type WELL_POINT_FULL
    h_mes_m As Double  ' измеренная глубина
    ang_deg As Double ' угол  от вертикали
    h_abs_m As Double  ' абсолютная глубина
    DcasIn_m As Double  ' диаметр эксплуатационной колонны, внутренний
    DtubIn_m As Double  ' диаметр НКТ внутренний
    DtubOut_m As Double ' диаметр НКТ внешний
    roughness_cas_m As Double    ' шероховатость
    roughness_tub_m As Double    ' шероховатость
End Type
Private h_abs_init_m_ As New CInterpolation      ' исходный массив абсолютных глубин
Private angle_init_deg_ As New CInterpolation    ' исходный массив углов
'Private angle_azimuth_init_deg_ As New CInterpolation ' значения азимутального угла
'Private angle_zenith_init_deg_ As New CInterpolation  ' значения зенитного угла
Private d_cas_init_m_ As New CInterpolation  ' исходный массив значений диаметров эксплуатационных колонн
Private d_tub_init_m_ As New CInterpolation  ' исходный массив значений диаметров НКТ
Private tub_thickness_mm_ '           пока считаем что НКТ всегда имеет одинаковую толщину - потом можно будет учесть
Private roughness_m_ '           пока также считаем, что шероховатость везде тоже одинакова
Private well_trajctory_() As WELL_POINT_FULL   ' полная конструкция скважины пригодная для расчетов - итоговое свойство класса
'Private h_perf_m_ As Double    ' perforation depth aka reservoir depth
'Private h_tubing_m_ As Double  ' tubing setting depth - same as pump setting depth in most cases
Private num_points_out_ As Integer   ' количество точек в выходном массиве
Private length_between_points_m_ As Double  ' мин растояние между точками при генерации исходного массива
Private construction_points_curve_ As New CInterpolation  ' точки которые должны быть добавлены (измеренная глубина - абсолютная глубина)
Private h_points_curve_ As New CInterpolation    ' результирующие точки для заполнения массивов
'Private h_valve_GL_m_() As Double     ' массив глубин расположения газлифтных клапанов
'Private num_valves_ As Integer        ' количество клапанов газлифтных
Private Sub Class_Initialize()
' установка значений по умолчанию
  tub_thickness_mm_ = 10
  roughness_m_ = 0.0001
  length_between_points_m_ = 100     ' по умолчанию ставим расстояние между точками инклинометрии 100 м
  h_abs_init_m_.isStepFunction = False   ' абсолютные глубины линейно интерполируются
  angle_init_deg_.isStepFunction = True   ' углы - ступенчатая функция
  d_cas_init_m_.isStepFunction = True   ' диаметры - ступенчатая функция
  d_tub_init_m_.isStepFunction = True   ' диаметры - ступенчатая функция
End Sub
'Public Property Get num_valves() As Integer
'    num_valves = num_valves_
'End Property
'
'Public Sub clear_valves()
'    ReDim h_valve_GL_m_(0)
'    num_valves_ = 0
'End Sub
'Public Sub add_valve(Hvalve)
'    num_valves_ = num_valves_ + 1
'    ReDim Preserve h_valve_GL_m_(num_valves_)
'    h_valve_GL_m_(num_valves_) = Hvalve
'End Sub
Public Sub init_trajectory_h_abs(ByVal HabsCurve_m As CInterpolation, _
                              ByVal DcasCurve_mm As CInterpolation, _
                              ByVal DtubCurve_mm As CInterpolation)
                              ', _
                              'ByVal h_perf_m As Double, _
                              'ByVal h_tubing_m As Double)
                              ', _
                              'Optional ValveSet As CGLValveSet = Nothing)
' trajctory init based on vertical depth data (absolute depth)
'
'
' HabsCurve_m  - кривая значений абсолютных глубин относительно измеренных глубин (траектория упрощенная)
' DtubCurve_mm  - кривая значений диаматров НКТ
' DcasCurve_mm  - кривая значений диаметров эксплуатационной колонны
'
 Dim i As Integer
 Dim ang
 Dim sina As Double, cosa As Double
 
' h_perf_m_ = h_perf_m
' h_tubing_m_ = h_tubing_m
 angle_init_deg_.ClearPoints
 
 ' насос обязательно должен быть выше перфорации
' If h_tubing_m_ >= h_perf_m_ Then
'    h_tubing_m_ = h_perf_m_ '- const_ESP_length - 1   ' насос должен быть выше перфорации
' End If
'
 Set h_abs_init_m_ = HabsCurve_m
 Set d_tub_init_m_ = DtubCurve_mm.Transform(multY:=const_convert_mm_m)
 
 ' поправим кривую для НКТ - вставим принудительно точку глубины спука насоса и ниже ее диаметры занулим
 DtubCurve_mm.isStepFunction = True
' d_tub_init_m_.AddPoint h_tubing_m_, DtubCurve_mm.getPoint(h_tubing_m_)     ' добавляем значение глубины спуска НКТ в компоновку НКТ
'
' ' check - if tubing goes below pump setting depth - make tubing diameter zero below Hpump
' If d_tub_init_m_.maxx > h_tubing_m_ Then
'    For i = 1 To d_tub_init_m_.num_points
'        If d_tub_init_m_.pointX(i) > h_tubing_m_ Then
'            d_tub_init_m_.AddPoint d_tub_init_m_.pointX(i), 0
'        End If
'    Next i
' End If
 
 Set d_cas_init_m_ = DcasCurve_mm.Transform(multY:=const_convert_mm_m)
 d_cas_init_m_.isStepFunction = True   ' диаметры - ступенчатая функция
 d_tub_init_m_.isStepFunction = True   ' диаметры - ступенчатая функция
 
 For i = 2 To HabsCurve_m.num_points
    sina = (HabsCurve_m.PointY(i) - HabsCurve_m.PointY(i - 1)) / (HabsCurve_m.pointX(i) - HabsCurve_m.pointX(i - 1))
    cosa = Sqr(MaxReal(1 - sina ^ 2, 0))
    If cosa = 0 Then
        ang = 90
    Else
        ang = Atn(sina / cosa) * 180 / const_Pi
    End If
    angle_init_deg_.AddPoint HabsCurve_m.pointX(i - 1), ang
 Next i
 
 calc_trajectory
 
End Sub
Private Function calc_trajectory() As Boolean
' функция расчета траектории скважины - из исходных данных считает нормализованные выходные данные и готовит данные для скважины
 Dim i As Integer
 Dim allDone As Boolean
 Dim i_constrPoint As Integer
 Dim Hmes As Double, HmesNext As Double
 Call FillConstructionPoints     ' заполним все необходимые точки, которые надо добавить в конструкцию
  
 Hmes = 0
 i = 0
 i_constrPoint = 1
 allDone = False
 
 ' начинаем цикл, в котором формируем набор точек из которых должна состоять траетория скважины
 ' учитывая минимальное расстояние между точками и присутствие в списке всех обязательных точек
 Do
    HmesNext = Hmes + length_between_points_m_    ' смотрим куда должна попасть след точка
    
    If construction_points_curve_.pointX(i_constrPoint) < HmesNext Then
        Hmes = construction_points_curve_.pointX(i_constrPoint)
        i_constrPoint = i_constrPoint + 1
    Else
        Hmes = HmesNext
    End If
 
    If Hmes >= construction_points_curve_.maxx Then
        Hmes = construction_points_curve_.maxx
        allDone = True
    End If
    h_points_curve_.AddPoint Hmes, h_abs_init_m_.getPoint(Hmes)   ' сохраняем измеренную и абсолютную глубины тут
 Loop Until allDone
 ' набор точек для траектории сформирован
 
 ' дальше надо по данному набору заполнить все элементы массива конструкции
 
 ReDim well_trajctory_(h_points_curve_.num_points - 1)
 For i = 0 To h_points_curve_.num_points - 1
    Hmes = h_points_curve_.pointX(i + 1)
    With well_trajctory_(i)
        .h_mes_m = Hmes
        .h_abs_m = h_points_curve_.PointY(i + 1)
        .ang_deg = angle_init_deg_.getPoint(Hmes)
        .DcasIn_m = d_cas_init_m_.getPoint(Hmes)
        .DtubIn_m = d_tub_init_m_.getPoint(Hmes)
        .DtubOut_m = d_tub_init_m_.getPoint(Hmes) + tub_thickness_mm_ * const_convert_mm_m
        .roughness_cas_m = roughness_m_
        .roughness_tub_m = roughness_m_
    End With
 Next i
 ' траекторию сформировали
 ' надо теперь подготовить массивы для класса скважина
End Function
Private Sub FillConstructionPoints()
    Dim i As Integer
    Dim h As Double
    
    construction_points_curve_.ClearPoints
    construction_points_curve_.AddPoint 0, 0   ' на всякий случай добавим в конструкцию нулевую точку из которой стартуем
'    h = h_perf_m_:     construction_points_curve_.AddPoint h, h_abs_init_m_.getPoint(h)
'    h = h_tubing_m_:     construction_points_curve_.AddPoint h, h_abs_init_m_.getPoint(h)
    For i = 1 To d_cas_init_m_.num_points
        h = d_cas_init_m_.pointX(i):      construction_points_curve_.AddPoint h, h_abs_init_m_.getPoint(h)
    Next i
    For i = 1 To d_tub_init_m_.num_points
        h = d_tub_init_m_.pointX(i):      construction_points_curve_.AddPoint h, h_abs_init_m_.getPoint(h)
    Next i
    
    ' если надо тут надо добавить другие точки в конструкцию, например газлифтные клапана, глубины установки оборудования
    ' также тут хорошо бы проверить потенциальные ошибки - отсутствие точек и тому подобное
End Sub
'Public Property Get h_tubing_m() As Double
'    h_tubing_m = h_tubing_m_
'End Property
'Public Property Get h_perf_m() As Double
'    h_perf_m = h_perf_m_
'End Property
'Public Property Get h_perf_vert_m() As Double
'    h_perf_vert_m = h_abs_hmes_m(h_perf_m_)
'End Property
Public Property Get num_points() As Integer
    num_points = h_points_curve_.num_points
End Property
Public Property Get ang_deg(i As Integer) As Double
    ang_deg = well_trajctory_(i).ang_deg
End Property
Public Property Get ang_hmes_deg(h_mes_m As Double) As Double
    ang_hmes_deg = angle_init_deg_.getPoint(h_mes_m)
End Property
Public Property Get h_mes_m(i As Integer) As Double
    h_mes_m = well_trajctory_(i).h_mes_m
End Property
Public Property Get h_abs_m(i As Integer) As Double
    h_abs_m = well_trajctory_(i).h_abs_m
End Property
Public Property Get h_abs_hmes_m(ByVal h_mes_m As Double) As Double
    h_abs_hmes_m = h_points_curve_.getPoint(h_mes_m)
End Property
Public Property Get d_cas_m(i As Integer) As Double
    d_cas_m = well_trajctory_(i).DcasIn_m
End Property
Public Property Get d_cas_hmes_m(h_mes_m As Double) As Double
    d_cas_hmes_m = d_cas_init_m_.getPoint(h_mes_m)
End Property
Public Property Get d_tub_m(i As Integer) As Double
    d_tub_m = well_trajctory_(i).DtubIn_m
End Property
Public Property Get d_tub_hmes_m(h_mes_m As Double) As Double
    d_tub_hmes_m = d_tub_init_m_.getPoint(h_mes_m)
End Property
Public Property Get roughness_cas_m(i As Integer) As Double
    roughness_cas_m = well_trajctory_(i).roughness_cas_m
End Property
Public Property Get roughness_cas_hmes_m(h_mes_m As Double) As Double
    roughness_cas_hmes_m = roughness_m_
End Property
Public Property Get roughness_tub_m(i As Integer) As Double
    roughness_tub_m = well_trajctory_(i).roughness_tub_m
End Property
Public Property Get roughness_tub_hmes_m(h_mes_m As Double) As Double
    roughness_tub_hmes_m = roughness_m_
End Property

