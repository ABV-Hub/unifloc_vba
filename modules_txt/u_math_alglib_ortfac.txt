''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 2005-2010 Sergey Bochkanov.
'
'Additional copyrights:
'    1992-2007 The University of Tennessee (as indicated in subroutines
'    comments).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'QR decomposition of a rectangular matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and R in compact form (see below).
'    Tau -   array of scalar factors which are used to form
'            matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].
'
'Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.
'
'The elements of matrix R are located on and above the main diagonal of
'matrix A. The elements which are located in Tau array and below the main
'diagonal of matrix A are used to form matrix Q as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(0)*H(2)*...*H(k-1),
'
'where k = min(m,n), and each H(i) is in the form
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - real vector,
'so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQR(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASBlockSize(A) - 1, 0 To N - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASBlockSize(A) Then
            BlockSize = ABLASBlockSize(A)
        End If
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call RMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call RMatrixQRBaseCase(TmpA, RowsCount, BlockSize, WORK, T, TauBuf)
        Call RMatrixCopy(RowsCount, BlockSize, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= N - 1# Then
            If N - BlockStart - BlockSize >= 2# * ABLASBlockSize(A) Or RowsCount >= 4# * ABLASBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call RMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q'.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
                ' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
                '
                Call RMatrixGEMM(BlockSize, N - BlockStart - BlockSize, RowsCount, 1#, TmpA, 0#, 0#, 1#, A, BlockStart, BlockStart + BlockSize, 0#, 0#, TmpR, 0#, 0#)
                Call RMatrixGEMM(BlockSize, N - BlockStart - BlockSize, BlockSize, 1#, TmpT, 0#, 0#, 1#, TmpR, 0#, 0#, 0#, 0#, TmpR, BlockSize, 0#)
                Call RMatrixGEMM(RowsCount, N - BlockStart - BlockSize, BlockSize, 1#, TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, 1#, A, BlockStart, BlockStart + BlockSize)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To RowsCount - i Step 1
                        T(i_) = TmpA(i_ + i1_, i)
                    Next i_
                    T(1#) = 1#
                    Call ApplyReflectionFromTheLeft(A, TauBuf(i), T, BlockStart + i, M - 1#, BlockStart + BlockSize, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LQ decomposition of a rectangular matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices L and Q in compact form (see below)
'    Tau -   array of scalar factors which are used to form
'            matrix Q. Array whose index ranges within [0..Min(M,N)-1].
'
'Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.
'
'The elements of matrix L are located on and below  the  main  diagonal  of
'matrix A. The elements which are located in Tau array and above  the  main
'diagonal of matrix A are used to form matrix Q as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(k-1)*H(k-2)*...*H(1)*H(0),
'
'where k = min(m,n), and each H(i) is of the form
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
'v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQ(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To M - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASBlockSize(A) Then
            BlockSize = ABLASBlockSize(A)
        End If
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call RMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call RMatrixLQBaseCase(TmpA, BlockSize, ColumnsCount, WORK, T, TauBuf)
        Call RMatrixCopy(BlockSize, ColumnsCount, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= M - 1# Then
            If M - BlockStart - BlockSize >= 2# * ABLASBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call RMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
                '
                Call RMatrixGEMM(M - BlockStart - BlockSize, BlockSize, ColumnsCount, 1#, A, BlockStart + BlockSize, BlockStart, 0#, TmpA, 0#, 0#, 1#, 0#, TmpR, 0#, 0#)
                Call RMatrixGEMM(M - BlockStart - BlockSize, BlockSize, BlockSize, 1#, TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 0#, 0#, TmpR, 0#, BlockSize)
                Call RMatrixGEMM(M - BlockStart - BlockSize, ColumnsCount, BlockSize, 1#, TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, 1#, A, BlockStart + BlockSize, BlockStart)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To ColumnsCount - i Step 1
                        T(i_) = TmpA(i, i_ + i1_)
                    Next i_
                    T(1#) = 1#
                    Call ApplyReflectionFromTheRight(A, TauBuf(i), T, BlockStart + BlockSize, M - 1#, BlockStart + i, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'QR decomposition of a rectangular complex matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and R in compact form
'    Tau -   array of scalar factors which are used to form matrix Q. Array
'            whose indexes range within [0.. Min(M,N)-1]
'
'Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
'MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQR(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASComplexBlockSize(A) - 1, 0 To N - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASComplexBlockSize(A) Then
            BlockSize = ABLASComplexBlockSize(A)
        End If
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call CMatrixQRBaseCase(TmpA, RowsCount, BlockSize, WORK, T, TauBuf)
        Call CMatrixCopy(RowsCount, BlockSize, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= N - 1# Then
            If N - BlockStart - BlockSize >= 2# * ABLASComplexBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call CMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q'.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
                ' Q' = E + Y*T'*Y' = E + TmpA*TmpT'*TmpA'
                '
                Call CMatrixGEMM(BlockSize, N - BlockStart - BlockSize, RowsCount, C_Complex(1#), TmpA, 0#, 0#, 2#, A, BlockStart, BlockStart + BlockSize, 0#, C_Complex(0#), TmpR, 0#, 0#)
                Call CMatrixGEMM(BlockSize, N - BlockStart - BlockSize, BlockSize, C_Complex(1#), TmpT, 0#, 0#, 2#, TmpR, 0#, 0#, 0#, C_Complex(0#), TmpR, BlockSize, 0#)
                Call CMatrixGEMM(RowsCount, N - BlockStart - BlockSize, BlockSize, C_Complex(1#), TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, C_Complex(1#), A, BlockStart, BlockStart + BlockSize)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To RowsCount - i Step 1
                        T(i_) = TmpA(i_ + i1_, i)
                    Next i_
                    T(1#) = C_Complex(1#)
                    Call ComplexApplyReflectionFromTheLeft(A, Conj(TauBuf(i)), T, BlockStart + i, M - 1#, BlockStart + BlockSize, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'LQ decomposition of a rectangular complex matrix of size MxN
'
'Input parameters:
'    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
'    M   -   number of rows in matrix A.
'    N   -   number of columns in matrix A.
'
'Output parameters:
'    A   -   matrices Q and L in compact form
'    Tau -   array of scalar factors which are used to form matrix Q. Array
'            whose indexes range within [0.. Min(M,N)-1]
'
'Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
'MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQ(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim Tau(0 To MinMN - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASComplexBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To M - 1, 0 To 2# * ABLASComplexBlockSize(A) - 1)
    
    '
    ' Blocked code
    '
    BlockStart = 0#
    Do While BlockStart <> MinMN
        
        '
        ' Determine block size
        '
        BlockSize = MinMN - BlockStart
        If BlockSize > ABLASComplexBlockSize(A) Then
            BlockSize = ABLASComplexBlockSize(A)
        End If
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        Call CMatrixLQBaseCase(TmpA, BlockSize, ColumnsCount, WORK, T, TauBuf)
        Call CMatrixCopy(BlockSize, ColumnsCount, TmpA, 0#, 0#, A, BlockStart, BlockStart)
        i1_ = (0#) - (BlockStart)
        For i_ = BlockStart To BlockStart + BlockSize - 1# Step 1
            Tau(i_) = TauBuf(i_ + i1_)
        Next i_
        
        '
        ' Update the rest, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If BlockStart + BlockSize <= M - 1# Then
            If M - BlockStart - BlockSize >= 2# * ABLASComplexBlockSize(A) Then
                
                '
                ' Prepare block reflector
                '
                Call CMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
                
                '
                ' Multiply the rest of A by Q.
                '
                ' Q  = E + Y*T*Y'  = E + TmpA'*TmpT*TmpA
                '
                Call CMatrixGEMM(M - BlockStart - BlockSize, BlockSize, ColumnsCount, C_Complex(1#), A, BlockStart + BlockSize, BlockStart, 0#, TmpA, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, 0#)
                Call CMatrixGEMM(M - BlockStart - BlockSize, BlockSize, BlockSize, C_Complex(1#), TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 0#, C_Complex(0#), TmpR, 0#, BlockSize)
                Call CMatrixGEMM(M - BlockStart - BlockSize, ColumnsCount, BlockSize, C_Complex(1#), TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, C_Complex(1#), A, BlockStart + BlockSize, BlockStart)
            Else
                
                '
                ' Level 2 algorithm
                '
                For i = 0# To BlockSize - 1# Step 1
                    i1_ = (i) - (1#)
                    For i_ = 1# To ColumnsCount - i Step 1
                        T(i_) = Conj(TmpA(i, i_ + i1_))
                    Next i_
                    T(1#) = C_Complex(1#)
                    Call ComplexApplyReflectionFromTheRight(A, TauBuf(i), T, BlockStart + BlockSize, M - 1#, BlockStart + i, N - 1#, WORK)
                Next i
            End If
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart + BlockSize
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of RMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'    Tau     -   scalar factors which are used to form Q.
'                Output of the RMatrixQR subroutine.
'    QColumns -  required number of columns of matrix Q. M>=QColumns>=0.
'
'Output parameters:
'    Q       -   first QColumns columns of matrix Q.
'                Array whose indexes range within [0..M-1, 0..QColumns-1].
'                If QColumns=0, the array remains unchanged.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQRUnpackQ(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByVal QColumns As Long, _
         ByRef Q() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or QColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QColumns)
    ReDim Q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For J = 0# To QColumns - 1# Step 1
            If i = J Then
                Q(i, J) = 1#
            Else
                Q(i, J) = 0#
            End If
        Next J
    Next i
    ReDim WORK(0 To MaxInt(M, QColumns) + 1# - 1)
    ReDim T(0 To MaxInt(M, QColumns) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASBlockSize(A) - 1, 0 To QColumns - 1)
    
    '
    ' Blocked code
    '
    BlockStart = ABLASBlockSize(A) * (RefCnt \ ABLASBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        RowsCount = M - BlockStart
        
        '
        ' Copy current block
        '
        Call RMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QColumns >= 2# * ABLASBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call RMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply matrix by Q.
            '
            ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
            '
            Call RMatrixGEMM(BlockSize, QColumns, RowsCount, 1#, TmpA, 0#, 0#, 1#, Q, BlockStart, 0#, 0#, 0#, TmpR, 0#, 0#)
            Call RMatrixGEMM(BlockSize, QColumns, BlockSize, 1#, TmpT, 0#, 0#, 0#, TmpR, 0#, 0#, 0#, 0#, TmpR, BlockSize, 0#)
            Call RMatrixGEMM(RowsCount, QColumns, BlockSize, 1#, TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, 1#, Q, BlockStart, 0#)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To RowsCount - i Step 1
                    T(i_) = TmpA(i_ + i1_, i)
                Next i_
                T(1#) = 1#
                Call ApplyReflectionFromTheLeft(Q, TauBuf(i), T, BlockStart + i, M - 1#, 0#, QColumns - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASBlockSize(A)
        BlockSize = ABLASBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix R from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of RMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    R       -   matrix R, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixQRUnpackR(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef R() As Double)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    K = MinInt(M, N)
    ReDim R(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        R(0#, i) = 0#
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            R(i, i_) = R(0#, i_)
        Next i_
    Next i
    For i = 0# To K - 1# Step 1
        For i_ = i To N - 1# Step 1
            R(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices L and Q in compact form.
'                Output of RMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'    Tau     -   scalar factors which are used to form Q.
'                Output of the RMatrixLQ subroutine.
'    QRows   -   required number of rows in matrix Q. N>=QRows>=0.
'
'Output parameters:
'    Q       -   first QRows rows of matrix Q. Array whose indexes range
'                within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
'                unchanged.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQUnpackQ(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByVal QRows As Long, _
         ByRef Q() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim TauBuf() As Double
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Double
    Dim TmpT() As Double
    Dim TmpR() As Double
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or QRows <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QRows)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASBlockSize(A) - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim TmpR(0 To QRows - 1, 0 To 2# * ABLASBlockSize(A) - 1)
    ReDim Q(0 To QRows - 1, 0 To N - 1)
    For i = 0# To QRows - 1# Step 1
        For J = 0# To N - 1# Step 1
            If i = J Then
                Q(i, J) = 1#
            Else
                Q(i, J) = 0#
            End If
        Next J
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASBlockSize(A) * (RefCnt \ ABLASBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        ColumnsCount = N - BlockStart
        
        '
        ' Copy submatrix
        '
        Call RMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QRows >= 2# * ABLASBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call RMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q'.
            '
            ' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
            '
            Call RMatrixGEMM(QRows, BlockSize, ColumnsCount, 1#, Q, 0#, BlockStart, 0#, TmpA, 0#, 0#, 1#, 0#, TmpR, 0#, 0#)
            Call RMatrixGEMM(QRows, BlockSize, BlockSize, 1#, TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 1#, 0#, TmpR, 0#, BlockSize)
            Call RMatrixGEMM(QRows, ColumnsCount, BlockSize, 1#, TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, 1#, Q, 0#, BlockStart)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To ColumnsCount - i Step 1
                    T(i_) = TmpA(i, i_ + i1_)
                Next i_
                T(1#) = 1#
                Call ApplyReflectionFromTheRight(Q, TauBuf(i), T, 0#, QRows - 1#, BlockStart + i, N - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASBlockSize(A)
        BlockSize = ABLASBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix L from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and L in compact form.
'                Output of RMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    L       -   matrix L, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLQUnpackL(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef L() As Double)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    ReDim L(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        L(0#, i) = 0#
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            L(i, i_) = L(0#, i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        K = MinInt(i, N - 1#)
        For i_ = 0# To K Step 1
            L(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from QR decomposition of a complex matrix A.
'
'Input parameters:
'    A           -   matrices Q and R in compact form.
'                    Output of CMatrixQR subroutine .
'    M           -   number of rows in matrix A. M>=0.
'    N           -   number of columns in matrix A. N>=0.
'    Tau         -   scalar factors which are used to form Q.
'                    Output of CMatrixQR subroutine .
'    QColumns    -   required number of columns in matrix Q. M>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QColumns columns of matrix Q.
'                    Array whose index ranges within [0..M-1, 0..QColumns-1].
'                    If QColumns=0, array isn't changed.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQRUnpackQ(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex, _
         ByVal QColumns As Long, _
         ByRef Q() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim RowsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QColumns)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To M - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To 2# * ABLASComplexBlockSize(A) - 1, 0 To QColumns - 1)
    ReDim Q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For J = 0# To QColumns - 1# Step 1
            If i = J Then
                Q(i, J) = C_Complex(1#)
            Else
                Q(i, J) = C_Complex(0#)
            End If
        Next J
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASComplexBlockSize(A) * (RefCnt \ ABLASComplexBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        RowsCount = M - BlockStart
        
        '
        ' QR decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(RowsCount, BlockSize, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QColumns >= 2# * ABLASComplexBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call CMatrixBlockReflector(TmpA, TauBuf, True, RowsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q.
            '
            ' Q  = E + Y*T*Y'  = E + TmpA*TmpT*TmpA'
            '
            Call CMatrixGEMM(BlockSize, QColumns, RowsCount, C_Complex(1#), TmpA, 0#, 0#, 2#, Q, BlockStart, 0#, 0#, C_Complex(0#), TmpR, 0#, 0#)
            Call CMatrixGEMM(BlockSize, QColumns, BlockSize, C_Complex(1#), TmpT, 0#, 0#, 0#, TmpR, 0#, 0#, 0#, C_Complex(0#), TmpR, BlockSize, 0#)
            Call CMatrixGEMM(RowsCount, QColumns, BlockSize, C_Complex(1#), TmpA, 0#, 0#, 0#, TmpR, BlockSize, 0#, 0#, C_Complex(1#), Q, BlockStart, 0#)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To RowsCount - i Step 1
                    T(i_) = TmpA(i_ + i1_, i)
                Next i_
                T(1#) = C_Complex(1#)
                Call ComplexApplyReflectionFromTheLeft(Q, TauBuf(i), T, BlockStart + i, M - 1#, 0#, QColumns - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASComplexBlockSize(A)
        BlockSize = ABLASComplexBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix R from the QR decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and R in compact form.
'                Output of CMatrixQR subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    R       -   matrix R, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixQRUnpackR(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef R() As Complex)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    K = MinInt(M, N)
    ReDim R(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        R(0#, i) = C_Complex(0#)
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            R(i, i_) = R(0#, i_)
        Next i_
    Next i
    For i = 0# To K - 1# Step 1
        For i_ = i To N - 1# Step 1
            R(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.
'
'Input parameters:
'    A           -   matrices Q and R in compact form.
'                    Output of CMatrixLQ subroutine .
'    M           -   number of rows in matrix A. M>=0.
'    N           -   number of columns in matrix A. N>=0.
'    Tau         -   scalar factors which are used to form Q.
'                    Output of CMatrixLQ subroutine .
'    QRows       -   required number of rows in matrix Q. N>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QRows rows of matrix Q.
'                    Array whose index ranges within [0..QRows-1, 0..N-1].
'                    If QRows=0, array isn't changed.
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQUnpackQ(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef Tau() As Complex, _
         ByVal QRows As Long, _
         ByRef Q() As Complex)
    Dim WORK() As Complex
    Dim T() As Complex
    Dim TauBuf() As Complex
    Dim MinMN As Long
    Dim RefCnt As Long
    Dim TmpA() As Complex
    Dim TmpT() As Complex
    Dim TmpR() As Complex
    Dim BlockStart As Long
    Dim BlockSize As Long
    Dim ColumnsCount As Long
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    
    '
    ' Init
    '
    MinMN = MinInt(M, N)
    RefCnt = MinInt(MinMN, QRows)
    ReDim WORK(0 To MaxInt(M, N) + 1# - 1)
    ReDim T(0 To MaxInt(M, N) + 1# - 1)
    ReDim TauBuf(0 To MinMN - 1)
    ReDim TmpA(0 To ABLASComplexBlockSize(A) - 1, 0 To N - 1)
    ReDim TmpT(0 To ABLASComplexBlockSize(A) - 1, 0 To ABLASComplexBlockSize(A) - 1)
    ReDim TmpR(0 To QRows - 1, 0 To 2# * ABLASComplexBlockSize(A) - 1)
    ReDim Q(0 To QRows - 1, 0 To N - 1)
    For i = 0# To QRows - 1# Step 1
        For J = 0# To N - 1# Step 1
            If i = J Then
                Q(i, J) = C_Complex(1#)
            Else
                Q(i, J) = C_Complex(0#)
            End If
        Next J
    Next i
    
    '
    ' Blocked code
    '
    BlockStart = ABLASComplexBlockSize(A) * (RefCnt \ ABLASComplexBlockSize(A))
    BlockSize = RefCnt - BlockStart
    Do While BlockStart >= 0#
        ColumnsCount = N - BlockStart
        
        '
        ' LQ decomposition of submatrix.
        ' Matrix is copied to temporary storage to solve
        ' some TLB issues arising from non-contiguous memory
        ' access pattern.
        '
        Call CMatrixCopy(BlockSize, ColumnsCount, A, BlockStart, BlockStart, TmpA, 0#, 0#)
        i1_ = (BlockStart) - (0#)
        For i_ = 0# To BlockSize - 1# Step 1
            TauBuf(i_) = Tau(i_ + i1_)
        Next i_
        
        '
        ' Update matrix, choose between:
        ' a) Level 2 algorithm (when the rest of the matrix is small enough)
        ' b) blocked algorithm, see algorithm 5 from  'A storage efficient WY
        '    representation for products of Householder transformations',
        '    by R. Schreiber and C. Van Loan.
        '
        If QRows >= 2# * ABLASComplexBlockSize(A) Then
            
            '
            ' Prepare block reflector
            '
            Call CMatrixBlockReflector(TmpA, TauBuf, False, ColumnsCount, BlockSize, TmpT, WORK)
            
            '
            ' Multiply the rest of A by Q'.
            '
            ' Q'  = E + Y*T'*Y'  = E + TmpA'*TmpT'*TmpA
            '
            Call CMatrixGEMM(QRows, BlockSize, ColumnsCount, C_Complex(1#), Q, 0#, BlockStart, 0#, TmpA, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, 0#)
            Call CMatrixGEMM(QRows, BlockSize, BlockSize, C_Complex(1#), TmpR, 0#, 0#, 0#, TmpT, 0#, 0#, 2#, C_Complex(0#), TmpR, 0#, BlockSize)
            Call CMatrixGEMM(QRows, ColumnsCount, BlockSize, C_Complex(1#), TmpR, 0#, BlockSize, 0#, TmpA, 0#, 0#, 0#, C_Complex(1#), Q, 0#, BlockStart)
        Else
            
            '
            ' Level 2 algorithm
            '
            For i = BlockSize - 1# To 0# Step -1
                i1_ = (i) - (1#)
                For i_ = 1# To ColumnsCount - i Step 1
                    T(i_) = Conj(TmpA(i, i_ + i1_))
                Next i_
                T(1#) = C_Complex(1#)
                Call ComplexApplyReflectionFromTheRight(Q, Conj(TauBuf(i)), T, 0#, QRows - 1#, BlockStart + i, N - 1#, WORK)
            Next i
        End If
        
        '
        ' Advance
        '
        BlockStart = BlockStart - ABLASComplexBlockSize(A)
        BlockSize = ABLASComplexBlockSize(A)
    Loop
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of matrix L from the LQ decomposition of a matrix A
'
'Input parameters:
'    A       -   matrices Q and L in compact form.
'                Output of CMatrixLQ subroutine.
'    M       -   number of rows in given matrix A. M>=0.
'    N       -   number of columns in given matrix A. N>=0.
'
'Output parameters:
'    L       -   matrix L, array[0..M-1, 0..N-1].
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLQUnpackL(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef L() As Complex)
    Dim i As Long
    Dim K As Long
    Dim i_ As Long
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    ReDim L(0 To M - 1, 0 To N - 1)
    For i = 0# To N - 1# Step 1
        L(0#, i) = C_Complex(0#)
    Next i
    For i = 1# To M - 1# Step 1
        For i_ = 0# To N - 1# Step 1
            L(i, i_) = L(0#, i_)
        Next i_
    Next i
    For i = 0# To M - 1# Step 1
        K = MinInt(i, N - 1#)
        For i_ = 0# To K Step 1
            L(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a rectangular matrix to  bidiagonal form
'
'The algorithm reduces the rectangular matrix A to  bidiagonal form by
'orthogonal transformations P and Q: A = Q*B*P.
'
'Input parameters:
'    A       -   source matrix. array[0..M-1, 0..N-1]
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'
'Output parameters:
'    A       -   matrices Q, B, P in compact form (see below).
'    TauQ    -   scalar factors which are used to form matrix Q.
'    TauP    -   scalar factors which are used to form matrix P.
'
'The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
'replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
'reflections which form MxM matrix Q and NxN matrix P, respectively.
'
'If M>=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
'corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
'product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
'H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
'vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
'stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
'G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
'u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).
'
'If M<N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
'corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
'H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
'is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
'G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
'is stored in A(i,i+1:n-1).
'
'EXAMPLE:
'
'm=6, n=5 (m > n):               m=5, n=6 (m < n):
'
'(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
'(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
'(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
'(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
'(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
'(  v1  v2  v3  v4  v5 )
'
'Here vi and ui are vectors which form H(i) and G(i), and d and e -
'are the diagonal and off-diagonal elements of matrix B.
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBD(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByRef TauP() As Double)
    Dim WORK() As Double
    Dim T() As Double
    Dim MinMN As Long
    Dim MaxMN As Long
    Dim i As Long
    Dim LTau As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Prepare
    '
    If N <= 0# Or M <= 0# Then
        Exit Sub
    End If
    MinMN = MinInt(M, N)
    MaxMN = MaxInt(M, N)
    ReDim WORK(0 To MaxMN + 1# - 1)
    ReDim T(0 To MaxMN + 1# - 1)
    If M >= N Then
        ReDim TauQ(0 To N - 1)
        ReDim TauP(0 To N - 1)
    Else
        ReDim TauQ(0 To M - 1)
        ReDim TauP(0 To M - 1)
    End If
    If M >= N Then
        
        '
        ' Reduce to upper bidiagonal form
        '
        For i = 0# To N - 1# Step 1
            
            '
            ' Generate elementary reflector H(i) to annihilate A(i+1:m-1,i)
            '
            i1_ = (i) - (1#)
            For i_ = 1# To M - i Step 1
                T(i_) = A(i_ + i1_, i)
            Next i_
            Call GenerateReflection(T, M - i, LTau)
            TauQ(i) = LTau
            i1_ = (1#) - (i)
            For i_ = i To M - 1# Step 1
                A(i_, i) = T(i_ + i1_)
            Next i_
            T(1#) = 1#
            
            '
            ' Apply H(i) to A(i:m-1,i+1:n-1) from the left
            '
            Call ApplyReflectionFromTheLeft(A, LTau, T, i, M - 1#, i + 1#, N - 1#, WORK)
            If i < N - 1# Then
                
                '
                ' Generate elementary reflector G(i) to annihilate
                ' A(i,i+2:n-1)
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i, i_ + i1_)
                Next i_
                Call GenerateReflection(T, N - 1# - i, LTau)
                TauP(i) = LTau
                i1_ = (1#) - (i + 1#)
                For i_ = i + 1# To N - 1# Step 1
                    A(i, i_) = T(i_ + i1_)
                Next i_
                T(1#) = 1#
                
                '
                ' Apply G(i) to A(i+1:m-1,i+1:n-1) from the right
                '
                Call ApplyReflectionFromTheRight(A, LTau, T, i + 1#, M - 1#, i + 1#, N - 1#, WORK)
            Else
                TauP(i) = 0#
            End If
        Next i
    Else
        
        '
        ' Reduce to lower bidiagonal form
        '
        For i = 0# To M - 1# Step 1
            
            '
            ' Generate elementary reflector G(i) to annihilate A(i,i+1:n-1)
            '
            i1_ = (i) - (1#)
            For i_ = 1# To N - i Step 1
                T(i_) = A(i, i_ + i1_)
            Next i_
            Call GenerateReflection(T, N - i, LTau)
            TauP(i) = LTau
            i1_ = (1#) - (i)
            For i_ = i To N - 1# Step 1
                A(i, i_) = T(i_ + i1_)
            Next i_
            T(1#) = 1#
            
            '
            ' Apply G(i) to A(i+1:m-1,i:n-1) from the right
            '
            Call ApplyReflectionFromTheRight(A, LTau, T, i + 1#, M - 1#, i, N - 1#, WORK)
            If i < M - 1# Then
                
                '
                ' Generate elementary reflector H(i) to annihilate
                ' A(i+2:m-1,i)
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To M - 1# - i Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                Call GenerateReflection(T, M - 1# - i, LTau)
                TauQ(i) = LTau
                i1_ = (1#) - (i + 1#)
                For i_ = i + 1# To M - 1# Step 1
                    A(i_, i) = T(i_ + i1_)
                Next i_
                T(1#) = 1#
                
                '
                ' Apply H(i) to A(i+1:m-1,i+1:n-1) from the left
                '
                Call ApplyReflectionFromTheLeft(A, LTau, T, i + 1#, M - 1#, i + 1#, N - 1#, WORK)
            Else
                TauQ(i) = 0#
            End If
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces a matrix to bidiagonal form.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of ToBidiagonal subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUQ        -   scalar factors which are used to form Q.
'                    Output of ToBidiagonal subroutine.
'    QColumns    -   required number of columns in matrix Q.
'                    M>=QColumns>=0.
'
'Output parameters:
'    Q           -   first QColumns columns of matrix Q.
'                    Array[0..M-1, 0..QColumns-1]
'                    If QColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackQ(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByVal QColumns As Long, _
         ByRef Q() As Double)
    Dim i As Long
    Dim J As Long
    If M = 0# Or N = 0# Or QColumns = 0# Then
        Exit Sub
    End If
    
    '
    ' prepare Q
    '
    ReDim Q(0 To M - 1, 0 To QColumns - 1)
    For i = 0# To M - 1# Step 1
        For J = 0# To QColumns - 1# Step 1
            If i = J Then
                Q(i, J) = 1#
            Else
                Q(i, J) = 0#
            End If
        Next J
    Next i
    
    '
    ' Calculate
    '
    Call RMatrixBDMultiplyByQ(QP, M, N, TauQ, Q, M, QColumns, False, False)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication by matrix Q which reduces matrix A to  bidiagonal form.
'
'The algorithm allows pre- or post-multiply by Q or Q'.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of ToBidiagonal subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUQ        -   scalar factors which are used to form Q.
'                    Output of ToBidiagonal subroutine.
'    Z           -   multiplied matrix.
'                    array[0..ZRows-1,0..ZColumns-1]
'    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                    ZRows=M, otherwise ZRows can be arbitrary.
'    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                    ZColumns=M, otherwise ZColumns can be arbitrary.
'    FromTheRight -  pre- or post-multiply.
'    DoTranspose -   multiply by Q or Q'.
'
'Output parameters:
'    Z           -   product of Z and Q.
'                    Array[0..ZRows-1,0..ZColumns-1]
'                    If ZRows=0 or ZColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDMultiplyByQ(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauQ() As Double, _
         ByRef Z() As Double, _
         ByVal ZRows As Long, _
         ByVal ZColumns As Long, _
         ByVal FromTheRight As Boolean, _
         ByVal DoTranspose As Boolean)
    Dim i As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IStep As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim MX As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or ZRows <= 0# Or ZColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MX = MaxInt(M, N)
    MX = MaxInt(MX, ZRows)
    MX = MaxInt(MX, ZColumns)
    ReDim V(0 To MX + 1# - 1)
    ReDim WORK(0 To MX + 1# - 1)
    If M >= N Then
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = 0#
            I2 = N - 1#
            IStep = 1#
        Else
            I1 = N - 1#
            I2 = 0#
            IStep = -1#
        End If
        If DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        i = I1
        Do
            i1_ = (i) - (1#)
            For i_ = 1# To M - i Step 1
                V(i_) = QP(i_ + i1_, i)
            Next i_
            V(1#) = 1#
            If FromTheRight Then
                Call ApplyReflectionFromTheRight(Z, TauQ(i), V, 0#, ZRows - 1#, i, M - 1#, WORK)
            Else
                Call ApplyReflectionFromTheLeft(Z, TauQ(i), V, i, M - 1#, 0#, ZColumns - 1#, WORK)
            End If
            i = i + IStep
        Loop Until i = I2 + IStep
    Else
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = 0#
            I2 = M - 2#
            IStep = 1#
        Else
            I1 = M - 2#
            I2 = 0#
            IStep = -1#
        End If
        If DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        If M - 1# > 0# Then
            i = I1
            Do
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To M - i - 1# Step 1
                    V(i_) = QP(i_ + i1_, i)
                Next i_
                V(1#) = 1#
                If FromTheRight Then
                    Call ApplyReflectionFromTheRight(Z, TauQ(i), V, 0#, ZRows - 1#, i + 1#, M - 1#, WORK)
                Else
                    Call ApplyReflectionFromTheLeft(Z, TauQ(i), V, i + 1#, M - 1#, 0#, ZColumns - 1#, WORK)
                End If
                i = i + IStep
            Loop Until i = I2 + IStep
        End If
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix P which reduces matrix A to bidiagonal form.
'The subroutine returns transposed matrix P.
'
'Input parameters:
'    QP      -   matrices Q and P in compact form.
'                Output of ToBidiagonal subroutine.
'    M       -   number of rows in matrix A.
'    N       -   number of columns in matrix A.
'    TAUP    -   scalar factors which are used to form P.
'                Output of ToBidiagonal subroutine.
'    PTRows  -   required number of rows of matrix P^T. N >= PTRows >= 0.
'
'Output parameters:
'    PT      -   first PTRows columns of matrix P^T
'                Array[0..PTRows-1, 0..N-1]
'                If PTRows=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackPT(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauP() As Double, _
         ByVal PTRows As Long, _
         ByRef PT() As Double)
    Dim i As Long
    Dim J As Long
    If M = 0# Or N = 0# Or PTRows = 0# Then
        Exit Sub
    End If
    
    '
    ' prepare PT
    '
    ReDim PT(0 To PTRows - 1, 0 To N - 1)
    For i = 0# To PTRows - 1# Step 1
        For J = 0# To N - 1# Step 1
            If i = J Then
                PT(i, J) = 1#
            Else
                PT(i, J) = 0#
            End If
        Next J
    Next i
    
    '
    ' Calculate
    '
    Call RMatrixBDMultiplyByP(QP, M, N, TauP, PT, PTRows, N, True, True)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Multiplication by matrix P which reduces matrix A to  bidiagonal form.
'
'The algorithm allows pre- or post-multiply by P or P'.
'
'Input parameters:
'    QP          -   matrices Q and P in compact form.
'                    Output of RMatrixBD subroutine.
'    M           -   number of rows in matrix A.
'    N           -   number of columns in matrix A.
'    TAUP        -   scalar factors which are used to form P.
'                    Output of RMatrixBD subroutine.
'    Z           -   multiplied matrix.
'                    Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
'                    ZRows=N, otherwise ZRows can be arbitrary.
'    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
'                    ZColumns=N, otherwise ZColumns can be arbitrary.
'    FromTheRight -  pre- or post-multiply.
'    DoTranspose -   multiply by P or P'.
'
'Output parameters:
'    Z - product of Z and P.
'                Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
'                If ZRows=0 or ZColumns=0, the array is not modified.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDMultiplyByP(ByRef QP() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef TauP() As Double, _
         ByRef Z() As Double, _
         ByVal ZRows As Long, _
         ByVal ZColumns As Long, _
         ByVal FromTheRight As Boolean, _
         ByVal DoTranspose As Boolean)
    Dim i As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim MX As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim IStep As Long
    Dim i_ As Long
    Dim i1_ As Long
    If M <= 0# Or N <= 0# Or ZRows <= 0# Or ZColumns <= 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    MX = MaxInt(M, N)
    MX = MaxInt(MX, ZRows)
    MX = MaxInt(MX, ZColumns)
    ReDim V(0 To MX + 1# - 1)
    ReDim WORK(0 To MX + 1# - 1)
    If M >= N Then
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = N - 2#
            I2 = 0#
            IStep = -1#
        Else
            I1 = 0#
            I2 = N - 2#
            IStep = 1#
        End If
        If Not DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        If N - 1# > 0# Then
            i = I1
            Do
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - 1# - i Step 1
                    V(i_) = QP(i, i_ + i1_)
                Next i_
                V(1#) = 1#
                If FromTheRight Then
                    Call ApplyReflectionFromTheRight(Z, TauP(i), V, 0#, ZRows - 1#, i + 1#, N - 1#, WORK)
                Else
                    Call ApplyReflectionFromTheLeft(Z, TauP(i), V, i + 1#, N - 1#, 0#, ZColumns - 1#, WORK)
                End If
                i = i + IStep
            Loop Until i = I2 + IStep
        End If
    Else
        
        '
        ' setup
        '
        If FromTheRight Then
            I1 = M - 1#
            I2 = 0#
            IStep = -1#
        Else
            I1 = 0#
            I2 = M - 1#
            IStep = 1#
        End If
        If Not DoTranspose Then
            i = I1
            I1 = I2
            I2 = i
            IStep = -IStep
        End If
        
        '
        ' Process
        '
        i = I1
        Do
            i1_ = (i) - (1#)
            For i_ = 1# To N - i Step 1
                V(i_) = QP(i, i_ + i1_)
            Next i_
            V(1#) = 1#
            If FromTheRight Then
                Call ApplyReflectionFromTheRight(Z, TauP(i), V, 0#, ZRows - 1#, i, N - 1#, WORK)
            Else
                Call ApplyReflectionFromTheLeft(Z, TauP(i), V, i, N - 1#, 0#, ZColumns - 1#, WORK)
            End If
            i = i + IStep
        Loop Until i = I2 + IStep
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking of the main and secondary diagonals of bidiagonal decomposition
'of matrix A.
'
'Input parameters:
'    B   -   output of RMatrixBD subroutine.
'    M   -   number of rows in matrix B.
'    N   -   number of columns in matrix B.
'
'Output parameters:
'    IsUpper -   True, if the matrix is upper bidiagonal.
'                otherwise IsUpper is False.
'    D       -   the main diagonal.
'                Array whose index ranges within [0..Min(M,N)-1].
'    E       -   the secondary diagonal (upper or lower, depending on
'                the value of IsUpper).
'                Array index ranges within [0..Min(M,N)-1], the last
'                element is not used.
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixBDUnpackDiagonals(ByRef B() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef D() As Double, _
         ByRef E() As Double)
    Dim i As Long
    IsUpper = M >= N
    If M <= 0# Or N <= 0# Then
        Exit Sub
    End If
    If IsUpper Then
        ReDim D(0 To N - 1)
        ReDim E(0 To N - 1)
        For i = 0# To N - 2# Step 1
            D(i) = B(i, i)
            E(i) = B(i, i + 1#)
        Next i
        D(N - 1#) = B(N - 1#, N - 1#)
    Else
        ReDim D(0 To M - 1)
        ReDim E(0 To M - 1)
        For i = 0# To M - 2# Step 1
            D(i) = B(i, i)
            E(i) = B(i + 1#, i)
        Next i
        D(M - 1#) = B(M - 1#, M - 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
'where Q is an orthogonal matrix, H - Hessenberg matrix.
'
'Input parameters:
'    A       -   matrix A with elements [0..N-1, 0..N-1]
'    N       -   size of matrix A.
'
'Output parameters:
'    A       -   matrices Q and P in  compact form (see below).
'    Tau     -   array of scalar factors which are used to form matrix Q.
'                Array whose index ranges within [0..N-2]
'
'Matrix H is located on the main diagonal, on the lower secondary  diagonal
'and above the main diagonal of matrix A. The elements which are used to
'form matrix Q are situated in array Tau and below the lower secondary
'diagonal of matrix A as follows:
'
'Matrix Q is represented as a product of elementary reflections
'
'Q = H(0)*H(2)*...*H(n-2),
'
'where each H(i) is given by
'
'H(i) = 1 - tau * v * (v^T)
'
'where tau is a scalar stored in Tau[I]; v - is a real vector,
'so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenberg(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim V As Double
    Dim T() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' Quick return if possible
    '
    If N <= 1# Then
        Exit Sub
    End If
    ReDim Tau(0# To N - 2#)
    ReDim T(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 2# Step 1
        
        '
        ' Compute elementary reflector H(i) to annihilate A(i+2:ihi,i)
        '
        i1_ = (i + 1#) - (1#)
        For i_ = 1# To N - i - 1# Step 1
            T(i_) = A(i_ + i1_, i)
        Next i_
        Call GenerateReflection(T, N - i - 1#, V)
        i1_ = (1#) - (i + 1#)
        For i_ = i + 1# To N - 1# Step 1
            A(i_, i) = T(i_ + i1_)
        Next i_
        Tau(i) = V
        T(1#) = 1#
        
        '
        ' Apply H(i) to A(1:ihi,i+1:ihi) from the right
        '
        Call ApplyReflectionFromTheRight(A, V, T, 0#, N - 1#, i + 1#, N - 1#, WORK)
        
        '
        ' Apply H(i) to A(i+1:ihi,i+1:n) from the left
        '
        Call ApplyReflectionFromTheLeft(A, V, T, i + 1#, N - 1#, i + 1#, N - 1#, WORK)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces matrix A to upper Hessenberg form
'
'Input parameters:
'    A   -   output of RMatrixHessenberg subroutine.
'    N   -   size of matrix A.
'    Tau -   scalar factors which are used to form Q.
'            Output of RMatrixHessenberg subroutine.
'
'Output parameters:
'    Q   -   matrix Q.
'            Array whose indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenbergUnpackQ(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Tau() As Double, _
         ByRef Q() As Double)
    Dim i As Long
    Dim J As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim Q(0# To N - 1#, 0# To N - 1#)
    ReDim V(0# To N - 1#)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For J = 0# To N - 1# Step 1
            If i = J Then
                Q(i, J) = 1#
            Else
                Q(i, J) = 0#
            End If
        Next J
    Next i
    
    '
    ' unpack Q
    '
    For i = 0# To N - 2# Step 1
        
        '
        ' Apply H(i)
        '
        i1_ = (i + 1#) - (1#)
        For i_ = 1# To N - i - 1# Step 1
            V(i_) = A(i_ + i1_, i)
        Next i_
        V(1#) = 1#
        Call ApplyReflectionFromTheRight(Q, Tau(i), V, 0#, N - 1#, i + 1#, N - 1#, WORK)
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)
'
'Input parameters:
'    A   -   output of RMatrixHessenberg subroutine.
'    N   -   size of matrix A.
'
'Output parameters:
'    H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     2005-2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixHessenbergUnpackH(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef H() As Double)
    Dim i As Long
    Dim J As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    If N = 0# Then
        Exit Sub
    End If
    ReDim H(0# To N - 1#, 0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For J = 0# To i - 2# Step 1
            H(i, J) = 0#
        Next J
        J = MaxInt(0#, i - 1#)
        For i_ = J To N - 1# Step 1
            H(i, i_) = A(i, i_)
        Next i_
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a symmetric matrix which is given by its higher or lower
'triangular part to a tridiagonal matrix using orthogonal similarity
'transformation: Q'*A*Q=T.
'
'Input parameters:
'    A       -   matrix to be transformed
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then matrix A is given
'                by its upper triangle, and the lower triangle is not used
'                and not modified by the algorithm, and vice versa
'                if IsUpper = False.
'
'Output parameters:
'    A       -   matrices T and Q in  compact form (see lower)
'    Tau     -   array of factors which are forming matrices H(i)
'                array with elements [0..N-2].
'    D       -   main diagonal of symmetric matrix T.
'                array with elements [0..N-1].
'    E       -   secondary diagonal of symmetric matrix T.
'                array with elements [0..N-2].
'
'
'  If IsUpper=True, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(n-2) . . . H(2) H(0).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a real scalar, and v is a real vector with
'  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'  A(0:i-1,i+1), and tau in TAU(i).
'
'  If IsUpper=False, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(0) H(2) . . . H(n-2).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a real scalar, and v is a real vector with
'  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'  and tau in TAU(i).
'
'  The contents of A on exit are illustrated by the following examples
'  with n = 5:
'
'  if UPLO = 'U':                       if UPLO = 'L':
'
'    (  d   e   v1  v2  v3 )              (  d                  )
'    (      d   e   v2  v3 )              (  e   d              )
'    (          d   e   v3 )              (  v0  e   d          )
'    (              d   e  )              (  v0  v1  e   d      )
'    (                  d  )              (  v0  v1  v2  e   d  )
'
'  where d and e denote diagonal and off-diagonal elements of T, and vi
'  denotes an element of the vector defining H(i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixTD(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tau() As Double, _
         ByRef D() As Double, _
         ByRef E() As Double)
    Dim i As Long
    Dim Alpha As Double
    Dim TauI As Double
    Dim V As Double
    Dim T() As Double
    Dim T2() As Double
    Dim T3() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    ReDim T(1# To N)
    ReDim T2(1# To N)
    ReDim T3(1# To N)
    If N > 1# Then
        ReDim Tau(0# To N - 2#)
    End If
    ReDim D(0# To N - 1#)
    If N > 1# Then
        ReDim E(0# To N - 2#)
    End If
    If IsUpper Then
        
        '
        ' Reduce the upper triangle of A
        '
        For i = N - 2# To 0# Step -1
            
            '
            ' Generate elementary reflector H() = E - tau * v * v'
            '
            If i >= 1# Then
                i1_ = (0#) - (2#)
                For i_ = 2# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
            End If
            T(1#) = A(i, i + 1#)
            Call GenerateReflection(T, i + 1#, TauI)
            If i >= 1# Then
                i1_ = (2#) - (0#)
                For i_ = 0# To i - 1# Step 1
                    A(i_, i + 1#) = T(i_ + i1_)
                Next i_
            End If
            A(i, i + 1#) = T(1#)
            E(i) = A(i, i + 1#)
            If TauI <> 0# Then
                
                '
                ' Apply H from both sides to A
                '
                A(i, i + 1#) = 1#
                
                '
                ' Compute  x := tau * A * v  storing x in TAU
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                Call SymmetricMatrixVectorMultiply(A, IsUpper, 0#, i, T, TauI, T3)
                i1_ = (1#) - (0#)
                For i_ = 0# To i Step 1
                    Tau(i_) = T3(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                V = 0#
                For i_ = 0# To i Step 1
                    V = V + Tau(i_) * A(i_, i + 1#)
                Next i_
                Alpha = -(0.5 * TauI * V)
                For i_ = 0# To i Step 1
                    Tau(i_) = Tau(i_) + Alpha * A(i_, i + 1#)
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '    A := A - v * w' - w * v'
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T3(i_) = Tau(i_ + i1_)
                Next i_
                Call SymmetricRank2Update(A, IsUpper, 0#, i, T, T3, T2, -1#)
                A(i, i + 1#) = E(i)
            End If
            D(i + 1#) = A(i + 1#, i + 1#)
            Tau(i) = TauI
        Next i
        D(0#) = A(0#, 0#)
    Else
        
        '
        ' Reduce the lower triangle of A
        '
        For i = 0# To N - 2# Step 1
            
            '
            ' Generate elementary reflector H = E - tau * v * v'
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                T(i_) = A(i_ + i1_, i)
            Next i_
            Call GenerateReflection(T, N - i - 1#, TauI)
            i1_ = (1#) - (i + 1#)
            For i_ = i + 1# To N - 1# Step 1
                A(i_, i) = T(i_ + i1_)
            Next i_
            E(i) = A(i + 1#, i)
            If TauI <> 0# Then
                
                '
                ' Apply H from both sides to A
                '
                A(i + 1#, i) = 1#
                
                '
                ' Compute  x := tau * A * v  storing y in TAU
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                Call SymmetricMatrixVectorMultiply(A, IsUpper, i + 1#, N - 1#, T, TauI, T2)
                i1_ = (1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                i1_ = (i + 1#) - (i)
                V = 0#
                For i_ = i To N - 2# Step 1
                    V = V + Tau(i_) * A(i_ + i1_, i)
                Next i_
                Alpha = -(0.5 * TauI * V)
                i1_ = (i + 1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = Tau(i_) + Alpha * A(i_ + i1_, i)
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '     A := A - v * w' - w * v'
                '
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                i1_ = (i) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T2(i_) = Tau(i_ + i1_)
                Next i_
                Call SymmetricRank2Update(A, IsUpper, i + 1#, N - 1#, T, T2, T3, -1#)
                A(i + 1#, i) = E(i)
            End If
            D(i) = A(i, i)
            Tau(i) = TauI
        Next i
        D(N - 1#) = A(N - 1#, N - 1#)
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
'form.
'
'Input parameters:
'    A       -   the result of a SMatrixTD subroutine
'    N       -   size of matrix A.
'    IsUpper -   storage format (a parameter of SMatrixTD subroutine)
'    Tau     -   the result of a SMatrixTD subroutine
'
'Output parameters:
'    Q       -   transformation matrix.
'                array with elements [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005-2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SMatrixTDUnpackQ(ByRef A() As Double, _
         ByRef N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef Tau() As Double, _
         ByRef Q() As Double)
    Dim i As Long
    Dim J As Long
    Dim V() As Double
    Dim WORK() As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim Q(0# To N - 1#, 0# To N - 1#)
    ReDim V(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For J = 0# To N - 1# Step 1
            If i = J Then
                Q(i, J) = 1#
            Else
                Q(i, J) = 0#
            End If
        Next J
    Next i
    
    '
    ' unpack Q
    '
    If IsUpper Then
        For i = 0# To N - 2# Step 1
            
            '
            ' Apply H(i)
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To i + 1# Step 1
                V(i_) = A(i_ + i1_, i + 1#)
            Next i_
            V(i + 1#) = 1#
            Call ApplyReflectionFromTheLeft(Q, Tau(i), V, 0#, i, 0#, N - 1#, WORK)
        Next i
    Else
        For i = N - 2# To 0# Step -1
            
            '
            ' Apply H(i)
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                V(i_) = A(i_ + i1_, i)
            Next i_
            V(1#) = 1#
            Call ApplyReflectionFromTheLeft(Q, Tau(i), V, i + 1#, N - 1#, 0#, N - 1#, WORK)
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
'triangular part to a real  tridiagonal  matrix  using  unitary  similarity
'transformation: Q'*A*Q = T.
'
'Input parameters:
'    A       -   matrix to be transformed
'                array with elements [0..N-1, 0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format. If IsUpper = True, then matrix A is  given
'                by its upper triangle, and the lower triangle is not  used
'                and not modified by the algorithm, and vice versa
'                if IsUpper = False.
'
'Output parameters:
'    A       -   matrices T and Q in  compact form (see lower)
'    Tau     -   array of factors which are forming matrices H(i)
'                array with elements [0..N-2].
'    D       -   main diagonal of real symmetric matrix T.
'                array with elements [0..N-1].
'    E       -   secondary diagonal of real symmetric matrix T.
'                array with elements [0..N-2].
'
'
'  If IsUpper=True, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(n-2) . . . H(2) H(0).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a complex scalar, and v is a complex vector with
'  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
'  A(0:i-1,i+1), and tau in TAU(i).
'
'  If IsUpper=False, the matrix Q is represented as a product of elementary
'  reflectors
'
'     Q = H(0) H(2) . . . H(n-2).
'
'  Each H(i) has the form
'
'     H(i) = I - tau * v * v'
'
'  where tau is a complex scalar, and v is a complex vector with
'  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
'  and tau in TAU(i).
'
'  The contents of A on exit are illustrated by the following examples
'  with n = 5:
'
'  if UPLO = 'U':                       if UPLO = 'L':
'
'    (  d   e   v1  v2  v3 )              (  d                  )
'    (      d   e   v2  v3 )              (  e   d              )
'    (          d   e   v3 )              (  v0  e   d          )
'    (              d   e  )              (  v0  v1  e   d      )
'    (                  d  )              (  v0  v1  v2  e   d  )
'
'where d and e denote diagonal and off-diagonal elements of T, and vi
'denotes an element of the vector defining H(i).
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     October 31, 1992
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixTD(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tau() As Complex, _
         ByRef D() As Double, _
         ByRef E() As Double)
    Dim i As Long
    Dim Alpha As Complex
    Dim TauI As Complex
    Dim V As Complex
    Dim T() As Complex
    Dim T2() As Complex
    Dim T3() As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N <= 0# Then
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
    Next i
    If N > 1# Then
        ReDim Tau(0# To N - 2#)
        ReDim E(0# To N - 2#)
    End If
    ReDim D(0# To N - 1#)
    ReDim T(0# To N - 1#)
    ReDim T2(0# To N - 1#)
    ReDim T3(0# To N - 1#)
    If IsUpper Then
        
        '
        ' Reduce the upper triangle of A
        '
        A(N - 1#, N - 1#) = C_Complex(A(N - 1#, N - 1#).x)
        For i = N - 2# To 0# Step -1
            
            '
            ' Generate elementary reflector H = I+1 - tau * v * v'
            '
            Alpha = A(i, i + 1#)
            T(1#) = Alpha
            If i >= 1# Then
                i1_ = (0#) - (2#)
                For i_ = 2# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
            End If
            Call ComplexGenerateReflection(T, i + 1#, TauI)
            If i >= 1# Then
                i1_ = (2#) - (0#)
                For i_ = 0# To i - 1# Step 1
                    A(i_, i + 1#) = T(i_ + i1_)
                Next i_
            End If
            Alpha = T(1#)
            E(i) = Alpha.x
            If C_NotEqualR(TauI, 0#) Then
                
                '
                ' Apply H(I+1) from both sides to A
                '
                A(i, i + 1#) = C_Complex(1#)
                
                '
                ' Compute  x := tau * A * v  storing x in TAU
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                Call HermitianMatrixVectorMultiply(A, IsUpper, 0#, i, T, TauI, T2)
                i1_ = (1#) - (0#)
                For i_ = 0# To i Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                V = C_Complex(0#)
                For i_ = 0# To i Step 1
                    V = C_Add(V, C_Mul(Conj(Tau(i_)), A(i_, i + 1#)))
                Next i_
                Alpha = C_Opposite(C_Mul(C_MulR(TauI, 0.5), V))
                For i_ = 0# To i Step 1
                    Tau(i_) = C_Add(Tau(i_), C_Mul(Alpha, A(i_, i + 1#)))
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                '    A := A - v * w' - w * v'
                '
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T(i_) = A(i_ + i1_, i + 1#)
                Next i_
                i1_ = (0#) - (1#)
                For i_ = 1# To i + 1# Step 1
                    T3(i_) = Tau(i_ + i1_)
                Next i_
                Call HermitianRank2Update(A, IsUpper, 0#, i, T, T3, T2, C_Complex(-1#))
            Else
                A(i, i) = C_Complex(A(i, i).x)
            End If
            A(i, i + 1#) = C_Complex(E(i))
            D(i + 1#) = A(i + 1#, i + 1#).x
            Tau(i) = TauI
        Next i
        D(0#) = A(0#, 0#).x
    Else
        
        '
        ' Reduce the lower triangle of A
        '
        A(0#, 0#) = C_Complex(A(0#, 0#).x)
        For i = 0# To N - 2# Step 1
            
            '
            ' Generate elementary reflector H = I - tau * v * v'
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                T(i_) = A(i_ + i1_, i)
            Next i_
            Call ComplexGenerateReflection(T, N - i - 1#, TauI)
            i1_ = (1#) - (i + 1#)
            For i_ = i + 1# To N - 1# Step 1
                A(i_, i) = T(i_ + i1_)
            Next i_
            E(i) = A(i + 1#, i).x
            If C_NotEqualR(TauI, 0#) Then
                
                '
                ' Apply H(i) from both sides to A(i+1:n,i+1:n)
                '
                A(i + 1#, i) = C_Complex(1#)
                
                '
                ' Compute  x := tau * A * v  storing y in TAU
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                Call HermitianMatrixVectorMultiply(A, IsUpper, i + 1#, N - 1#, T, TauI, T2)
                i1_ = (1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = T2(i_ + i1_)
                Next i_
                
                '
                ' Compute  w := x - 1/2 * tau * (x'*v) * v
                '
                i1_ = (i + 1#) - (i)
                V = C_Complex(0#)
                For i_ = i To N - 2# Step 1
                    V = C_Add(V, C_Mul(Conj(Tau(i_)), A(i_ + i1_, i)))
                Next i_
                Alpha = C_Opposite(C_Mul(C_MulR(TauI, 0.5), V))
                i1_ = (i + 1#) - (i)
                For i_ = i To N - 2# Step 1
                    Tau(i_) = C_Add(Tau(i_), C_Mul(Alpha, A(i_ + i1_, i)))
                Next i_
                
                '
                ' Apply the transformation as a rank-2 update:
                ' A := A - v * w' - w * v'
                '
                i1_ = (i + 1#) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T(i_) = A(i_ + i1_, i)
                Next i_
                i1_ = (i) - (1#)
                For i_ = 1# To N - i - 1# Step 1
                    T2(i_) = Tau(i_ + i1_)
                Next i_
                Call HermitianRank2Update(A, IsUpper, i + 1#, N - 1#, T, T2, T3, C_Complex(-1#))
            Else
                A(i + 1#, i + 1#) = C_Complex(A(i + 1#, i + 1#).x)
            End If
            A(i + 1#, i) = C_Complex(E(i))
            D(i) = A(i, i).x
            Tau(i) = TauI
        Next i
        D(N - 1#) = A(N - 1#, N - 1#).x
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
'form.
'
'Input parameters:
'    A       -   the result of a HMatrixTD subroutine
'    N       -   size of matrix A.
'    IsUpper -   storage format (a parameter of HMatrixTD subroutine)
'    Tau     -   the result of a HMatrixTD subroutine
'
'Output parameters:
'    Q       -   transformation matrix.
'                array with elements [0..N-1, 0..N-1].
'
'  -- ALGLIB --
'     Copyright 2005-2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HMatrixTDUnpackQ(ByRef A() As Complex, _
         ByRef N As Long, _
         ByRef IsUpper As Boolean, _
         ByRef Tau() As Complex, _
         ByRef Q() As Complex)
    Dim i As Long
    Dim J As Long
    Dim V() As Complex
    Dim WORK() As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N = 0# Then
        Exit Sub
    End If
    
    '
    ' init
    '
    ReDim Q(0# To N - 1#, 0# To N - 1#)
    ReDim V(1# To N)
    ReDim WORK(0# To N - 1#)
    For i = 0# To N - 1# Step 1
        For J = 0# To N - 1# Step 1
            If i = J Then
                Q(i, J) = C_Complex(1#)
            Else
                Q(i, J) = C_Complex(0#)
            End If
        Next J
    Next i
    
    '
    ' unpack Q
    '
    If IsUpper Then
        For i = 0# To N - 2# Step 1
            
            '
            ' Apply H(i)
            '
            i1_ = (0#) - (1#)
            For i_ = 1# To i + 1# Step 1
                V(i_) = A(i_ + i1_, i + 1#)
            Next i_
            V(i + 1#) = C_Complex(1#)
            Call ComplexApplyReflectionFromTheLeft(Q, Tau(i), V, 0#, i, 0#, N - 1#, WORK)
        Next i
    Else
        For i = N - 2# To 0# Step -1
            
            '
            ' Apply H(i)
            '
            i1_ = (i + 1#) - (1#)
            For i_ = 1# To N - i - 1# Step 1
                V(i_) = A(i_ + i1_, i)
            Next i_
            V(1#) = C_Complex(1#)
            Call ComplexApplyReflectionFromTheLeft(Q, Tau(i), V, i + 1#, N - 1#, 0#, N - 1#, WORK)
        Next i
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for real QR
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixQRBaseCase(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef T() As Double, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim K As Long
    Dim MinMN As Long
    Dim Tmp As Double
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    
    '
    ' Test the input arguments
    '
    K = MinMN
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
        '
        i1_ = (i) - (1#)
        For i_ = 1# To M - i Step 1
            T(i_) = A(i_ + i1_, i)
        Next i_
        Call GenerateReflection(T, M - i, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To M - 1# Step 1
            A(i_, i) = T(i_ + i1_)
        Next i_
        T(1#) = 1#
        If i < N Then
            
            '
            ' Apply H(i) to A(i:m-1,i+1:n-1) from the left
            '
            Call ApplyReflectionFromTheLeft(A, Tau(i), T, i, M - 1#, i + 1#, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for real LQ
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixLQBaseCase(ByRef A() As Double, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef T() As Double, _
         ByRef Tau() As Double)
    Dim i As Long
    Dim K As Long
    Dim MinMN As Long
    Dim Tmp As Double
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    K = MinInt(M, N)
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i,i+1:n-1)
        '
        i1_ = (i) - (1#)
        For i_ = 1# To N - i Step 1
            T(i_) = A(i, i_ + i1_)
        Next i_
        Call GenerateReflection(T, N - i, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To N - 1# Step 1
            A(i, i_) = T(i_ + i1_)
        Next i_
        T(1#) = 1#
        If i < N Then
            
            '
            ' Apply H(i) to A(i+1:m,i:n) from the right
            '
            Call ApplyReflectionFromTheRight(A, Tau(i), T, i + 1#, M - 1#, i, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for complex QR
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixQRBaseCase(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef T() As Complex, _
         ByRef Tau() As Complex)
    Dim i As Long
    Dim K As Long
    Dim MMI As Long
    Dim MinMN As Long
    Dim Tmp As Complex
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    If MinMN <= 0# Then
        Exit Sub
    End If
    
    '
    ' Test the input arguments
    '
    K = MinInt(M, N)
    For i = 0# To K - 1# Step 1
        
        '
        ' Generate elementary reflector H(i) to annihilate A(i+1:m,i)
        '
        MMI = M - i
        i1_ = (i) - (1#)
        For i_ = 1# To MMI Step 1
            T(i_) = A(i_ + i1_, i)
        Next i_
        Call ComplexGenerateReflection(T, MMI, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To M - 1# Step 1
            A(i_, i) = T(i_ + i1_)
        Next i_
        T(1#) = C_Complex(1#)
        If i < N - 1# Then
            
            '
            ' Apply H'(i) to A(i:m,i+1:n) from the left
            '
            Call ComplexApplyReflectionFromTheLeft(A, Conj(Tau(i)), T, i, M - 1#, i + 1#, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Base case for complex LQ
'
'  -- LAPACK routine (version 3.0) --
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     September 30, 1994.
'     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
'     pseudocode, 2007-2010.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixLQBaseCase(ByRef A() As Complex, _
         ByVal M As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef T() As Complex, _
         ByRef Tau() As Complex)
    Dim i As Long
    Dim MinMN As Long
    Dim Tmp As Complex
    Dim i_ As Long
    Dim i1_ As Long
    MinMN = MinInt(M, N)
    If MinMN <= 0# Then
        Exit Sub
    End If
    
    '
    ' Test the input arguments
    '
    For i = 0# To MinMN - 1# Step 1
        
        '
        ' Generate elementary reflector H(i)
        '
        ' NOTE: ComplexGenerateReflection() generates left reflector,
        ' i.e. H which reduces x by applyiong from the left, but we
        ' need RIGHT reflector. So we replace H=E-tau*v*v' by H^H,
        ' which changes v to conj(v).
        '
        i1_ = (i) - (1#)
        For i_ = 1# To N - i Step 1
            T(i_) = Conj(A(i, i_ + i1_))
        Next i_
        Call ComplexGenerateReflection(T, N - i, Tmp)
        Tau(i) = Tmp
        i1_ = (1#) - (i)
        For i_ = i To N - 1# Step 1
            A(i, i_) = Conj(T(i_ + i1_))
        Next i_
        T(1#) = C_Complex(1#)
        If i < M - 1# Then
            
            '
            ' Apply H'(i)
            '
            Call ComplexApplyReflectionFromTheRight(A, Tau(i), T, i + 1#, M - 1#, i, N - 1#, WORK)
        End If
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generate block reflector:
'* fill unused parts of reflectors matrix by zeros
'* fill diagonal of reflectors matrix by ones
'* generate triangular factor T
'
'PARAMETERS:
'    A           -   either LengthA*BlockSize (if ColumnwiseA) or
'                    BlockSize*LengthA (if not ColumnwiseA) matrix of
'                    elementary reflectors.
'                    Modified on exit.
'    Tau         -   scalar factors
'    ColumnwiseA -   reflectors are stored in rows or in columns
'    LengthA     -   length of largest reflector
'    BlockSize   -   number of reflectors
'    T           -   array[BlockSize,2*BlockSize]. Left BlockSize*BlockSize
'                    submatrix stores triangular factor on exit.
'    WORK        -   array[BlockSize]
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixBlockReflector(ByRef A() As Double, _
         ByRef Tau() As Double, _
         ByVal ColumnwiseA As Boolean, _
         ByVal LengthA As Long, _
         ByVal BlockSize As Long, _
         ByRef T() As Double, _
         ByRef WORK() As Double)
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Dim i_ As Long
    Dim i1_ As Long
    
    '
    ' fill beginning of new column with zeros,
    ' load 1.0 in the first non-zero element
    '
    For K = 0# To BlockSize - 1# Step 1
        If ColumnwiseA Then
            For i = 0# To K - 1# Step 1
                A(i, K) = 0#
            Next i
        Else
            For i = 0# To K - 1# Step 1
                A(K, i) = 0#
            Next i
        End If
        A(K, K) = 1#
    Next K
    
    '
    ' Calculate Gram matrix of A
    '
    For i = 0# To BlockSize - 1# Step 1
        For J = 0# To BlockSize - 1# Step 1
            T(i, BlockSize + J) = 0#
        Next J
    Next i
    For K = 0# To LengthA - 1# Step 1
        For J = 1# To BlockSize - 1# Step 1
            If ColumnwiseA Then
                V = A(K, J)
                If V <> 0# Then
                    i1_ = (0#) - (BlockSize)
                    For i_ = BlockSize To BlockSize + J - 1# Step 1
                        T(J, i_) = T(J, i_) + V * A(K, i_ + i1_)
                    Next i_
                End If
            Else
                V = A(J, K)
                If V <> 0# Then
                    i1_ = (0#) - (BlockSize)
                    For i_ = BlockSize To BlockSize + J - 1# Step 1
                        T(J, i_) = T(J, i_) + V * A(i_ + i1_, K)
                    Next i_
                End If
            End If
        Next J
    Next K
    
    '
    ' Prepare Y (stored in TmpA) and T (stored in TmpT)
    '
    For K = 0# To BlockSize - 1# Step 1
        
        '
        ' fill non-zero part of T, use pre-calculated Gram matrix
        '
        i1_ = (BlockSize) - (0#)
        For i_ = 0# To K - 1# Step 1
            WORK(i_) = T(K, i_ + i1_)
        Next i_
        For i = 0# To K - 1# Step 1
            V = 0#
            For i_ = i To K - 1# Step 1
                V = V + T(i, i_) * WORK(i_)
            Next i_
            T(i, K) = -(Tau(K) * V)
        Next i
        T(K, K) = -Tau(K)
        
        '
        ' Rest of T is filled by zeros
        '
        For i = K + 1# To BlockSize - 1# Step 1
            T(i, K) = 0#
        Next i
    Next K
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Generate block reflector (complex):
'* fill unused parts of reflectors matrix by zeros
'* fill diagonal of reflectors matrix by ones
'* generate triangular factor T
'
'
'  -- ALGLIB routine --
'     17.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixBlockReflector(ByRef A() As Complex, _
         ByRef Tau() As Complex, _
         ByVal ColumnwiseA As Boolean, _
         ByVal LengthA As Long, _
         ByVal BlockSize As Long, _
         ByRef T() As Complex, _
         ByRef WORK() As Complex)
    Dim i As Long
    Dim K As Long
    Dim V As Complex
    Dim i_ As Long
    
    '
    ' Prepare Y (stored in TmpA) and T (stored in TmpT)
    '
    For K = 0# To BlockSize - 1# Step 1
        
        '
        ' fill beginning of new column with zeros,
        ' load 1.0 in the first non-zero element
        '
        If ColumnwiseA Then
            For i = 0# To K - 1# Step 1
                A(i, K) = C_Complex(0#)
            Next i
        Else
            For i = 0# To K - 1# Step 1
                A(K, i) = C_Complex(0#)
            Next i
        End If
        A(K, K) = C_Complex(1#)
        
        '
        ' fill non-zero part of T,
        '
        For i = 0# To K - 1# Step 1
            If ColumnwiseA Then
                V = C_Complex(0#)
                For i_ = K To LengthA - 1# Step 1
                    V = C_Add(V, C_Mul(Conj(A(i_, i)), A(i_, K)))
                Next i_
            Else
                V = C_Complex(0#)
                For i_ = K To LengthA - 1# Step 1
                    V = C_Add(V, C_Mul(A(i, i_), Conj(A(K, i_))))
                Next i_
            End If
            WORK(i) = V
        Next i
        For i = 0# To K - 1# Step 1
            V = C_Complex(0#)
            For i_ = i To K - 1# Step 1
                V = C_Add(V, C_Mul(T(i, i_), WORK(i_)))
            Next i_
            T(i, K) = C_Opposite(C_Mul(Tau(K), V))
        Next i
        T(K, K) = C_Opposite(Tau(K))
        
        '
        ' Rest of T is filled by zeros
        '
        For i = K + 1# To BlockSize - 1# Step 1
            T(i, K) = C_Complex(0#)
        Next i
    Next K
End Sub
