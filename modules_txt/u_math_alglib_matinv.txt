''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.
'
'Contributors:
'    * Sergey Bochkanov (ALGLIB project). Translation from FORTRAN to
'      pseudocode.
'
'See subroutines comments for additional copyrights.
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Data types
Public Type MatInvReport
    R1 As Double
    RInf As Double
End Type
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a matrix given by its LU decomposition.
'
'INPUT PARAMETERS:
'    A       -   LU decomposition of the matrix (output of RMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during the LU decomposition
'                (the output of RMatrixLU subroutine).
'    N       -   size of matrix A.
'
'OUTPUT PARAMETERS:
'    Info    -   return code:
'                * -3    A is singular, or VERY close to singular.
'                        it is filled by zeros in such cases.
'                * -1    N<=0 was passed, or incorrect Pivots was passed
'                *  1    task is solved (but matrix A may be ill-conditioned,
'                        check R1/RInf parameters for condition numbers).
'    Rep     -   solver report, see below for more info
'    A       -   inverse of matrix A.
'                Array whose indexes range within [0..N-1, 0..N-1].
'
'SOLVER REPORT
'
'Subroutine sets following fields of the Rep structure:
'* R1        reciprocal of condition number: 1/cond(A), 1-norm.
'* RInf      reciprocal of condition number: 1/cond(A), inf-norm.
'
'  -- ALGLIB routine --
'     05.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixLUInverse(ByRef A() As Double, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim WORK() As Double
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Info = 1#
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If Pivots(i) > N - 1# Or Pivots(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = RMatrixLURCond1(A, N)
    Rep.RInf = RMatrixLURCondInf(A, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For J = 0# To N - 1# Step 1
                A(i, J) = 0#
            Next J
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Call cache-oblivious code
    '
    ReDim WORK(0 To N - 1)
    Call RMatrixLUInverseRec(A, 0#, N, WORK, Info, Rep)
    
    '
    ' apply permutations
    '
    For i = 0# To N - 1# Step 1
        For J = N - 2# To 0# Step -1
            K = Pivots(J)
            V = A(i, J)
            A(i, J) = A(i, K)
            A(i, K) = V
        Next J
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a general matrix.
'
'Input parameters:
'    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
'    N   -   size of matrix A.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'Result:
'    True, if the matrix is not singular.
'    False, if the matrix is singular.
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim Pivots() As Long
    Call RMatrixLU(A, N, N, Pivots)
    Call RMatrixLUInverse(A, Pivots, N, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a matrix given by its LU decomposition.
'
'INPUT PARAMETERS:
'    A       -   LU decomposition of the matrix (output of CMatrixLU subroutine).
'    Pivots  -   table of permutations which were made during the LU decomposition
'                (the output of CMatrixLU subroutine).
'    N       -   size of matrix A.
'
'OUTPUT PARAMETERS:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     05.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixLUInverse(ByRef A() As Complex, _
         ByRef Pivots() As Long, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim WORK() As Complex
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Complex
    Info = 1#
    
    '
    ' Quick return if possible
    '
    If N = 0# Then
        Info = -1#
        Exit Sub
    End If
    For i = 0# To N - 1# Step 1
        If Pivots(i) > N - 1# Or Pivots(i) < i Then
            Info = -1#
            Exit Sub
        End If
    Next i
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = CMatrixLURCond1(A, N)
    Rep.RInf = CMatrixLURCondInf(A, N)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For J = 0# To N - 1# Step 1
                A(i, J) = C_Complex(0#)
            Next J
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Call cache-oblivious code
    '
    ReDim WORK(0 To N - 1)
    Call CMatrixLUInverseRec(A, 0#, N, WORK, Info, Rep)
    
    '
    ' apply permutations
    '
    For i = 0# To N - 1# Step 1
        For J = N - 2# To 0# Step -1
            K = Pivots(J)
            V = A(i, J)
            A(i, J) = A(i, K)
            A(i, K) = V
        Next J
    Next i
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a general matrix.
'
'Input parameters:
'    A   -   matrix, array[0..N-1,0..N-1].
'    N   -   size of A.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB --
'     Copyright 2005 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim Pivots() As Long
    Call CMatrixLU(A, N, N, Pivots)
    Call CMatrixLUInverse(A, Pivots, N, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric positive definite matrix which is given
'by Cholesky decomposition.
'
'Input parameters:
'    A       -   Cholesky decomposition of the matrix to be inverted:
'                A=U’*U or A = L*L'.
'                Output of  SPDMatrixCholesky subroutine.
'    N       -   size of matrix A.
'    IsUpper –   storage format.
'                If IsUpper = True, then matrix A is given as A = U'*U
'                (matrix contains upper triangle).
'                Similarly, if IsUpper = False, then A = L*L'.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixCholeskyInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim J As Long
    Dim K As Long
    Dim V As Double
    Dim AJJ As Double
    Dim AII As Double
    Dim Tmp() As Double
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = SPDMatrixCholeskyRCond(A, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        If IsUpper Then
            For i = 0# To N - 1# Step 1
                For J = i To N - 1# Step 1
                    A(i, J) = 0#
                Next J
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For J = 0# To i Step 1
                    A(i, J) = 0#
                Next J
            Next i
        End If
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Inverse
    '
    ReDim Tmp(0 To N - 1)
    Call SPDMatrixCholeskyInverseRec(A, 0#, N, IsUpper, Tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a symmetric positive definite matrix.
'
'Given an upper or lower triangle of a symmetric positive definite matrix,
'the algorithm generates matrix A^-1 and saves the upper or lower triangle
'depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1,0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'                If IsUpper = True, then the upper triangle of matrix A is
'                given, otherwise the lower triangle is given.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SPDMatrixInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    If SPDMatrixCholesky(A, N, IsUpper) Then
        Call SPDMatrixCholeskyInverse(A, N, IsUpper, Info, Rep)
    Else
        Info = -3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a Hermitian positive definite matrix which is given
'by Cholesky decomposition.
'
'Input parameters:
'    A       -   Cholesky decomposition of the matrix to be inverted:
'                A=U’*U or A = L*L'.
'                Output of  HPDMatrixCholesky subroutine.
'    N       -   size of matrix A.
'    IsUpper –   storage format.
'                If IsUpper = True, then matrix A is given as A = U'*U
'                (matrix contains upper triangle).
'                Similarly, if IsUpper = False, then A = L*L'.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixCholeskyInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim J As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim Tmp() As Complex
    Dim V As Complex
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = HPDMatrixCholeskyRCond(A, N, IsUpper)
    Rep.RInf = Rep.R1
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        If IsUpper Then
            For i = 0# To N - 1# Step 1
                For J = i To N - 1# Step 1
                    A(i, J) = C_Complex(0#)
                Next J
            Next i
        Else
            For i = 0# To N - 1# Step 1
                For J = 0# To i Step 1
                    A(i, J) = C_Complex(0#)
                Next J
            Next i
        End If
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Inverse
    '
    ReDim Tmp(0 To N - 1)
    Call HPDMatrixCholeskyInverseRec(A, 0#, N, IsUpper, Tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Inversion of a Hermitian positive definite matrix.
'
'Given an upper or lower triangle of a Hermitian positive definite matrix,
'the algorithm generates matrix A^-1 and saves the upper or lower triangle
'depending on the input.
'
'Input parameters:
'    A       -   matrix to be inverted (upper or lower triangle).
'                Array with elements [0..N-1,0..N-1].
'    N       -   size of matrix A.
'    IsUpper -   storage format.
'                If IsUpper = True, then the upper triangle of matrix A is
'                given, otherwise the lower triangle is given.
'
'Output parameters:
'    Info    -   return code, same as in RMatrixLUInverse
'    Rep     -   solver report, same as in RMatrixLUInverse
'    A       -   inverse of matrix A, same as in RMatrixLUInverse
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HPDMatrixInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    If HPDMatrixCholesky(A, N, IsUpper) Then
        Call HPDMatrixCholeskyInverse(A, N, IsUpper, Info, Rep)
    Else
        Info = -3#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inverse (real)
'
'The subroutine inverts the following types of matrices:
'    * upper triangular
'    * upper triangular with unit diagonal
'    * lower triangular
'    * lower triangular with unit diagonal
'
'In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'also be upper (lower) triangular, and after the end of the algorithm,  the
'inverse matrix replaces the source matrix. The elements  below (above) the
'main diagonal are not changed by the algorithm.
'
'If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'diagonal, and the diagonal elements are not passed to the algorithm.
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Output parameters:
'    Info    -   same as for RMatrixLUInverse
'    Rep     -   same as for RMatrixLUInverse
'    A       -   same as for RMatrixLUInverse.
'
'  -- ALGLIB --
'     Copyright 05.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub RMatrixTRInverse(ByRef A() As Double, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsUnit As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim J As Long
    Dim Tmp() As Double
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = RMatrixTRRCond1(A, N, IsUpper, IsUnit)
    Rep.RInf = RMatrixTRRCondInf(A, N, IsUpper, IsUnit)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For J = 0# To N - 1# Step 1
                A(i, J) = 0#
            Next J
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Invert
    '
    ReDim Tmp(0 To N - 1)
    Call RMatrixTRInverseRec(A, 0#, N, IsUpper, IsUnit, Tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inverse (complex)
'
'The subroutine inverts the following types of matrices:
'    * upper triangular
'    * upper triangular with unit diagonal
'    * lower triangular
'    * lower triangular with unit diagonal
'
'In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
'also be upper (lower) triangular, and after the end of the algorithm,  the
'inverse matrix replaces the source matrix. The elements  below (above) the
'main diagonal are not changed by the algorithm.
'
'If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
'diagonal, and the diagonal elements are not passed to the algorithm.
'
'Input parameters:
'    A       -   matrix, array[0..N-1, 0..N-1].
'    N       -   size of A.
'    IsUpper -   True, if the matrix is upper triangular.
'    IsUnit  -   True, if the matrix has a unit diagonal.
'
'Output parameters:
'    Info    -   same as for RMatrixLUInverse
'    Rep     -   same as for RMatrixLUInverse
'    A       -   same as for RMatrixLUInverse.
'
'  -- ALGLIB --
'     Copyright 05.02.2010 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub CMatrixTRInverse(ByRef A() As Complex, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsUnit As Boolean, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim J As Long
    Dim Tmp() As Complex
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    Info = 1#
    
    '
    ' calculate condition numbers
    '
    Rep.R1 = CMatrixTRRCond1(A, N, IsUpper, IsUnit)
    Rep.RInf = CMatrixTRRCondInf(A, N, IsUpper, IsUnit)
    If Rep.R1 < RCondThreshold() Or Rep.RInf < RCondThreshold() Then
        For i = 0# To N - 1# Step 1
            For J = 0# To N - 1# Step 1
                A(i, J) = C_Complex(0#)
            Next J
        Next i
        Rep.R1 = 0#
        Rep.RInf = 0#
        Info = -3#
        Exit Sub
    End If
    
    '
    ' Invert
    '
    ReDim Tmp(0 To N - 1)
    Call CMatrixTRInverseRec(A, 0#, N, IsUpper, IsUnit, Tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inversion, recursive subroutine
'
'  -- ALGLIB --
'     05.02.2010, Bochkanov Sergey.
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub RMatrixTRInverseRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsUnit As Boolean, _
         ByRef Tmp() As Double, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim N1 As Long
    Dim N2 As Long
    Dim i As Long
    Dim J As Long
    Dim V As Double
    Dim AJJ As Double
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(A) Then
        If IsUpper Then
            
            '
            ' Compute inverse of upper triangular matrix.
            '
            For J = 0# To N - 1# Step 1
                If Not IsUnit Then
                    If A(Offs + J, Offs + J) = 0# Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + J, Offs + J) = 1# / A(Offs + J, Offs + J)
                    AJJ = -A(Offs + J, Offs + J)
                Else
                    AJJ = -1#
                End If
                
                '
                ' Compute elements 1:j-1 of j-th column.
                '
                If J > 0# Then
                    i1_ = (Offs + 0#) - (0#)
                    For i_ = 0# To J - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + J)
                    Next i_
                    For i = 0# To J - 1# Step 1
                        If i < J - 1# Then
                            i1_ = (i + 1#) - (Offs + i + 1#)
                            V = 0#
                            For i_ = Offs + i + 1# To Offs + J - 1# Step 1
                                V = V + A(Offs + i, i_) * Tmp(i_ + i1_)
                            Next i_
                        Else
                            V = 0#
                        End If
                        If Not IsUnit Then
                            A(Offs + i, Offs + J) = V + A(Offs + i, Offs + i) * Tmp(i)
                        Else
                            A(Offs + i, Offs + J) = V + Tmp(i)
                        End If
                    Next i
                    For i_ = Offs + 0# To Offs + J - 1# Step 1
                        A(i_, Offs + J) = AJJ * A(i_, Offs + J)
                    Next i_
                End If
            Next J
        Else
            
            '
            ' Compute inverse of lower triangular matrix.
            '
            For J = N - 1# To 0# Step -1
                If Not IsUnit Then
                    If A(Offs + J, Offs + J) = 0# Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + J, Offs + J) = 1# / A(Offs + J, Offs + J)
                    AJJ = -A(Offs + J, Offs + J)
                Else
                    AJJ = -1#
                End If
                If J < N - 1# Then
                    
                    '
                    ' Compute elements j+1:n of j-th column.
                    '
                    i1_ = (Offs + J + 1#) - (J + 1#)
                    For i_ = J + 1# To N - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + J)
                    Next i_
                    For i = J + 1# To N - 1# Step 1
                        If i > J + 1# Then
                            i1_ = (J + 1#) - (Offs + J + 1#)
                            V = 0#
                            For i_ = Offs + J + 1# To Offs + i - 1# Step 1
                                V = V + A(Offs + i, i_) * Tmp(i_ + i1_)
                            Next i_
                        Else
                            V = 0#
                        End If
                        If Not IsUnit Then
                            A(Offs + i, Offs + J) = V + A(Offs + i, Offs + i) * Tmp(i)
                        Else
                            A(Offs + i, Offs + J) = V + Tmp(i)
                        End If
                    Next i
                    For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                        A(i_, Offs + J) = AJJ * A(i_, Offs + J)
                    Next i_
                End If
            Next J
        End If
        Exit Sub
    End If
    
    '
    ' Recursive case
    '
    Call ABLASSplitLength(A, N, N1, N2)
    If N2 > 0# Then
        If IsUpper Then
            For i = 0# To N1 - 1# Step 1
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = -1 * A(Offs + i, i_)
                Next i_
            Next i
            Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, IsUnit, 0#, A, Offs, Offs + N1)
            Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, IsUnit, 0#, A, Offs, Offs + N1)
        Else
            For i = 0# To N2 - 1# Step 1
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = -1 * A(Offs + N1 + i, i_)
                Next i_
            Next i
            Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, IsUnit, 0#, A, Offs + N1, Offs)
            Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, IsUnit, 0#, A, Offs + N1, Offs)
        End If
        Call RMatrixTRInverseRec(A, Offs + N1, N2, IsUpper, IsUnit, Tmp, Info, Rep)
    End If
    Call RMatrixTRInverseRec(A, Offs, N1, IsUpper, IsUnit, Tmp, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Triangular matrix inversion, recursive subroutine
'
'  -- ALGLIB --
'     05.02.2010, Bochkanov Sergey.
'     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
'     Courant Institute, Argonne National Lab, and Rice University
'     February 29, 1992.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub CMatrixTRInverseRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByVal IsUnit As Boolean, _
         ByRef Tmp() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim N1 As Long
    Dim N2 As Long
    Dim i As Long
    Dim J As Long
    Dim V As Complex
    Dim AJJ As Complex
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(A) Then
        If IsUpper Then
            
            '
            ' Compute inverse of upper triangular matrix.
            '
            For J = 0# To N - 1# Step 1
                If Not IsUnit Then
                    If C_EqualR(A(Offs + J, Offs + J), 0#) Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + J, Offs + J) = C_RDiv(1#, A(Offs + J, Offs + J))
                    AJJ = C_Opposite(A(Offs + J, Offs + J))
                Else
                    AJJ = C_Complex(-1#)
                End If
                
                '
                ' Compute elements 1:j-1 of j-th column.
                '
                If J > 0# Then
                    i1_ = (Offs + 0#) - (0#)
                    For i_ = 0# To J - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + J)
                    Next i_
                    For i = 0# To J - 1# Step 1
                        If i < J - 1# Then
                            i1_ = (i + 1#) - (Offs + i + 1#)
                            V = C_Complex(0#)
                            For i_ = Offs + i + 1# To Offs + J - 1# Step 1
                                V = C_Add(V, C_Mul(A(Offs + i, i_), Tmp(i_ + i1_)))
                            Next i_
                        Else
                            V = C_Complex(0#)
                        End If
                        If Not IsUnit Then
                            A(Offs + i, Offs + J) = C_Add(V, C_Mul(A(Offs + i, Offs + i), Tmp(i)))
                        Else
                            A(Offs + i, Offs + J) = C_Add(V, Tmp(i))
                        End If
                    Next i
                    For i_ = Offs + 0# To Offs + J - 1# Step 1
                        A(i_, Offs + J) = C_Mul(AJJ, A(i_, Offs + J))
                    Next i_
                End If
            Next J
        Else
            
            '
            ' Compute inverse of lower triangular matrix.
            '
            For J = N - 1# To 0# Step -1
                If Not IsUnit Then
                    If C_EqualR(A(Offs + J, Offs + J), 0#) Then
                        Info = -3#
                        Exit Sub
                    End If
                    A(Offs + J, Offs + J) = C_RDiv(1#, A(Offs + J, Offs + J))
                    AJJ = C_Opposite(A(Offs + J, Offs + J))
                Else
                    AJJ = C_Complex(-1#)
                End If
                If J < N - 1# Then
                    
                    '
                    ' Compute elements j+1:n of j-th column.
                    '
                    i1_ = (Offs + J + 1#) - (J + 1#)
                    For i_ = J + 1# To N - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + J)
                    Next i_
                    For i = J + 1# To N - 1# Step 1
                        If i > J + 1# Then
                            i1_ = (J + 1#) - (Offs + J + 1#)
                            V = C_Complex(0#)
                            For i_ = Offs + J + 1# To Offs + i - 1# Step 1
                                V = C_Add(V, C_Mul(A(Offs + i, i_), Tmp(i_ + i1_)))
                            Next i_
                        Else
                            V = C_Complex(0#)
                        End If
                        If Not IsUnit Then
                            A(Offs + i, Offs + J) = C_Add(V, C_Mul(A(Offs + i, Offs + i), Tmp(i)))
                        Else
                            A(Offs + i, Offs + J) = C_Add(V, Tmp(i))
                        End If
                    Next i
                    For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                        A(i_, Offs + J) = C_Mul(AJJ, A(i_, Offs + J))
                    Next i_
                End If
            Next J
        End If
        Exit Sub
    End If
    
    '
    ' Recursive case
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    If N2 > 0# Then
        If IsUpper Then
            For i = 0# To N1 - 1# Step 1
                For i_ = Offs + N1 To Offs + N - 1# Step 1
                    A(Offs + i, i_) = C_MulR(A(Offs + i, i_), -1)
                Next i_
            Next i
            Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, IsUnit, 0#, A, Offs, Offs + N1)
            Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, IsUnit, 0#, A, Offs, Offs + N1)
        Else
            For i = 0# To N2 - 1# Step 1
                For i_ = Offs To Offs + N1 - 1# Step 1
                    A(Offs + N1 + i, i_) = C_MulR(A(Offs + N1 + i, i_), -1)
                Next i_
            Next i
            Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, IsUnit, 0#, A, Offs + N1, Offs)
            Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, IsUnit, 0#, A, Offs + N1, Offs)
        End If
        Call CMatrixTRInverseRec(A, Offs + N1, N2, IsUpper, IsUnit, Tmp, Info, Rep)
    End If
    Call CMatrixTRInverseRec(A, Offs, N1, IsUpper, IsUnit, Tmp, Info, Rep)
End Sub
Private Sub RMatrixLUInverseRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByRef WORK() As Double, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim IWS As Long
    Dim J As Long
    Dim JB As Long
    Dim JJ As Long
    Dim JP As Long
    Dim K As Long
    Dim V As Double
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(A) Then
        
        '
        ' Form inv(U)
        '
        Call RMatrixTRInverseRec(A, Offs, N, True, False, WORK, Info, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' Solve the equation inv(A)*L = inv(U) for inv(A).
        '
        For J = N - 1# To 0# Step -1
            
            '
            ' Copy current column of L to WORK and replace with zeros.
            '
            For i = J + 1# To N - 1# Step 1
                WORK(i) = A(Offs + i, Offs + J)
                A(Offs + i, Offs + J) = 0#
            Next i
            
            '
            ' Compute current column of inv(A).
            '
            If J < N - 1# Then
                For i = 0# To N - 1# Step 1
                    i1_ = (J + 1#) - (Offs + J + 1#)
                    V = 0#
                    For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                        V = V + A(Offs + i, i_) * WORK(i_ + i1_)
                    Next i_
                    A(Offs + i, Offs + J) = A(Offs + i, Offs + J) - V
                Next i
            End If
        Next J
        Exit Sub
    End If
    
    '
    ' Recursive code:
    '
    '         ( L1      )   ( U1  U12 )
    ' A    =  (         ) * (         )
    '         ( L12  L2 )   (     U2  )
    '
    '         ( W   X )
    ' A^-1 =  (       )
    '         ( Y   Z )
    '
    Call ABLASSplitLength(A, N, N1, N2)
    
    '
    ' X := inv(U1)*U12*inv(U2)
    '
    Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, True, False, 0#, A, Offs, Offs + N1)
    Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs, Offs + N1)
    
    '
    ' Y := inv(L2)*L12*inv(L1)
    '
    Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs + N1, Offs)
    Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, False, True, 0#, A, Offs + N1, Offs)
    
    '
    ' W := inv(L1*U1)+X*Y
    '
    Call RMatrixLUInverseRec(A, Offs, N1, WORK, Info, Rep)
    If Info <= 0# Then
        Exit Sub
    End If
    Call RMatrixGEMM(N1, N1, N2, 1#, A, Offs, Offs + N1, 0#, A, Offs + N1, Offs, 0#, 1#, A, Offs, Offs)
    
    '
    ' X := -X*inv(L2)
    ' Y := -inv(U2)*Y
    '
    Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs, Offs + N1)
    For i = 0# To N1 - 1# Step 1
        For i_ = Offs + N1 To Offs + N - 1# Step 1
            A(Offs + i, i_) = -1 * A(Offs + i, i_)
        Next i_
    Next i
    Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs + N1, Offs)
    For i = 0# To N2 - 1# Step 1
        For i_ = Offs To Offs + N1 - 1# Step 1
            A(Offs + N1 + i, i_) = -1 * A(Offs + N1 + i, i_)
        Next i_
    Next i
    
    '
    ' Z := inv(L2*U2)
    '
    Call RMatrixLUInverseRec(A, Offs + N1, N2, WORK, Info, Rep)
End Sub
Private Sub CMatrixLUInverseRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByRef WORK() As Complex, _
         ByRef Info As Long, _
         ByRef Rep As MatInvReport)
    Dim i As Long
    Dim IWS As Long
    Dim J As Long
    Dim JB As Long
    Dim JJ As Long
    Dim JP As Long
    Dim K As Long
    Dim V As Complex
    Dim N1 As Long
    Dim N2 As Long
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Info = -1#
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(A) Then
        
        '
        ' Form inv(U)
        '
        Call CMatrixTRInverseRec(A, Offs, N, True, False, WORK, Info, Rep)
        If Info <= 0# Then
            Exit Sub
        End If
        
        '
        ' Solve the equation inv(A)*L = inv(U) for inv(A).
        '
        For J = N - 1# To 0# Step -1
            
            '
            ' Copy current column of L to WORK and replace with zeros.
            '
            For i = J + 1# To N - 1# Step 1
                WORK(i) = A(Offs + i, Offs + J)
                A(Offs + i, Offs + J) = C_Complex(0#)
            Next i
            
            '
            ' Compute current column of inv(A).
            '
            If J < N - 1# Then
                For i = 0# To N - 1# Step 1
                    i1_ = (J + 1#) - (Offs + J + 1#)
                    V = C_Complex(0#)
                    For i_ = Offs + J + 1# To Offs + N - 1# Step 1
                        V = C_Add(V, C_Mul(A(Offs + i, i_), WORK(i_ + i1_)))
                    Next i_
                    A(Offs + i, Offs + J) = C_Sub(A(Offs + i, Offs + J), V)
                Next i
            End If
        Next J
        Exit Sub
    End If
    
    '
    ' Recursive code:
    '
    '         ( L1      )   ( U1  U12 )
    ' A    =  (         ) * (         )
    '         ( L12  L2 )   (     U2  )
    '
    '         ( W   X )
    ' A^-1 =  (       )
    '         ( Y   Z )
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    
    '
    ' X := inv(U1)*U12*inv(U2)
    '
    Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, True, False, 0#, A, Offs, Offs + N1)
    Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs, Offs + N1)
    
    '
    ' Y := inv(L2)*L12*inv(L1)
    '
    Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs + N1, Offs)
    Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, False, True, 0#, A, Offs + N1, Offs)
    
    '
    ' W := inv(L1*U1)+X*Y
    '
    Call CMatrixLUInverseRec(A, Offs, N1, WORK, Info, Rep)
    If Info <= 0# Then
        Exit Sub
    End If
    Call CMatrixGEMM(N1, N1, N2, C_Complex(1#), A, Offs, Offs + N1, 0#, A, Offs + N1, Offs, 0#, C_Complex(1#), A, Offs, Offs)
    
    '
    ' X := -X*inv(L2)
    ' Y := -inv(U2)*Y
    '
    Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, False, True, 0#, A, Offs, Offs + N1)
    For i = 0# To N1 - 1# Step 1
        For i_ = Offs + N1 To Offs + N - 1# Step 1
            A(Offs + i, i_) = C_MulR(A(Offs + i, i_), -1)
        Next i_
    Next i
    Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, True, False, 0#, A, Offs + N1, Offs)
    For i = 0# To N2 - 1# Step 1
        For i_ = Offs To Offs + N1 - 1# Step 1
            A(Offs + N1 + i, i_) = C_MulR(A(Offs + N1 + i, i_), -1)
        Next i_
    Next i
    
    '
    ' Z := inv(L2*U2)
    '
    Call CMatrixLUInverseRec(A, Offs + N1, N2, WORK, Info, Rep)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive subroutine for SPD inversion.
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub SPDMatrixCholeskyInverseRec(ByRef A() As Double, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Double)
    Dim i As Long
    Dim J As Long
    Dim V As Double
    Dim N1 As Long
    Dim N2 As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASBlockSize(A) Then
        Call RMatrixTRInverseRec(A, Offs, N, IsUpper, False, Tmp, Info2, Rep2)
        If IsUpper Then
            
            '
            ' Compute the product U * U'.
            ' NOTE: we never assume that diagonal of U is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
                    ' (          ) * (              ) = (                                )
                    ' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = A(i_ + i1_, Offs + i)
                    Next i_
                    For J = 0# To i - 1# Step 1
                        V = A(Offs + J, Offs + i)
                        i1_ = (J) - (Offs + J)
                        For i_ = Offs + J To Offs + i - 1# Step 1
                            A(Offs + J, i_) = A(Offs + J, i_) + V * Tmp(i_ + i1_)
                        Next i_
                    Next J
                    V = A(Offs + i, Offs + i)
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(i_, Offs + i) = V * A(i_, Offs + i)
                    Next i_
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                End If
            Next i
        Else
            
            '
            ' Compute the product L' * L
            ' NOTE: we never assume that diagonal of L is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
                    ' (              ) * (          ) = (                                )
                    ' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = A(Offs + i, i_ + i1_)
                    Next i_
                    For J = 0# To i - 1# Step 1
                        V = A(Offs + i, Offs + J)
                        i1_ = (0#) - (Offs)
                        For i_ = Offs To Offs + J Step 1
                            A(Offs + J, i_) = A(Offs + J, i_) + V * Tmp(i_ + i1_)
                        Next i_
                    Next J
                    V = A(Offs + i, Offs + i)
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(Offs + i, i_) = V * A(Offs + i, i_)
                    Next i_
                    A(Offs + i, Offs + i) = Square(A(Offs + i, Offs + i))
                End If
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' Recursive code: triangular factor inversion merged with
    ' UU' or L'L multiplication
    '
    Call ABLASSplitLength(A, N, N1, N2)
    
    '
    ' form off-diagonal block of trangular inverse
    '
    If IsUpper Then
        For i = 0# To N1 - 1# Step 1
            For i_ = Offs + N1 To Offs + N - 1# Step 1
                A(Offs + i, i_) = -1 * A(Offs + i, i_)
            Next i_
        Next i
        Call RMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 0#, A, Offs, Offs + N1)
        Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs, Offs + N1)
    Else
        For i = 0# To N2 - 1# Step 1
            For i_ = Offs To Offs + N1 - 1# Step 1
                A(Offs + N1 + i, i_) = -1 * A(Offs + N1 + i, i_)
            Next i_
        Next i
        Call RMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 0#, A, Offs + N1, Offs)
        Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert first diagonal block
    '
    Call SPDMatrixCholeskyInverseRec(A, Offs, N1, IsUpper, Tmp)
    
    '
    ' update first diagonal block with off-diagonal block,
    ' update off-diagonal block
    '
    If IsUpper Then
        Call RMatrixSYRK(N1, N2, 1#, A, Offs, Offs + N1, 0#, 1#, A, Offs, Offs, IsUpper)
        Call RMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 1#, A, Offs, Offs + N1)
    Else
        Call RMatrixSYRK(N1, N2, 1#, A, Offs + N1, Offs, 1#, 1#, A, Offs, Offs, IsUpper)
        Call RMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 1#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert second diagonal block
    '
    Call SPDMatrixCholeskyInverseRec(A, Offs + N1, N2, IsUpper, Tmp)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Recursive subroutine for HPD inversion.
'
'  -- ALGLIB routine --
'     10.02.2010
'     Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub HPDMatrixCholeskyInverseRec(ByRef A() As Complex, _
         ByVal Offs As Long, _
         ByVal N As Long, _
         ByVal IsUpper As Boolean, _
         ByRef Tmp() As Complex)
    Dim i As Long
    Dim J As Long
    Dim V As Complex
    Dim N1 As Long
    Dim N2 As Long
    Dim Info2 As Long
    Dim Rep2 As MatInvReport
    Dim i_ As Long
    Dim i1_ As Long
    If N < 1# Then
        Exit Sub
    End If
    
    '
    ' Base case
    '
    If N <= ABLASComplexBlockSize(A) Then
        Call CMatrixTRInverseRec(A, Offs, N, IsUpper, False, Tmp, Info2, Rep2)
        If IsUpper Then
            
            '
            ' Compute the product U * U'.
            ' NOTE: we never assume that diagonal of U is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).Y))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11  A12 )   ( A11^H        )   ( A11*A11^H+A12*A12^H  A12*A22^H )
                    ' (          ) * (              ) = (                                )
                    ' (      A22 )   ( A12^H  A22^H )   ( A22*A12^H            A22*A22^H )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = Conj(A(i_ + i1_, Offs + i))
                    Next i_
                    For J = 0# To i - 1# Step 1
                        V = A(Offs + J, Offs + i)
                        i1_ = (J) - (Offs + J)
                        For i_ = Offs + J To Offs + i - 1# Step 1
                            A(Offs + J, i_) = C_Add(A(Offs + J, i_), C_Mul(V, Tmp(i_ + i1_)))
                        Next i_
                    Next J
                    V = Conj(A(Offs + i, Offs + i))
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(i_, Offs + i) = C_Mul(V, A(i_, Offs + i))
                    Next i_
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).Y))
                End If
            Next i
        Else
            
            '
            ' Compute the product L' * L
            ' NOTE: we never assume that diagonal of L is real
            '
            For i = 0# To N - 1# Step 1
                If i = 0# Then
                    
                    '
                    ' 1x1 matrix
                    '
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).Y))
                Else
                    
                    '
                    ' (I+1)x(I+1) matrix,
                    '
                    ' ( A11^H  A21^H )   ( A11      )   ( A11^H*A11+A21^H*A21  A21^H*A22 )
                    ' (              ) * (          ) = (                                )
                    ' (        A22^H )   ( A21  A22 )   ( A22^H*A21            A22^H*A22 )
                    '
                    ' A11 is IxI, A22 is 1x1.
                    '
                    i1_ = (Offs) - (0#)
                    For i_ = 0# To i - 1# Step 1
                        Tmp(i_) = A(Offs + i, i_ + i1_)
                    Next i_
                    For J = 0# To i - 1# Step 1
                        V = Conj(A(Offs + i, Offs + J))
                        i1_ = (0#) - (Offs)
                        For i_ = Offs To Offs + J Step 1
                            A(Offs + J, i_) = C_Add(A(Offs + J, i_), C_Mul(V, Tmp(i_ + i1_)))
                        Next i_
                    Next J
                    V = Conj(A(Offs + i, Offs + i))
                    For i_ = Offs To Offs + i - 1# Step 1
                        A(Offs + i, i_) = C_Mul(V, A(Offs + i, i_))
                    Next i_
                    A(Offs + i, Offs + i) = C_Complex(Square(A(Offs + i, Offs + i).X) + Square(A(Offs + i, Offs + i).Y))
                End If
            Next i
        End If
        Exit Sub
    End If
    
    '
    ' Recursive code: triangular factor inversion merged with
    ' UU' or L'L multiplication
    '
    Call ABLASComplexSplitLength(A, N, N1, N2)
    
    '
    ' form off-diagonal block of trangular inverse
    '
    If IsUpper Then
        For i = 0# To N1 - 1# Step 1
            For i_ = Offs + N1 To Offs + N - 1# Step 1
                A(Offs + i, i_) = C_MulR(A(Offs + i, i_), -1)
            Next i_
        Next i
        Call CMatrixLeftTRSM(N1, N2, A, Offs, Offs, IsUpper, False, 0#, A, Offs, Offs + N1)
        Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs, Offs + N1)
    Else
        For i = 0# To N2 - 1# Step 1
            For i_ = Offs To Offs + N1 - 1# Step 1
                A(Offs + N1 + i, i_) = C_MulR(A(Offs + N1 + i, i_), -1)
            Next i_
        Next i
        Call CMatrixRightTRSM(N2, N1, A, Offs, Offs, IsUpper, False, 0#, A, Offs + N1, Offs)
        Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 0#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert first diagonal block
    '
    Call HPDMatrixCholeskyInverseRec(A, Offs, N1, IsUpper, Tmp)
    
    '
    ' update first diagonal block with off-diagonal block,
    ' update off-diagonal block
    '
    If IsUpper Then
        Call CMatrixSYRK(N1, N2, 1#, A, Offs, Offs + N1, 0#, 1#, A, Offs, Offs, IsUpper)
        Call CMatrixRightTRSM(N1, N2, A, Offs + N1, Offs + N1, IsUpper, False, 2#, A, Offs, Offs + N1)
    Else
        Call CMatrixSYRK(N1, N2, 1#, A, Offs + N1, Offs, 2#, 1#, A, Offs, Offs, IsUpper)
        Call CMatrixLeftTRSM(N2, N1, A, Offs + N1, Offs + N1, IsUpper, False, 2#, A, Offs + N1, Offs)
    End If
    
    '
    ' invert second diagonal block
    '
    Call HPDMatrixCholeskyInverseRec(A, Offs + N1, N2, IsUpper, Tmp)
End Sub
