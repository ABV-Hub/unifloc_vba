'=======================================================================================
'Unifloc 7.10  Apodemus agrarius                                      khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' функции для работы с кривыми из интерфейса Excel
Option Explicit
Option Base 1
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция поиска значения функции по заданным табличным данным (интерполяция)
Public Function crv_interpolation(x_points, y_points, x_val, _
                        Optional ByVal type_interpolation As Integer = 0)
' x_points  - таблица аргументов функции
' y_points  - таблица значений функции
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' x_val     - аргумент для которого надо найти значение
'             одно значение в ячейке или диапазон значений
'             для диапазона аргументов будет найден диапазон значений
'             диапазоны могут быть заданы как в строках,
'             так и в столбцах
' type_interpolation - тип интерполяции
'                    0 - линейная интерполяция
'                    1 - кубическая интерполяция
'                    2 - интерполяция Акима (выбросы)
'                        https://en.wikipedia.org/wiki/Akima_spline
'                    3 - кубический сплай Катмулла Рома
'                        https://en.wikipedia.org/wiki/Cubic_Hermite_spline
' результат
'             значение функции для заданного x_val
'description_end
    Dim x_arr(), y_arr(), x_val_arr(), y_out()
    Dim y_val_temp
    Dim X_Range As Range
    Dim Y_Range As Range
    Dim i As Integer
    Dim crv As New CInterpolation
    Dim interp_type As String
    
On Error GoTo err1:
        
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x_points, y_points, x_val, x_arr, y_arr, x_val_arr, y_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x_arr)
        crv.AddPoint x_arr(i), y_arr(i)
    Next i
    
    ' готовим интерполяцию
    Select Case type_interpolation
        Case 0
            interp_type = "Linear"
        Case 1
            interp_type = "Cubic"
        Case 2
            interp_type = "Akima"
        Case 3
            interp_type = "CatmullRom"
    End Select
           
    crv.init_interpolation interp_type
    
    ' интерполируем требуемые данные и готовим для вывода массива значений
    For i = LBound(x_val_arr) To UBound(x_val_arr)
        y_val_temp = crv.get_interpolation_point(x_val_arr(i))
        If UBound(y_out, 1) > 1 Then
            y_out(i, LBound(y_out)) = y_val_temp
        Else
            y_out(LBound(y_out), i) = y_val_temp
        End If
    Next i
    crv_interpolation = y_out
    
    Exit Function
err1:
    crv_interpolation = "error"
    addLogMsg "Error:crv_interpolation:" & Err.Description
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция решения уравнения в табличном виде f(x) = y_val
' ищется значение аргумента соответствующее заданному значению
' используется линейная интерполяция
' возможно несколько решений
Public Function crv_solve(x_points, y_points, ByVal y_val As Double)
' x_points  - таблица аргументов функции
' y_points  - таблица значений функции
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' y_val     - значение функции для которого надо ищутся аргументы
'             строго одно вещественное число (ссылка на ячейку)
' результат
'             массив значений аргументов - решений уравнения
'description_end
    Dim x_arr(), y_arr(), y_val_arr(), x_out()
    Dim n_y_val As Integer
    Dim i As Integer
    Dim crv As New CInterpolation
On Error GoTo err1:
        
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x_points, y_points, 0, x_arr, y_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x_arr)
        crv.AddPoint x_arr(i), y_arr(i)
    Next i
            
    ' только для первого элемента ищем
    
    n_y_val = crv.FindSolutions(y_val)
    ReDim x_out(1 To n_y_val)
    
    For i = 1 To n_y_val
        x_out(i) = crv.SolutionPointX(i)
    Next i
    
    crv_solve = x_out
    
    Exit Function
err1:
    crv_solve = "error"
    addLogMsg "Error:crv_solve:" & Err.Description
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' поиск пересечений для кривых заданных таблицами
' используется линейная интерполяция
' возможно несколько решений
Public Function crv_intersection(x1_points, y1_points, _
                                 x2_points, y2_points)
' x1_points  - таблица аргументов функции 1
' y1_points  - таблица значений функции 1
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' x2_points  - таблица аргументов функции 2
' y2_points  - таблица значений функции 2
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' результат
'             массив значений аргументов пересечений двух функций
'description_end
'description_end
    Dim x1_arr(), y1_arr(), y_val_arr(), x_out()
    Dim x2_arr(), y2_arr()
    Dim n_y_val As Integer
    Dim i As Integer
    Dim crv1 As New CInterpolation
    Dim crv2 As New CInterpolation
    Dim crv As CInterpolation
On Error GoTo err1:
        
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x1_points, y1_points, 0, x1_arr, y1_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x1_arr)
        crv1.AddPoint x1_arr(i), y1_arr(i)
    Next i
            
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x2_points, y2_points, 0, x2_arr, y2_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x2_arr)
        crv2.AddPoint x2_arr(i), y2_arr(i)
    Next i
            
    Set crv = crv1.SubtractCurve(crv2)
    ' только для первого элемента ищем
    
    n_y_val = crv.FindSolutions(0)
    ReDim x_out(1 To n_y_val)
    
    For i = 1 To n_y_val
        x_out(i) = crv.SolutionPointX(i)
    Next i
    
    crv_intersection = x_out
    
    Exit Function
err1:
    crv_intersection = "error:" & Err.Description
    addLogMsg "Error:crv_intersection:" & Err.Description
End Function
' рабочая функция для чтения данных кривых из range
Private Sub read_xy_vectors(x_points, y_points, x_val, _
                                ByRef x_arr(), _
                                ByRef y_arr(), _
                                ByRef x_val_arr(), _
                                ByRef y_val_arr())
                               
Dim X_Range As Range
Dim Y_Range As Range
Dim x_val_range As Range
Dim check_x As Boolean
Dim check_y As Boolean
Dim msg As String, fname As String
On Error GoTo err1:
    ' проверим что на входе range объекты
    If (IsObject(x_points)) And (IsObject(y_points)) Then
        Set X_Range = x_points
        Set Y_Range = y_points
        
        ' проверим что данные заданы в строке для вектора аргументов
        If X_Range.Rows.Count = 1 And X_Range.Columns.Count > 1 Then
            x_arr = Application.Transpose(Application.Transpose(X_Range))
        ' если не в строке, то проверим столбец
        ElseIf X_Range.Rows.Count > 1 And X_Range.Columns.Count = 1 Then
            x_arr = Application.Transpose(X_Range)
        ' если не удалось найти или один столбец или одну строку то плохо
        Else
            msg = "first data set must be in row or column"
            GoTo err1:
        End If
        
        ' проверим что данные заданы в строке для вектора аргументов
        If Y_Range.Rows.Count = 1 And Y_Range.Columns.Count > 1 Then
            y_arr = Application.Transpose(Application.Transpose(Y_Range))
        ' если не в строке, то проверим столбец
        ElseIf Y_Range.Rows.Count > 1 And Y_Range.Columns.Count = 1 Then
            y_arr = Application.Transpose(Y_Range)
        ' если не удалось найти или один столбец или одну строку то плохо
        Else
            msg = "second data set must be in row or column"
            GoTo err1:
        End If
        
    Else
        If IsArray(x_points) And IsArray(y_points) Then
            check_x = (UBound(x_points, 1) > 1 And UBound(x_points, 2) = 0)
            check_y = (UBound(y_points, 1) > 1 And UBound(y_points, 2) = 0)
            If Not (check_x And check_y) Then GoTo err1:
        End If
    End If
    ' Ожидаем, что веркторы одинаковой размерности
    If Not (UBound(x_arr) = UBound(y_arr)) Then
        msg = "vectors must be same dimension"
        GoTo err1:
    End If
    
    ' проверим искомое значение
    If (IsObject(x_val)) Then
        Set x_val_range = x_val
        ' проверим что данные заданы в строке для вектора аргументов
        If x_val_range.Rows.Count = 1 And x_val_range.Columns.Count > 1 Then
            x_val_arr = Application.Transpose(Application.Transpose(x_val_range))
            ReDim y_val_arr(1, UBound(x_val_arr))
        ' если не в строке, то проверим столбец
        ElseIf x_val_range.Rows.Count > 1 And x_val_range.Columns.Count = 1 Then
            x_val_arr = Application.Transpose(x_val_range)
            ReDim y_val_arr(UBound(x_val_arr), 1)
        ' если не удалось найти или один столбец или одну строку то плохо
        ElseIf x_val_range.Rows.Count = 1 And x_val_range.Columns.Count = 1 Then
            ReDim x_val_arr(1)
            x_val_arr(1) = x_val_range.Value2
            ReDim y_val_arr(1, 1)
        End If
    Else
        ReDim x_val_arr(1)
        x_val_arr(1) = x_val
        ReDim y_val_arr(1, 1)
    End If
    Exit Sub
err1:
    ' унифицированная реакция на ошибочный ввод ключевых параметров класса
    
    fname = "read_xy_vectors"
    msg = fname & ": " & msg
    addLogMsg msg
    Err.Raise kreadRangeError, fname, msg
End Sub
