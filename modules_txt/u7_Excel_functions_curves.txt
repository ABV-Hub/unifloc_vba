'=======================================================================================
'Unifloc 7.8  Vulpes zerda                                      khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' функции для работы с кривыми из интерфейса Excel
Option Explicit
Option Base 1
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция поиска значения функции по заданным табличным данным (интерполяция)
Public Function crv_interpolation(x_points, y_points, x_val, _
                        Optional ByVal type_interpolation As Integer = 0)
' x_points  - таблица аргументов функции
' y_points  - таблица значений функции
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' x_val     - аргумент для которого надо найти значение
'             одно значение в ячейке или диапазон значений
'             для диапазона аргументов будет найден диапазон значений
'             диапазоны могут быть заданы как в строках,
'             так и в столбцах
' type_interpolation - тип интерполяции
'                    0 - линейная интерполяция
'                    1 - кубическая интерполяция
'                    2 - интерполяция Акима (выбросы)
'                        https://en.wikipedia.org/wiki/Akima_spline
'                    3 - кубический сплай Катмулла Рома
'                        https://en.wikipedia.org/wiki/Cubic_Hermite_spline
' результат
'             значение функции для заданного x_val
'description_end
    Dim x_arr(), y_arr(), x_val_arr(), y_out()
    Dim y_val_temp
    Dim x_range As Range
    Dim y_range As Range
    Dim i As Integer
    Dim crv As New TInterpolation
    Dim interp_type As String
    
On Error GoTo err1:
        
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x_points, y_points, x_val, x_arr, y_arr, x_val_arr, y_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x_arr)
        crv.AddPoint x_arr(i), y_arr(i)
    Next i
    
    ' готовим интерполяцию
    Select Case type_interpolation
        Case 0
            interp_type = "Linear"
        Case 1
            interp_type = "Cubic"
        Case 2
            interp_type = "Akima"
        Case 3
            interp_type = "CatmullRom"
    End Select
           
    crv.init_interpolation interp_type
    
    ' интерполируем требуемые данные и готовим для вывода массива значений
    For i = LBound(x_val_arr) To UBound(x_val_arr)
        y_val_temp = crv.get_interpolation_point(x_val_arr(i))
        If UBound(y_out, 1) > 1 Then
            y_out(i, LBound(y_out)) = y_val_temp
        Else
            y_out(LBound(y_out), i) = y_val_temp
        End If
    Next i
    crv_interpolation = y_out
    
    Exit Function
err1:
    crv_interpolation = "error"
    addLogMsg "Error:crv_interpolation:" & Err.Description
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция решения уравнения в табличном виде f(x) = y_val
' ищется значение аргумента соответствующее заданному значению
' используется линейная интерполяция
' возможно несколько решений
Public Function crv_solve(x_points, y_points, ByVal y_val As Double)
' x_points  - таблица аргументов функции
' y_points  - таблица значений функции
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' y_val     - значение функции для которого надо ищутся аргументы
'             строго одно вещественное число (ссылка на ячейку)
' результат
'             массив значений аргументов - решений уравнения
'description_end
    Dim x_arr(), y_arr(), y_val_arr(), x_out()
    Dim n_y_val As Integer
    Dim i As Integer
    Dim crv As New TInterpolation
On Error GoTo err1:
        
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x_points, y_points, 0, x_arr, y_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x_arr)
        crv.AddPoint x_arr(i), y_arr(i)
    Next i
            
    ' только для первого элемента ищем
    
    n_y_val = crv.FindSolutions(y_val)
    ReDim x_out(1 To n_y_val)
    
    For i = 1 To n_y_val
        x_out(i) = crv.SolutionPointX(i)
    Next i
    
    crv_solve = x_out
    
    Exit Function
err1:
    crv_solve = "error"
    addLogMsg "Error:crv_solve:" & Err.Description
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' поиск пересечений для кривых заданных таблицами
' используется линейная интерполяция
' возможно несколько решений
Public Function crv_intersection(x1_points, y1_points, _
                                 x2_points, y2_points)
' x1_points  - таблица аргументов функции 1
' y1_points  - таблица значений функции 1
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' x2_points  - таблица аргументов функции 2
' y2_points  - таблица значений функции 2
'             количество агрументов и значений функции должно совпадать
'             для табличной функции одному аргументу соответствует
'             строго одно значение функции (последнее)
' результат
'             массив значений аргументов пересечений двух функций
'description_end
'description_end
    Dim x1_arr(), y1_arr(), y_val_arr(), x_out()
    Dim x2_arr(), y2_arr()
    Dim n_y_val As Integer
    Dim i As Integer
    Dim crv1 As New TInterpolation
    Dim crv2 As New TInterpolation
    Dim crv As TInterpolation
On Error GoTo err1:
        
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x1_points, y1_points, 0, x1_arr, y1_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x1_arr)
        crv1.AddPoint x1_arr(i), y1_arr(i)
    Next i
            
    ' прочитаем все исходные вектора с листа и подготовим выходной массив
    Call read_xy_vectors(x2_points, y2_points, 0, x2_arr, y2_arr, y_val_arr, x_out)
    ' формируем объект функции для работы с ним
    For i = 1 To UBound(x2_arr)
        crv2.AddPoint x2_arr(i), y2_arr(i)
    Next i
            
    Set crv = crv1.SubtractCurve(crv2)
    ' только для первого элемента ищем
    
    n_y_val = crv.FindSolutions(0)
    ReDim x_out(1 To n_y_val)
    
    For i = 1 To n_y_val
        x_out(i) = crv.SolutionPointX(i)
    Next i
    
    crv_intersection = x_out
    
    Exit Function
err1:
    crv_intersection = "error"
    addLogMsg "Error:crv_intersection:" & Err.Description
End Function
' рабочая функция для чтения данных кривых из range
Private Sub read_xy_vectors(x_points, y_points, x_val, _
                                ByRef x_arr(), _
                                ByRef y_arr(), _
                                ByRef x_val_arr(), _
                                ByRef y_val_arr())
                               
Dim x_range As Range
Dim y_range As Range
Dim x_val_range As Range
Dim check_x As Boolean
Dim check_y As Boolean
On Error GoTo err1:
    ' проверим что на входе range объекты
    If (IsObject(x_points)) And (IsObject(y_points)) Then
        Set x_range = x_points
        Set y_range = y_points
        
        ' проверим что данные заданы в строке для вектора аргументов
        If x_range.Rows.Count = 1 And x_range.Columns.Count > 1 Then
            x_arr = Application.Transpose(Application.Transpose(x_range))
        ' если не в строке, то проверим столбец
        ElseIf x_range.Rows.Count > 1 And x_range.Columns.Count = 1 Then
            x_arr = Application.Transpose(x_range)
        ' если не удалось найти или один столбец или одну строку то плохо
        Else
            GoTo err1:
        End If
        
        ' проверим что данные заданы в строке для вектора аргументов
        If y_range.Rows.Count = 1 And y_range.Columns.Count > 1 Then
            y_arr = Application.Transpose(Application.Transpose(y_range))
        ' если не в строке, то проверим столбец
        ElseIf y_range.Rows.Count > 1 And y_range.Columns.Count = 1 Then
            y_arr = Application.Transpose(y_range)
        ' если не удалось найти или один столбец или одну строку то плохо
        Else
            GoTo err1:
        End If
        
    Else
        If IsArray(x_points) And IsArray(y_points) Then
            check_x = (UBound(x_points, 1) > 1 And UBound(x_points, 2) = 0)
            check_y = (UBound(y_points, 1) > 1 And UBound(y_points, 2) = 0)
            If Not (check_x And check_y) Then GoTo err1:
        End If
    End If
    ' Ожидаем, что веркторы одинаковой размерности
    If Not (UBound(x_arr) = UBound(y_arr)) Then GoTo err1:
    
    
    ' проверим искомое значение
    If (IsObject(x_val)) Then
        Set x_val_range = x_val
        ' проверим что данные заданы в строке для вектора аргументов
        If x_val_range.Rows.Count = 1 And x_val_range.Columns.Count > 1 Then
            x_val_arr = Application.Transpose(Application.Transpose(x_val_range))
            ReDim y_val_arr(1, UBound(x_val_arr))
        ' если не в строке, то проверим столбец
        ElseIf x_val_range.Rows.Count > 1 And x_val_range.Columns.Count = 1 Then
            x_val_arr = Application.Transpose(x_val_range)
            ReDim y_val_arr(UBound(x_val_arr), 1)
        ' если не удалось найти или один столбец или одну строку то плохо
        ElseIf x_val_range.Rows.Count = 1 And x_val_range.Columns.Count = 1 Then
            ReDim x_val_arr(1)
            x_val_arr(1) = x_val_range.Value2
            ReDim y_val_arr(1, 1)
        End If
    End If
    Exit Sub
err1:
    ' унифицированная реакция на ошибочный ввод ключевых параметров класса
    Dim msg As String, fname As String
    fname = "read_xy_vectors"
    msg = fname & ": input - wrong "
    addLogMsg msg
    Err.Raise kreadRangeError, fname, msg
End Sub
Sub Description_crv()
' функция определения описания для интерфейса Excel
' достаточно вызвать один раз для того, чтобы поменять описание
' лучше вызывать функцию u7_descriptions.Задать_описания если надо поменять описания
On Error Resume Next
              
Application.MacroOptions _
        Macro:="crv_interpolation", _
        Description:="Возвращает значение функции заданной таблично по значению аргумента. Значение интерполируется по табличным данным, линейно или кубическими сплайнами", _
        Category:="Таблицы функции", _
        ArgumentDescriptions:=Array( _
            "Таблица аргументов. Одна строка или один столбец. Желательно более 5 значений (чтобы работали все методы интерполяции)", _
            "Таблица значений. Одна строка или один столбец. Число значений функции и аргументов должно совпадать", _
            "Значение аргумента для которого будет определено значение функции. Число или диапазон чисел (для диапазона чисел вернется диапазон ответов)", _
            "Тип интерполяции. По умолчанию 0 - линейная. 1 - кубический сплайн. 2 - кубический сплайн Акима (для выбросов). 3 - кубический сплайн Catmull Rom" _
            )
        
 Application.MacroOptions _
        Macro:="crv_solve", _
        Description:="Возвращает значения аргументов функции заданной таблично по значению функции. Решает уравнение f(x) = y. Значение интерполируется по табличным данным линейно", _
        Category:="Таблицы функции", _
        ArgumentDescriptions:=Array( _
            "Таблица аргументов. Одна строка или один столбец.", _
            "Таблица значений. Одна строка или один столбец. Число значений функции и аргументов должно совпадать", _
            "Значение функции для которого будет определено значение аргумента." _
            )
            
  Application.MacroOptions _
        Macro:="crv_intersection", _
        Description:="Поиск пересечений для кривых заданных таблицами. Основан на линейной интерполяции кривых", _
        Category:="Таблицы функции", _
        ArgumentDescriptions:=Array( _
            "Таблица аргументов первой кривой. Одна строка или один столбец.", _
            "Таблица значений первой кривой. Одна строка или один столбец. Число значений функции и аргументов должно совпадать", _
            "Таблица аргументов второй кривой. Одна строка или один столбец.", _
            "Таблица значений второй кривой. Одна строка или один столбец. Число значений функции и аргументов должно совпадать" _
            )
          
End Sub
